<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Inara - Play Online</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        /* Prevent zoom issues on orientation change */
        html {
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --obsidian: #0d0d0f;
            --onyx: #1a1a1f;
            --slate: #2d2d35;
            --silver: #9ca3af;
            --pearl: #f0ebe3;
            --gold: #c9a227;
            --gold-glow: rgba(201, 162, 39, 0.4);
            --bronze: #8b6914;
            --light-square: #d4c4a8;
            --dark-square: #5c4d3a;
            --highlight: rgba(255, 255, 255, 0.5);
            --move-highlight: rgba(74, 222, 128, 0.5);
            --glyph-white: #f5f5f5;
            --glyph-orange: #e67e22;
            --glyph-blue: #3498db;
            --accent: #ffffff;
            --accent-glow: rgba(255, 255, 255, 0.4);
            --glyph-tan: #d4b896;
            --glyph-charcoal: #2a2a2f;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--obsidian);
            color: var(--pearl);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Subtle texture overlay */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(201, 162, 39, 0.03) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(139, 105, 20, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 20px;
            animation: fadeDown 0.8s ease-out;
        }

        @keyframes fadeDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 600;
            color: var(--accent);
            letter-spacing: 0.2em;
            text-shadow: 0 0 40px var(--accent-glow);
        }

        /* Header Layout */
        .header-content {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* Menu Button */
        .menu-btn {
            position: absolute;
            left: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            transition: opacity 0.2s;
        }

        .menu-btn:hover {
            opacity: 0.7;
        }

        .flip-btn {
            position: absolute;
            right: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            font-size: 20px;
            color: var(--pearl);
            transition: opacity 0.2s;
        }

        .flip-btn:hover {
            opacity: 0.7;
        }

        .menu-btn span {
            display: block;
            width: 24px;
            height: 2px;
            background: var(--pearl);
            border-radius: 1px;
            transition: opacity 0.3s, transform 0.3s;
        }

        .menu-btn.open span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .menu-btn.open span:nth-child(2) {
            opacity: 0;
        }

        .menu-btn.open span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Dropdown Menu */
        .menu-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--onyx);
            border: 1px solid var(--slate);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, background 0.2s ease;
            z-index: 1000;
        }

        .menu-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(5px);
        }

        .menu-dropdown button {
            display: block;
            width: 100%;
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: var(--pearl);
            font-family: inherit;
            font-size: 0.95rem;
            text-align: left;
            cursor: pointer;
            transition: background 0.2s;
        }

        .menu-dropdown button:hover {
            background: var(--slate);
        }

        .menu-dropdown hr {
            border: none;
            border-top: 1px solid var(--slate);
            margin: 8px 0;
        }
        
        .lang-btn {
            padding: 6px 12px;
            background: var(--slate);
            border: 1px solid var(--silver);
            border-radius: 4px;
            color: var(--pearl);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .lang-btn:hover {
            background: var(--accent);
        }
        
        .lang-btn.active {
            background: var(--gold);
            color: var(--onyx);
            border-color: var(--gold);
        }
        
        .tutorial-lang-select {
            text-align: center;
            padding: 40px 20px;
        }

        /* Copyright Footer */
        .copyright {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            font-size: 0.8rem;
            color: var(--silver);
            opacity: 0.6;
            letter-spacing: 0.05em;
        }

        /* Game Layout */
        .game-area {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 30px;
            align-items: start;
            animation: fadeIn 1s ease-out 0.3s both;
        }

        /* Tutorial console - positioned left of board on desktop */
        .game-area.tutorial-active {
            grid-template-columns: 280px 380px 1fr;
        }

        .left-sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Default order within left-sidebar: Light, Dark, History */
        #lightPanel { order: 1; }
        #darkPanel { order: 2; }
        #moveHistoryPanel { order: 3; }

        .left-sidebar.flipped #lightPanel {
            order: 2;
        }

        .left-sidebar.flipped #darkPanel {
            order: 1;
        }

        .left-sidebar.flipped #moveHistoryPanel {
            order: 4;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Player Panels */
        .player-panel {
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 1px solid var(--slate);
            border-radius: 12px;
            padding: 12px 16px;
            transition: opacity 0.4s ease, border-color 0.4s ease;
            opacity: 0.6;
            position: relative;
            overflow: hidden;
        }

        .player-panel::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, transparent, rgba(201, 162, 39, 0.02));
            pointer-events: none;
        }

        .player-panel.active {
            opacity: 1;
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow), inset 0 0 20px rgba(255, 255, 255, 0.03);
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Icon Buttons */
        .icon-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--slate);
            background: var(--obsidian);
            color: var(--silver);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease, background 0.2s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .icon-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .icon-btn.paused {
            background: var(--accent);
            color: var(--obsidian);
            border-color: var(--accent);
        }

        .icon-btn.resign-btn:hover {
            border-color: #ef4444;
            color: #ef4444;
        }

        .player-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent);
            letter-spacing: 0.05em;
        }

        .lives-display {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--pearl);
            background: var(--obsidian);
            padding: 3px 8px;
            border-radius: 6px;
            border: 1px solid var(--slate);
            display: none; /* Hidden by default for sudden death */
        }

        .lives-display.visible {
            display: inline-flex;
            align-items: center;
            gap: 3px;
        }

        .breakthrough-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: var(--onyx);
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 20px 32px;
            text-align: center;
            color: var(--pearl);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 0 30px rgba(201, 162, 39, 0.3);
        }

        .breakthrough-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .player-name-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-clock {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            font-size: 0.9rem;
            color: var(--silver);
            background: var(--obsidian);
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid var(--slate);
        }

        .player-panel.active .player-clock {
            color: var(--accent);
            border-color: var(--accent);
        }

        .player-clock.warning {
            color: #ef4444;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            to { opacity: 0.6; }
        }

        /* Shadow Button - positioned in glyphs row */
        .shadow-btn {
            width: 52px;
            height: 52px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.2s ease, background 0.2s ease;
            border: 2px dashed;
            font-size: 20px;
            font-weight: 600;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .shadow-btn.light-shadow-btn {
            background: linear-gradient(145deg, #d4c4a8 0%, #c4b498 100%);
            border-color: #a09070;
            color: var(--obsidian);
        }

        .shadow-btn.dark-shadow-btn {
            background: linear-gradient(145deg, #6d5d4a 0%, var(--dark-square) 100%);
            border-color: #4a3d2e;
            color: var(--pearl);
        }

        .shadow-btn:hover:not(.locked):not(.disabled) {
            transform: scale(1.05);
        }

        .shadow-btn.primed {
            box-shadow: 0 0 12px var(--accent-glow);
            border-color: var(--accent);
            border-style: solid;
        }

        .shadow-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .shadow-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shadow-btn .shadow-count {
            line-height: 1;
        }

        /* Glyphs Row - Resting on left, Hand centered, Shadow on right */
        .glyphs-row {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            position: relative;
            min-height: 56px;
        }

        .resting-area {
            display: flex;
            position: absolute;
            left: 0;
            align-items: center;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .player-panel.active .resting-area {
            opacity: 1;
        }

        .hand-center {
            display: flex;
            gap: 10px;
            justify-content: center;
            grid-column: 2;
            padding-left: 70px; /* Space for resting glyph */
        }

        .shadow-area {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            opacity: 0.4;
            transition: opacity 0.2s ease;
            grid-column: 3;
        }

        .player-panel.active .shadow-area {
            opacity: 1;
        }

        .resting-arrow {
            color: var(--accent);
            font-size: 14px;
            opacity: 0.7;
            font-family: system-ui, sans-serif;
        }

        .resting-arrow::before {
            content: 'â€º';
            font-size: 20px;
            font-weight: 300;
        }

        /* Desktop Resting Area - no longer used, resting glyphs now in player panels */
        .desktop-resting-area {
            display: none;
        }

        .glyph-hand {
            display: flex;
            gap: 8px;
        }

        .glyph {
            width: 52px;
            height: 52px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: var(--glyph-tan);
            border: 2px solid rgba(0, 0, 0, 0.2);
            transition: opacity 0.2s ease, background 0.2s ease;
            position: relative;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .glyph:hover:not(.resting):not(.disabled) {
            transform: translateY(-2px);
            border-color: var(--accent);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        .glyph.selected {
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow), 0 0 30px var(--accent-glow);
            transform: scale(1.08);
        }

        .glyph.selectable {
            border-color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow), 0 0 25px var(--accent-glow), inset 0 0 15px rgba(74, 222, 128, 0.3);
            animation: glyphPulse 1.5s ease-in-out infinite;
        }

        @keyframes glyphPulse {
            0%, 100% { 
                box-shadow: 0 0 12px var(--accent-glow), 0 0 25px var(--accent-glow), inset 0 0 15px rgba(74, 222, 128, 0.3);
            }
            50% { 
                box-shadow: 0 0 18px var(--accent-glow), 0 0 35px var(--accent-glow), inset 0 0 20px rgba(74, 222, 128, 0.5);
            }
        }

        .glyph.choice-required {
            border-color: rgb(147, 51, 234);
            box-shadow: 0 0 12px rgba(147, 51, 234, 0.6), 0 0 25px rgba(147, 51, 234, 0.4), inset 0 0 15px rgba(147, 51, 234, 0.3);
            animation: glyphChoicePulse 1.5s ease-in-out infinite;
        }

        @keyframes glyphChoicePulse {
            0%, 100% { 
                box-shadow: 0 0 12px rgba(147, 51, 234, 0.6), 0 0 25px rgba(147, 51, 234, 0.4), inset 0 0 15px rgba(147, 51, 234, 0.3);
            }
            50% { 
                box-shadow: 0 0 18px rgba(147, 51, 234, 0.8), 0 0 35px rgba(147, 51, 234, 0.6), inset 0 0 20px rgba(147, 51, 234, 0.5);
            }
        }

        .glyph.flash {
            animation: glyphFlash 0.15s ease-in-out 3;
        }

        @keyframes glyphFlash {
            0%, 100% { 
                box-shadow: 0 0 12px rgba(147, 51, 234, 0.6), 0 0 25px rgba(147, 51, 234, 0.4), inset 0 0 15px rgba(147, 51, 234, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 25px rgba(147, 51, 234, 1), 0 0 40px rgba(147, 51, 234, 0.7), inset 0 0 25px rgba(147, 51, 234, 0.6);
                transform: scale(1.1);
            }
        }

        .glyph.resting {
            opacity: 0.7;
            cursor: default;
        }

        .glyph.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Hand glyphs are bigger (about 38% bigger than resting) */
        .hand-center .glyph {
            width: 72px;
            height: 72px;
            border-radius: 12px;
        }

        .hand-center .glyph-shape {
            font-size: 34px;
        }

        .hand-center .glyph.color-glyph {
            /* Color glyphs in hand */
        }

        .hand-center .glyph.mirror {
            font-size: 34px;
        }

        .hand-center .mirror-shape {
            font-size: 34px;
        }

        .hand-center .mirror-color {
            width: 36px;
            height: 36px;
        }

        .glyph-shape {
            font-size: 24px;
            font-weight: 500;
            line-height: 1;
            color: var(--glyph-charcoal);
        }

        /* Color glyphs - solid fill */
        .glyph.color-glyph {
            border: 2px solid rgba(0, 0, 0, 0.3);
        }

        .glyph.mirror {
            background: linear-gradient(135deg, #5a5a62 0%, #3d3d45 50%, #5a5a62 100%);
            font-size: 24px;
        }

        /* Mirror content styling */
        .mirror-shape {
            font-size: 24px;
            font-weight: 500;
            color: #c0c0c8;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .mirror-color {
            width: 26px;
            height: 26px;
            border-radius: 4px;
            transform: rotate(45deg);
        }

        /* Masks Display */
        .masks-container {
            display: flex;
            gap: 3px;
            align-items: center;
        }

        .masks-scroller {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .masks-viewport {
            display: flex;
            gap: 3px;
            overflow: hidden;
            max-width: 108px; /* 3 masks * 32px + gaps */
        }

        .masks-scroll-btn {
            background: none;
            border: none;
            color: var(--silver);
            font-size: 10px;
            cursor: pointer;
            padding: 2px 4px;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .masks-scroll-btn:hover {
            opacity: 1;
        }

        .masks-scroll-btn:disabled {
            opacity: 0.2;
            cursor: not-allowed;
        }

        .mask-piece {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s ease, background 0.2s ease;
        }

        .mask-piece.dark-mask {
            background: linear-gradient(135deg, #2a2a30 0%, #1a1a1f 100%);
            border: 2px solid #3a3a40;
            color: var(--accent);
        }

        .mask-piece.light-mask {
            background: linear-gradient(135deg, #d4c4a8 0%, #c4b498 100%);
            border: 2px solid #a09070;
            color: var(--obsidian);
        }

        .mask-piece.dimmed {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .mask-piece.available {
            cursor: pointer;
            opacity: 1;
        }

        .mask-piece.available:hover {
            transform: scale(1.1);
            box-shadow: 0 0 8px var(--accent-glow);
        }

        .mask-piece.selected {
            box-shadow: 0 0 12px var(--accent-glow);
            border-color: var(--accent);
            transform: scale(1.1);
        }

        /* Board Container */
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: min(560px, calc(100vw - 24px));
            aspect-ratio: 1;
            border: 4px solid var(--silver);
            border-radius: 4px;
            box-shadow: 
                0 0 60px rgba(255, 255, 255, 0.1),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            touch-action: manipulation;
            contain: layout style paint;
            transition: transform 0.3s ease;
        }

        .board.flipped {
            transform: rotate(180deg);
        }

        .board.flipped .square {
            transform: rotate(180deg);
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: box-shadow 0.15s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            contain: layout style;
        }

        .square .coord {
            position: absolute;
            font-size: 9px;
            font-weight: 500;
            opacity: 0.6;
            pointer-events: none;
        }

        .square .coord-file {
            bottom: 2px;
            right: 3px;
        }

        .square .coord-rank {
            top: 2px;
            left: 3px;
        }

        /* When flipped, coords rotate with square, so reposition to opposite corners */
        .board.flipped .square .coord-file {
            bottom: auto;
            right: auto;
            top: 2px;
            left: 3px;
        }

        .board.flipped .square .coord-rank {
            top: auto;
            left: auto;
            bottom: 2px;
            right: 3px;
        }

        .square.light .coord {
            color: var(--light-square);
        }

        .square.dark .coord {
            color: var(--dark-square);
        }

        .square.light {
            background: var(--dark-square);
        }

        .square.dark {
            background: var(--light-square);
        }

        .square:hover {
            filter: brightness(1.1);
        }

        .square.selectable {
            box-shadow: inset 0 0 20px var(--highlight);
        }

        .square.highlighted {
            box-shadow: inset 0 0 25px var(--move-highlight);
        }

        .square.highlighted::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(74, 222, 128, 0.6);
            border-radius: 50%;
        }

        .square.projected {
            box-shadow: inset 0 0 25px rgba(147, 51, 234, 0.5);
        }

        .square.projected::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(147, 51, 234, 0.6);
            border-radius: 50%;
        }

        .square.blocked-move {
            box-shadow: inset 0 0 25px rgba(239, 68, 68, 0.4);
        }

        .square.blocked-move::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(239, 68, 68, 0.5);
            border-radius: 50%;
        }



        .square.last-move-from {
            box-shadow: inset 0 0 0 3px rgba(250, 204, 21, 0.8);
        }

        .square.last-move-to .piece,
        .square.last-move-to .shadow-piece {
            box-shadow: 0 0 12px rgba(250, 204, 21, 0.7), 0 0 20px rgba(250, 204, 21, 0.4);
        }

        .square.reactivate-target {
            box-shadow: inset 0 0 20px rgba(147, 51, 234, 0.6);
        }

        /* Pieces */
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: grab;
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: clamp(16px, 3vw, 24px);
            font-weight: bold;
            z-index: 2;
        }

        .piece:active {
            cursor: grabbing;
        }

        .piece.dark-golem {
            background: linear-gradient(145deg, #6d5d4a 0%, var(--dark-square) 100%);
            border: 3px solid #4a3d2e;
            color: var(--pearl);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .piece.light-golem {
            background: linear-gradient(145deg, #d4c4a8 0%, #c4b498 100%);
            border: 3px solid #a09070;
            color: var(--obsidian);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .piece.selected {
            transform: scale(1.15);
            box-shadow: 0 0 25px var(--accent-glow), 0 8px 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .piece.blocked {
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.6), 0 8px 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .piece-shape {
            font-size: clamp(20px, 4vw, 28px);
            font-weight: 500;
            line-height: 1;
        }

        .shadow-piece {
            width: 60%;
            height: 60%;
            border-radius: 50%;
            border: 2px dashed;
            opacity: 0.7;
        }

        .shadow-piece.dark-shadow {
            background: linear-gradient(145deg, #6d5d4a 0%, var(--dark-square) 100%);
            border-color: #4a3d2e;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .shadow-piece.light-shadow {
            background: linear-gradient(145deg, #d4c4a8 0%, #c4b498 100%);
            border-color: #a09070;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Buttons (for modals) */
        .btn {
            background: linear-gradient(145deg, var(--pearl), #d4c4a8);
            color: var(--obsidian);
            border: none;
            padding: 12px 28px;
            font-size: 0.85rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: opacity 0.3s ease, transform 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 255, 255, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(145deg, var(--slate), var(--onyx));
            color: var(--pearl);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        /* Rules Button */
        /* Modal Base */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.3s ease-out;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 2px solid var(--gold);
            border-radius: 16px;
            padding: 32px;
            max-width: 700px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: slideUp 0.4s ease-out;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-content h2 {
            font-family: 'Philosopher', sans-serif;
            color: var(--gold);
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-content h3 {
            color: var(--gold);
            font-size: 1.2rem;
            margin: 24px 0 12px;
        }

        .modal-content p,
        .modal-content ul {
            line-height: 1.7;
            margin-bottom: 12px;
            color: var(--pearl);
        }

        .modal-content ul {
            padding-left: 24px;
        }

        .modal-content li {
            margin-bottom: 6px;
        }

        .close-modal {
            float: right;
            font-size: 28px;
            cursor: pointer;
            color: var(--silver);
            transition: color 0.2s;
            line-height: 1;
        }

        .close-modal:hover {
            color: var(--gold);
        }

        /* Rules Modal Tabs */
        .rules-modal-content {
            max-width: 600px;
        }

        .rules-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--slate);
            padding-bottom: 12px;
        }

        .rules-tab {
            background: transparent;
            border: 1px solid var(--slate);
            color: var(--silver);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .rules-tab:hover {
            border-color: var(--gold);
            color: var(--pearl);
        }

        .rules-tab.active {
            background: var(--gold);
            border-color: var(--gold);
            color: var(--obsidian);
            font-weight: 500;
        }

        .rules-tab-content {
            display: none;
        }

        .rules-tab-content.active {
            display: block;
        }

        .rules-tab-content h4 {
            color: var(--gold);
            font-size: 0.95rem;
            margin: 15px 0 8px 0;
            font-weight: 500;
        }

        .rules-tab-content ol {
            padding-left: 20px;
            margin: 10px 0;
        }

        .rules-tab-content ol li {
            margin-bottom: 8px;
        }

        .rules-tab-content ol ul {
            margin-top: 6px;
        }

        .rules-designer-note {
            margin-top: 30px;
            padding: 15px;
            background: var(--slate);
            border-radius: 8px;
            border-left: 3px solid var(--gold);
        }

        .rules-designer-note h4 {
            color: var(--gold);
            margin: 0 0 8px 0;
        }

        .rules-designer-note p {
            margin: 4px 0;
            font-style: italic;
        }

        /* Tutorial Modal - Non-interactive capsules */
        .tutorial-content {
            max-width: 500px;
            position: relative;
        }

        /* Tutorial Console - Interactive capsules */
        #tutorialConsole {
            display: none;
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 15px;
            max-width: 280px;
            align-self: start;
        }

        #tutorialConsole.show {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        #tutorialConsole h3 {
            font-family: 'Philosopher', sans-serif;
            color: var(--gold);
            font-size: 1.2rem;
            margin-bottom: 10px;
            text-align: center;
        }

        #tutorialConsole .tutorial-body {
            color: var(--pearl);
            line-height: 1.6;
            font-size: 0.9rem;
        }

        #tutorialConsole .tutorial-body p {
            margin-bottom: 10px;
        }

        #tutorialConsole .tutorial-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--slate);
        }

        .tutorial-nav-btn {
            background: var(--slate);
            border: none;
            color: var(--pearl);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: background 0.2s, opacity 0.2s;
        }

        .tutorial-nav-btn:hover:not(:disabled) {
            background: var(--accent);
            color: var(--obsidian);
        }

        .tutorial-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .tutorial-progress {
            color: var(--silver);
            font-size: 0.9rem;
        }

        .tutorial-capsule {
            display: none;
        }

        .tutorial-capsule.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .tutorial-capsule h2 {
            font-family: 'Philosopher', sans-serif;
            color: var(--gold);
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
        }

        .tutorial-body {
            color: var(--pearl);
            line-height: 1.7;
            font-size: 0.95rem;
        }

        .tutorial-body p {
            margin-bottom: 12px;
        }

        .tutorial-body ul {
            padding-left: 24px;
            margin-bottom: 12px;
        }

        .tutorial-body li {
            margin-bottom: 6px;
        }

        .tutorial-prompt {
            background: var(--slate);
            border-left: 3px solid var(--gold);
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            color: var(--accent);
        }

        .tutorial-reset-btn {
            display: inline-block;
            padding: 6px 12px;
            background: var(--slate);
            border: none;
            color: var(--pearl);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        .tutorial-reset-btn:hover {
            background: var(--accent);
            color: var(--obsidian);
        }

        .tutorial-continue-btn {
            display: inline-block;
            padding: 6px 16px;
            background: var(--gold);
            border: none;
            color: var(--obsidian);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: background 0.2s, opacity 0.2s;
        }

        .tutorial-continue-btn:hover:not(:disabled) {
            background: var(--accent);
        }

        .tutorial-continue-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .tutorial-checklist {
            list-style: none;
            padding-left: 0;
            margin: 10px 0;
        }

        .tutorial-checklist li {
            padding: 4px 0;
            color: var(--silver);
            transition: color 0.3s;
        }

        .tutorial-checklist li.completed {
            color: var(--accent);
        }

        /* Victory Modal */
        .victory-content {
            text-align: center;
            max-width: 450px;
        }

        .victory-content h2 {
            font-size: 2.5rem;
            text-shadow: 0 0 30px var(--gold-glow);
        }

        .victory-content p {
            font-size: 1.3rem;
            margin: 20px 0 30px;
        }

        /* Time Control Slider */
        .time-display {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 2.5rem;
            color: var(--accent);
            margin-bottom: 15px;
            font-weight: 600;
        }

        .time-display.increment-display {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .time-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--slate);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.15s ease;
        }

        .time-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .time-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .time-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--silver);
            opacity: 0.7;
        }

        /* Analysis Console */
        .analysis-ribbon {
            display: none;
            background: var(--onyx);
            border: 1px solid var(--slate);
            border-radius: 8px;
            padding: 10px 15px;
            margin-bottom: 15px;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .analysis-ribbon.show {
            display: flex;
        }

        .analysis-filename {
            width: 100%;
            font-size: 11px;
            color: var(--silver);
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .analysis-filename:empty {
            display: none;
        }

        .ribbon-nav {
            display: flex;
            gap: 5px;
        }

        .ribbon-btn {
            background: var(--slate);
            border: none;
            color: var(--pearl);
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .ribbon-btn:hover {
            background: var(--accent);
            color: var(--obsidian);
        }

        .ribbon-moves {
            display: flex;
            gap: 4px;
            flex-wrap: nowrap;
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 4px 0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        .ribbon-move {
            background: var(--slate);
            border: none;
            color: var(--pearl);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: opacity 0.2s, background 0.2s;
            white-space: nowrap;
        }

        .ribbon-move:hover {
            background: var(--silver);
            color: var(--obsidian);
        }

        .ribbon-move.active {
            background: var(--accent);
            color: var(--obsidian);
        }

        .ribbon-move.dark-move {
            border-left: 3px solid #4a4a52;
        }

        .ribbon-move.light-move {
            border-left: 3px solid #d4c4a8;
        }

        .ribbon-move-num {
            font-weight: 600;
            opacity: 0.7;
        }

        .ribbon-coords {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 10px;
            opacity: 0.8;
        }

        .ribbon-glyph {
            font-size: 11px;
            opacity: 0.9;
        }

        .move-icon {
            font-size: 11px;
        }

        /* Move History Panel */
        .move-history-panel {
            display: none;
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 1px solid var(--slate);
            border-radius: 12px;
            padding: 12px 16px;
            margin-top: 15px;
            overflow: hidden;
        }

        .move-history-panel.show {
            display: block;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .history-header.expanded {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--slate);
        }

        .history-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--pearl);
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .history-toggle {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .history-header.expanded .history-toggle {
            transform: rotate(90deg);
        }

        .history-controls {
            display: none;
            gap: 10px;
            align-items: center;
        }

        .history-header.expanded .history-controls {
            display: flex;
        }

        .history-nav {
            display: flex;
            gap: 5px;
        }

        .history-actions {
            display: flex;
            gap: 5px;
        }

        .history-btn {
            background: var(--slate);
            border: none;
            color: var(--pearl);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .history-btn:hover {
            background: var(--accent);
            color: var(--obsidian);
        }

        .history-body {
            display: none;
        }

        .history-body.expanded {
            display: block;
        }

        .history-list {
            overflow-y: auto;
            max-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .play-from-here-btn {
            width: 100%;
            margin-top: 10px;
            padding: 10px;
            background: linear-gradient(145deg, var(--slate), var(--onyx));
            border: 1px solid var(--silver);
            border-radius: 6px;
            color: var(--pearl);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s, background 0.2s;
        }

        .play-from-here-btn:hover {
            background: linear-gradient(145deg, var(--pearl), #d4c4a8);
            color: var(--obsidian);
            border-color: var(--pearl);
        }

        .history-move {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            cursor: pointer;
            transition: opacity 0.2s, background 0.2s;
            font-size: 0.85rem;
        }

        .history-move:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .history-move.active {
            background: var(--accent);
            color: var(--obsidian);
        }

        .history-move.dark-move {
            border-left: 3px solid #4a4a52;
        }

        .history-move.light-move {
            border-left: 3px solid #d4c4a8;
        }

        .move-number {
            font-weight: 600;
            min-width: 24px;
            color: var(--silver);
        }

        .history-move.active .move-number {
            color: var(--obsidian);
        }

        .move-notation {
            flex: 1;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.8rem;
        }

        .piece-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            font-size: 10px;
            font-weight: bold;
        }

        .piece-icon.dark-piece {
            background: #3a3a42;
            color: var(--pearl);
        }

        .piece-icon.light-piece {
            background: #d4c4a8;
            color: #2a2a30;
        }

        .glyph-indicator {
            font-size: 11px;
            opacity: 0.7;
        }

        .move-time {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 10px;
            color: var(--silver);
            opacity: 0.7;
            margin-left: auto;
            padding-left: 8px;
        }

        .history-move.active .move-time {
            color: var(--obsidian);
            opacity: 0.8;
        }

        .ribbon-time {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 9px;
            opacity: 0.6;
            margin-left: 4px;
        }

        /* Capture display */
        .capture-icons {
            font-size: 10px;
            margin-left: 2px;
            opacity: 0.9;
            color: #ef4444;
        }

        .capture-display {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 4px;
            color: #ef4444;
            font-size: 11px;
        }

        .captured-piece {
            width: 16px;
            height: 16px;
            font-size: 9px;
            opacity: 0.8;
        }

        .shadow-capture {
            opacity: 0.8;
        }

        .shadow-capture-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 9px;
            border: 1px dashed;
            opacity: 0.8;
        }

        .shadow-capture-icon.dark-shadow-icon {
            background: rgba(90, 77, 58, 0.5);
            border-color: #4a3d2e;
        }

        .shadow-capture-icon.light-shadow-icon {
            background: rgba(212, 196, 168, 0.5);
            border-color: #a09070;
        }

        /* Analysis mode board highlight */
        .board.analysis-mode {
            opacity: 0.95;
        }

        /* Responsive */
        @media (max-width: 1100px) {
            .game-area {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                max-width: 560px;
                margin: 0 auto;
                gap: 10px;
            }

            /* Tutorial console above light panel on mobile */
            .game-area.tutorial-active {
                grid-template-columns: 1fr;
            }

            #tutorialConsole {
                order: 0;
                max-width: 100%;
                margin-bottom: 10px;
            }

            .left-sidebar {
                display: contents;
            }

            #lightPanel {
                order: 1;
            }

            .board-container {
                order: 2;
            }

            #darkPanel {
                order: 3;
            }

            /* Flipped board: swap panel positions */
            .game-area.flipped #lightPanel {
                order: 3;
            }

            .game-area.flipped #darkPanel {
                order: 1;
            }

            .player-panel {
                max-width: 100%;
            }

            /* Restore flex layout for glyphs-row on mobile */
            .glyphs-row {
                display: flex;
                justify-content: center;
            }

            /* Add padding for resting area on left */
            .hand-center {
                padding-left: 60px;
                grid-column: unset;
            }

            /* Hide desktop resting area on mobile/tablet */
            .desktop-resting-area {
                display: none;
            }

            .shadow-area {
                position: absolute;
                right: 0;
                grid-column: unset;
            }
            
            /* Move history panel on mobile */
            .move-history-panel {
                order: 4;
                max-height: 200px;
            }
            
            /* Analysis ribbon on mobile */
            .analysis-ribbon {
                padding: 8px 10px;
                gap: 6px;
            }
            
            .ribbon-moves {
                gap: 3px;
            }
            
            .ribbon-move {
                padding: 3px 6px;
                font-size: 11px;
            }
        }

        @media (max-width: 600px) {
            .container {
                padding: 6px;
            }

            header {
                margin-bottom: 10px;
            }

            h1 {
                font-size: 1.8rem;
                letter-spacing: 0.1em;
            }

            .subtitle {
                font-size: 0.65rem;
                letter-spacing: 0.15em;
            }

            .game-area {
                gap: 8px;
            }

            .player-panel {
                padding: 8px 10px;
                border-radius: 8px;
            }

            .player-header {
                margin-bottom: 6px;
            }

            .player-name {
                font-size: 0.95rem;
            }

            .player-clock {
                font-size: 0.85rem;
                padding: 3px 8px;
            }

            .icon-btn {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            .btn-stack .icon-btn {
                width: 20px;
                height: 16px;
                font-size: 9px;
            }

            .header-right {
                gap: 8px;
            }

            .shadow-btn {
                width: 28px;
                height: 28px;
                font-size: 12px;
            }

            .resting-arrow {
                font-size: 12px;
            }

            .glyphs-row {
                min-height: 48px;
            }

            .glyph-hand {
                gap: 6px;
            }

            .glyph {
                width: 44px;
                height: 44px;
                border-radius: 8px;
            }

            .hand-center .glyph {
                width: 56px;
                height: 56px;
            }

            .glyph-shape {
                font-size: 20px;
            }

            .hand-center .glyph-shape {
                font-size: 26px;
            }

            .hand-center .mirror-shape {
                font-size: 26px;
            }

            .hand-center .mirror-color {
                width: 28px;
                height: 28px;
            }

            .glyph.mirror {
                font-size: 20px;
            }

            .hand-center .glyph.mirror {
                font-size: 26px;
            }

            .mask-piece {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }

            .player-name-row {
                gap: 6px;
            }

            .board {
                width: min(100%, calc(100vw - 12px));
                border-width: 3px;
            }

            .piece-shape {
                font-size: 16px;
            }

            .shadow-piece {
                width: 50%;
                height: 50%;
            }

            .btn {
                padding: 10px 16px;
                font-size: 0.8rem;
            }

            .modal-content {
                padding: 20px;
                border-radius: 12px;
            }

            .modal-content h2 {
                font-size: 1.5rem;
            }

            .modal-content h3 {
                font-size: 1rem;
            }

            .modal-content p,
            .modal-content ul {
                font-size: 0.9rem;
            }
        }

        @media (max-width: 400px) {
            .container {
                padding: 4px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .player-panel {
                padding: 6px 8px;
            }

            .player-name {
                font-size: 0.85rem;
            }

            .player-clock {
                font-size: 0.8rem;
                padding: 2px 6px;
            }

            .header-right {
                gap: 6px;
            }

            .shadow-btn {
                width: 38px;
                height: 38px;
                font-size: 14px;
            }

            .icon-btn {
                width: 26px;
                height: 26px;
                font-size: 12px;
            }

            .glyphs-row {
                min-height: 48px;
            }

            .glyph {
                width: 38px;
                height: 38px;
            }

            .hand-center .glyph {
                width: 50px;
                height: 50px;
            }

            .glyph-shape {
                font-size: 18px;
            }

            .hand-center .glyph-shape {
                font-size: 24px;
            }

            .hand-center .mirror-shape {
                font-size: 24px;
            }

            .hand-center .mirror-color {
                width: 24px;
                height: 24px;
            }

            .glyph.mirror {
                font-size: 18px;
            }

            .hand-center .glyph.mirror {
                font-size: 24px;
            }

            .resting-arrow {
                font-size: 10px;
            }

            .mask-piece {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            .player-name-row {
                gap: 4px;
            }

            .piece-shape {
                font-size: 14px;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--obsidian);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--slate);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <button class="menu-btn" id="menuBtn" onclick="toggleMenu()">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>INARA</h1>
                <div id="onlineIndicator" style="display: none; position: absolute; right: 50px; top: 50%; transform: translateY(-50%); 
                                                  font-size: 0.75rem; padding: 4px 10px; border-radius: 4px; background: var(--slate);">
                    <span id="onlineIndicatorDot" style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; 
                                                          background: #4ade80; margin-right: 6px;"></span>
                    <span id="onlineIndicatorText">Online</span>
                </div>
                <button class="flip-btn" onclick="toggleBoardFlip()" title="Flip board">â‡…</button>
                <div class="menu-dropdown" id="menuDropdown">
                    <button onclick="showNewGameModal(); closeMenu();">New Game</button>
                    <button onclick="document.getElementById('menuImportInput').click(); closeMenu();">Load Game</button>
                    <input type="file" id="menuImportInput" accept=".json" style="display:none" onchange="importGameJSON(event)">
                    <button onclick="toggleRules(); closeMenu();">Rules</button>
                    <button onclick="openTutorial(); closeMenu();">Tutorial</button>
                    <button onclick="showAbout(); closeMenu();">About</button>
                    <hr>
                    <button onclick="togglePause(); closeMenu();">Pause/Resume</button>
                    <button onclick="undoMove(); closeMenu();">Undo Move</button>
                </div>
            </div>
        </header>

        <!-- Analysis Ribbon -->
        <div class="analysis-ribbon" id="analysisRibbon">
            <div class="analysis-filename" id="analysisFilename"></div>
            <div class="ribbon-nav">
                <button class="ribbon-btn" onclick="goToMove(-1)" title="Start">â®</button>
                <button class="ribbon-btn" onclick="goToMove(analysisData.currentMoveIndex - 1)" title="Previous">â—€</button>
            </div>
            <div class="ribbon-moves" id="ribbonMoves"></div>
            <div class="ribbon-nav">
                <button class="ribbon-btn" onclick="goToMove(analysisData.currentMoveIndex + 1)" title="Next">â–¶</button>
                <button class="ribbon-btn" onclick="goToMove(analysisData.moves.length - 1)" title="End">â­</button>
            </div>
        </div>

        <div class="game-area">
            <!-- Tutorial Console (Interactive Mode) - Left of board on desktop, above light panel on mobile -->
            <div id="tutorialConsole">
                <h3 id="tutorialConsoleTitle">Steps</h3>
                <div class="tutorial-body" id="tutorialConsoleBody">
                    <!-- Content injected by JS -->
                </div>
                <div class="tutorial-controls">
                    <button class="tutorial-reset-btn" onclick="resetTutorialScenario()">Reset</button>
                    <button class="tutorial-nav-btn" onclick="tutorialPrev()">â—€ Back</button>
                    <span class="tutorial-progress" id="tutorialConsoleProgress">5 / 11</span>
                    <button class="tutorial-nav-btn" onclick="tutorialNext()">Next â–¶</button>
                    <button class="tutorial-continue-btn" id="tutorialConsoleContinue" onclick="tutorialNext()" disabled>Continue</button>
                </div>
            </div>

            <!-- Left Side: Player Panels and Resting Glyphs -->
            <div class="left-sidebar">
                <!-- Light Player Panel -->
                <div class="player-panel" id="lightPanel">
                    <div class="player-header">
                        <div class="player-name-row">
                            <span class="lives-display" id="lightLives"><span style="color: #e74c3c;">â™¥</span> 1</span>
                            <span class="player-name" id="lightPlayerName">Light</span>
                            <div class="masks-container" id="lightMasksDisplay"></div>
                        </div>
                        <div class="header-right">
                            <button class="icon-btn" onclick="undoMove()" title="Undo">âŸ²</button>
                            <span class="player-clock" id="lightClock">10:00</span>
                            <button class="icon-btn resign-btn" onclick="confirmResign('light')" title="Resign">âš</button>
                        </div>
                    </div>

                    <div class="glyphs-row">
                        <div class="resting-area">
                            <div class="glyph-hand" id="lightResting"></div>
                            <span class="resting-arrow"></span>
                        </div>
                        <div class="glyph-hand hand-center" id="lightHand"></div>
                        <div class="shadow-area">
                            <button class="shadow-btn light-shadow-btn" id="lightShadowBtn" onclick="toggleShadowPrimed('light')">
                                <span class="shadow-count" id="lightShadowCount">1</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Dark Player Panel -->
                <div class="player-panel active" id="darkPanel">
                    <div class="player-header">
                        <div class="player-name-row">
                            <span class="lives-display" id="darkLives"><span style="color: #e74c3c;">â™¥</span> 1</span>
                            <span class="player-name" id="darkPlayerName">Dark</span>
                            <div class="masks-container" id="darkMasksDisplay"></div>
                        </div>
                        <div class="header-right">
                            <button class="icon-btn" onclick="undoMove()" title="Undo">âŸ²</button>
                            <span class="player-clock" id="darkClock">10:00</span>
                            <button class="icon-btn resign-btn" onclick="confirmResign('dark')" title="Resign">âš</button>
                        </div>
                    </div>

                    <div class="glyphs-row">
                        <div class="resting-area">
                            <div class="glyph-hand" id="darkResting"></div>
                            <span class="resting-arrow"></span>
                        </div>
                        <div class="glyph-hand hand-center" id="darkHand"></div>
                        <div class="shadow-area">
                            <button class="shadow-btn dark-shadow-btn" id="darkShadowBtn" onclick="toggleShadowPrimed('dark')">
                                <span class="shadow-count" id="darkShadowCount">1</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Move History Panel (Analysis Mode) -->
                <div class="move-history-panel" id="moveHistoryPanel">
                    <div class="history-header" id="historyHeader" onclick="toggleHistoryPanel()">
                        <span class="history-title"><span class="history-toggle">â–¶</span> Move History</span>
                        <div class="history-controls">
                            <div class="history-actions">
                                <button class="history-btn" onclick="event.stopPropagation(); exportGameJSON()" title="Export JSON">ðŸ’¾</button>
                                <button class="history-btn" onclick="event.stopPropagation(); document.getElementById('importInput').click()" title="Import JSON">ðŸ“‚</button>
                                <input type="file" id="importInput" accept=".json" style="display:none" onchange="importGameJSON(event)">
                            </div>
                            <div class="history-nav">
                                <button class="history-btn" onclick="event.stopPropagation(); goToMove(analysisData.currentMoveIndex - 1)" title="Previous">â—€</button>
                                <button class="history-btn" onclick="event.stopPropagation(); goToMove(analysisData.currentMoveIndex + 1)" title="Next">â–¶</button>
                            </div>
                        </div>
                    </div>
                    <div class="history-body" id="historyBody">
                        <div class="history-list" id="historyList"></div>
                        <button class="play-from-here-btn" onclick="playFromHere()">â–¶ Play from here</button>
                    </div>
                </div>
            </div>

            <!-- Board -->
            <div class="board-container">
                <div class="board" id="board"></div>
            </div>
        </div>

        <footer class="copyright">
            Game Design Â© 2025 James Kuang
        </footer>
    </div>

    <!-- Rules Modal -->
    <div class="modal" id="rulesModal">
        <div class="modal-content rules-modal-content">
            <span class="close-modal" onclick="toggleRules()">&times;</span>
            
            <!-- Rules Language Selection (shown first) -->
            <div id="rulesLangSelect" class="tutorial-lang-select">
                <h2 style="font-family: 'Philosopher', sans-serif; margin-bottom: 20px;">Rules</h2>
                <p style="color: var(--silver); margin-bottom: 20px;">Select Language</p>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 200px; margin: 0 auto;">
                    <button class="btn" onclick="showRulesWithLang('en')" style="width: 100%;">English</button>
                    <button class="btn" onclick="showRulesWithLang('zh')" style="width: 100%; background: var(--slate); color: var(--pearl);">ä¸­æ–‡</button>
                    <button class="btn" onclick="showRulesWithLang('es')" style="width: 100%; background: var(--slate); color: var(--pearl);">EspaÃ±ol</button>
                </div>
            </div>
            
            <!-- Rules Content (hidden until language selected) -->
            <div id="rulesContent" style="display: none;">
                <h2>How to Play Inara</h2>

                <!-- Rules Tabs -->
                <div class="rules-tabs">
                    <button class="rules-tab active" data-tab="quick">Quick Reference</button>
                    <button class="rules-tab" data-tab="full">Full Rules</button>
                </div>

                <!-- Quick Reference Tab -->
                <div class="rules-tab-content active" id="rules-quick">
                    <h3>Objective</h3>
                    <p><strong>Sudden Death:</strong> Race your golems across the board and be the first to move one into a square on your opponent's home row to win!</p>
                    <p><strong>Extra Lives:</strong> Your opponent loses a life every time you make one of these runs. Bring their number of lives down to zero to win!</p>

                    <h3>On Your Turn</h3>
                    <ul>
                        <li>Select a glyph from your hand</li>
                        <li>Move a golem matching the glyph's shape or color</li>
                        <li>If using the Mirror glyph, match the resting glyph instead</li>
                        <li>The used glyph becomes your opponent's resting glyph</li>
                        <li>Pick up your resting glyph to your hand</li>
                    </ul>

                    <h3>Movement</h3>
                    <ul>
                        <li><strong>Step:</strong> Move 2 spaces orthogonally (N/S/E/W) if the middle square is empty, OR 1 space diagonally</li>
                        <li><strong>Jump:</strong> Jump diagonally over your own pieces to the next empty square</li>
                        <li>Chain multiple jumps in one turn!</li>
                    </ul>

                <h3>Capturing</h3>
                <ul>
                    <li>Surround an opponent's piece on opposite sides (horizontal or vertical)</li>
                    <li>Your moving piece must NOT match the target in shape or color</li>
                    <li>Captured golems return their mask and shadow to the owner's supply</li>
                </ul>

                <h3>Scoring (Extra Lives)</h3>
                <ul>
                    <li>Golems that complete a run can still make captures and leave shadows on that turn</li>
                    <li>Completing a run returns that golem to your supply as a mask and a shadow</li>
                </ul>

                <h3>Shadows</h3>
                <ul>
                    <li>After moving, you may leave a shadow on the vacated square (if available)</li>
                    <li>Dark cannot place shadows until Light has placed one first</li>
                    <li>Shadows can help capture and block movement</li>
                    <li>If ONE shadow is captured, ALL your shadows are removed!</li>
                </ul>

                <h3>Reactivation</h3>
                <ul>
                    <li>Instead of moving, place a mask from your supply onto one of your shadows</li>
                    <li>The mask must match BOTH the active glyph AND the resting glyph</li>
                    <li>If using Mirror, it copies the other glyph's requirement</li>
                </ul>

                <h3>Symbols</h3>
                <p><strong>Shapes:</strong> Î© Moon, Î§ Sand, Î› Peak</p>
                <p><strong>Colors:</strong> White, Orange, Blue</p>
                <p><strong>Mirror:</strong> â—‡ (copies the resting glyph)</p>
            </div>

            <!-- Full Rules Tab -->
            <div class="rules-tab-content" id="rules-full">
                <h3>Overview</h3>
                <p>Inara is a contest of skillful positioning and adaptation to ever shifting resources. There is no random chance once the game has started and no hidden information.</p>

                <h3>Materials</h3>
                <ul>
                    <li>A checkerboard (8Ã—8) with light and dark squares</li>
                    <li>7 Glyph tokens: 3 shapes (Moon, Sand, Peak), 3 colors (White, Orange, Blue), and 1 Mirror</li>
                    <li>Two sets of 9 golems (Light and Dark), each with a shadow stone and marked mask showing one of nine unique shape/color combinations</li>
                </ul>

                <h3>Preparing the Game</h3>
                <ol>
                    <li>Give each player a set of golems. The player with dark golems moves first.</li>
                    <li>Place 8 of your golems randomly on alternating squares in your first two rows. Light golems go on dark squares; dark golems go on light squares.</li>
                    <li>Leave your 9th golem asideâ€”dismantle it and put the mask and shadow into your supply.</li>
                    <li>Randomly distribute glyphs: Dark receives 3, Light receives 3. The remaining glyph becomes Dark's resting glyph.</li>
                </ol>

                <h3>Goal</h3>
                <p>Race your golems across the board and be the first to move one into your opponent's back row. Victory is yours if you succeed before they do!</p>

                <h3>Turn Summary</h3>
                <p>Players alternate turns. At the start of your turn, you have 3 glyphs in hand and 1 resting. You must take an actionâ€”you may not pass.</p>
                <ol>
                    <li><strong>Play a glyph</strong> from your hand as the active glyph, then either:
                        <ul>
                            <li>Move a golem matching the active glyph's shape or color (or if Mirror is active, match the resting glyph)</li>
                            <li>OR Reactivate a golem</li>
                        </ul>
                    </li>
                    <li><strong>Resolve captures</strong> resulting from movement or reactivation</li>
                    <li><strong>End your turn</strong> by picking up the resting glyph</li>
                    <li>Your used glyph becomes the new resting glyph for your opponent</li>
                </ol>

                <h3>How to Move</h3>
                <p>Each square can hold at most one golem or shadow.</p>
                <h4>Stepping</h4>
                <ul>
                    <li>Move orthogonally 2 spaces (N/S/E/W). This can be blocked by opponent pieces in the intermediate square.</li>
                    <li>OR move 1 space diagonally. This cannot be hindered by nearby pieces.</li>
                </ul>
                <h4>Jumping</h4>
                <ul>
                    <li>Jump diagonally over your own pieces (including shadows) to the next empty square</li>
                    <li>You may jump over one piece or multiple pieces arranged in a row</li>
                    <li>Chain several jumps together as a single move</li>
                    <li>You cannot jump back to your starting square in the same turn</li>
                </ul>

                <h3>Capturing Pieces</h3>
                <ul>
                    <li>After moving or reactivating, your golem captures any opponent pieces surrounded on two opposite sides (horizontal or vertical) by the moving golem and another of your pieces</li>
                    <li>The moving piece captures any opponent piece that does <strong>not</strong> match it in shape, color, or both. Pieces matching by shape or color are safe.</li>
                    <li>The stationary piece's shape/color does not matterâ€”only the moving piece's attributes count</li>
                    <li>Captured pieces are dismantled and returned to their owner's supply</li>
                    <li>Moving into a square between two opponent pieces does <strong>not</strong> result in your capture</li>
                </ul>

                <h3>Shadows</h3>
                <ul>
                    <li>When your golem moves, you may leave a shadow on the vacated square (if you have one in supply)</li>
                    <li><strong>Dark may not place shadows until Light has placed one first</strong></li>
                    <li>Shadows cannot move but can block opponent steps</li>
                    <li>Your golems can jump over your own shadows</li>
                    <li>Shadows can be stationary pieces for capturing</li>
                    <li>Shadows can be captured by any opponent piece (no matching required)</li>
                    <li><strong>Shadow Capture Rule:</strong> If one of your shadows is captured, ALL your remaining shadows are immediately removed and returned to your supply</li>
                </ul>

                <h3>Reactivation</h3>
                <ul>
                    <li>Instead of moving, place a mask from your supply onto one of your shadows on the board</li>
                    <li>The mask must match <strong>both</strong> the active glyph AND the resting glyph</li>
                    <li>If Mirror is your active or resting glyph, you may reactivate any piece matching the other glyph</li>
                    <li>After reactivating, resolve any captures</li>
                </ul>

                <h3>Ending the Game</h3>
                <p><strong>Sudden Death:</strong> The game ends immediately when one player moves a golem into their opponent's first row. That player wins!</p>
                <p><strong>Extra Lives:</strong> Your opponent loses a life every time you complete a run to their back row. The golem that scores can still make captures and leave a shadow on that turn. Completing a run also returns that golem to your supply as a mask and a shadow. Bring their number of lives down to zero to win!</p>
                <p>If a player cannot take any valid action (no glyphs allow movement or reactivation), the game ends in a <strong>draw</strong>.</p>

                <h3>Symbol Reference</h3>
                <p><strong>Shapes:</strong> Î© Moon, Î§ Sand, Î› Peak</p>
                <p><strong>Colors:</strong> White, Orange, Blue</p>
                <p><strong>Mirror:</strong> â—‡ (copies the resting glyph)</p>
            </div>
            </div>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="modal" id="tutorialModal">
        <div class="modal-content tutorial-content">
            <span class="close-modal" onclick="closeTutorial()">&times;</span>
            
            <!-- Tutorial Language Selection (shown first) -->
            <div id="tutorialLangSelect" class="tutorial-lang-select">
                <h2 style="font-family: 'Philosopher', sans-serif; margin-bottom: 20px;">Tutorial</h2>
                <p style="color: var(--silver); margin-bottom: 20px;">Select Language</p>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 200px; margin: 0 auto;">
                    <button class="btn" onclick="startTutorialWithLang('en')" style="width: 100%;">English</button>
                    <button class="btn" onclick="startTutorialWithLang('zh')" style="width: 100%; background: var(--slate); color: var(--pearl);">ä¸­æ–‡</button>
                    <button class="btn" onclick="startTutorialWithLang('es')" style="width: 100%; background: var(--slate); color: var(--pearl);">EspaÃ±ol</button>
                </div>
            </div>
            
            <!-- Tutorial Navigation (hidden until language selected) -->
            <div class="tutorial-nav" id="tutorialNav" style="display: none;">
                <button class="tutorial-nav-btn" id="tutorialPrev" onclick="tutorialPrev()">â—€ Back</button>
                <span class="tutorial-progress" id="tutorialProgress">1 / 11</span>
                <button class="tutorial-nav-btn" id="tutorialNext" onclick="tutorialNext()">Next â–¶</button>
            </div>

            <!-- Tutorial Capsules (hidden until language selected) -->
            <div class="tutorial-capsules" id="tutorialCapsules" style="display: none;">
                
                <!-- Capsule 1: Objective -->
                <div class="tutorial-capsule" data-capsule="1">
                    <h2>Objective</h2>
                    <div class="tutorial-body">
                        <p>Inara is a turn-based two-player game of abstract strategy.</p>
                        <p><strong>Your goal:</strong> Complete runs on your opponent's side with your <em>golems</em> to win.</p>
                    </div>
                </div>

                <!-- Capsule 2: Components -->
                <div class="tutorial-capsule" data-capsule="2">
                    <h2>Components</h2>
                    <div class="tutorial-body">
                        <p>The game is played on an 8Ã—8 checkered board with two players sitting across from each other.</p>
                        <p>There are <strong>7 glyphs</strong> (3 colors, 3 shapes, and a mirror), as well as <strong>9 golems</strong> for each player.</p>
                        <p>Each golem has 2 traits (a color and a shape) that match the glyphs:</p>
                        <ul>
                            <li><strong>Colors:</strong> Blue, Orange, White</li>
                            <li><strong>Shapes:</strong> Î› Peak, Î§ Sand, Î© Moon</li>
                        </ul>
                    </div>
                </div>

                <!-- Capsule 3: Preparation -->
                <div class="tutorial-capsule" data-capsule="3">
                    <h2>Preparation</h2>
                    <div class="tutorial-body">
                        <p>Decide who will go first. You may play timed or untimed.</p>
                        <p>As <strong>Dark</strong>, you control the dark pieces as the starting player. Your <strong>Light</strong> opponent takes the light pieces.</p>
                        <p>Dark pieces move on light squares; light pieces move on dark squares.</p>
                        <p>Take the glyphs and give each player 3 randomly as their starting hands. The leftover glyph becomes the first player's <em>resting</em> glyph.</p>
                        <p>Each player has 9 golems. Randomly place 8 of them â€” one on each starting square in your first two rows. Your remaining golem is dismantled and kept in your supply as a mask.</p>
                    </div>
                </div>

                <!-- Capsule 4: Glyphs (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="4" data-interactive="true">
                    <h2>Glyphs</h2>
                    <div class="tutorial-body">
                        <p>Every turn, prime a glyph to perform one action.</p>
                        <p><strong>Actions:</strong> Step, Jump, or Reactivate</p>
                        <p>The golem performing that action must match the glyph by shape or color. The <strong>mirror glyph â—‡</strong> lets you copy the resting glyph on your turn.</p>
                        <p>Once you have performed that action, the glyph you primed goes to your opponent as their resting glyph. You pick up your resting glyph into your hand.</p>
                        <p><strong>Warning:</strong> If a golem doesn't match any glyph in your hand, it cannot perform any actions that turn!</p>
                        <div class="tutorial-prompt">
                            <p>Select different glyphs and golems to see how they match:</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="select-golem-1">â˜ Select a golem with a matching glyph</li>
                                <li data-objective="select-golem-2">â˜ Select a different golem with a matching glyph</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 5: Steps (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="5" data-interactive="true">
                    <h2>Steps</h2>
                    <div class="tutorial-body">
                        <p><strong>Orthogonal Step:</strong> Move exactly 2 squares in a straight line (N/S/E/W). The middle square must be empty.</p>
                        <p><strong>Diagonal Step:</strong> Move exactly 1 square diagonally.</p>
                        <div class="tutorial-prompt">
                            <p>Try both types of steps:</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="ortho-step">â˜ Make an orthogonal step (2 squares)</li>
                                <li data-objective="diag-step">â˜ Make a diagonal step (1 square)</li>
                            </ul>
                            <button class="tutorial-reset-btn" onclick="resetTutorialScenario()">Reset</button>
                            <button class="tutorial-continue-btn" id="tutorialContinueBtn" onclick="tutorialNext()" disabled>Continue</button>
                        </div>
                    </div>
                </div>

                <!-- Capsule 6: Single Jump (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="6" data-interactive="true">
                    <h2>Jumps: Single Hop</h2>
                    <div class="tutorial-body">
                        <p>Jump <strong>diagonally</strong> over a friendly piece to land on the empty square just beyond it.</p>
                        <p>You cannot jump over enemies or empty squares.</p>
                        <div class="tutorial-prompt">
                            <p>Jump forward over one piece.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="single-jump">â˜ Make a single-piece jump forward</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 7: Multi-Piece Jump (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="7" data-interactive="true">
                    <h2>Jumps: Multiple Pieces</h2>
                    <div class="tutorial-body">
                        <p>You can jump over <strong>multiple contiguous pieces</strong> in a single hop. Land on the first empty square beyond them all.</p>
                        <div class="tutorial-prompt">
                            <p>Jump over two or more pieces at once.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="multi-piece-jump">â˜ Jump over multiple pieces in one hop</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 8: Chain Jumps (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="8" data-interactive="true">
                    <h2>Jumps: Chain Jumps</h2>
                    <div class="tutorial-body">
                        <p>After landing, you may <strong>continue jumping</strong> in any diagonal direction if another friendly piece is adjacent. All jumps happen in one turn!</p>
                        <div class="tutorial-prompt">
                            <p>Use your shadows as stepping stones. Make a chain jump with 2 or more hops!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="chain-jump">â˜ Make a chain jump (2+ hops in one move)</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 9: Completing a Run (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="9" data-interactive="true">
                    <h2>Completing a Run</h2>
                    <div class="tutorial-body">
                        <p><strong>Dark</strong> completes a run by reaching row 1 (Light's back row).</p>
                        <p><strong>Light</strong> completes a run by reaching row 8 (Dark's back row).</p>
                        <p>In <strong>Sudden Death</strong>, the first player to complete a run wins immediately!</p>
                        <p>With <strong>multiple lives</strong>, the golem that completes the run first makes any captures at the destination square, then returns to your supply as a shadow and a mask.</p>
                        <div class="tutorial-prompt">
                            <p>Reach the top row to complete a run!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reach-goal">â˜ Move a golem to row 1</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 10: Capturing (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="10" data-interactive="true">
                    <h2>Capturing</h2>
                    <div class="tutorial-body">
                        <p>Capture your opponent's pieces by surrounding them on two opposite sides between two of your pieces.</p>
                        <p>You must create this "sandwich" on your turn with the golem you moved or reactivated.</p>
                        <p>The golem you activated will only capture another golem if it does <strong>NOT</strong> match the target golem by shape or color.</p>
                        <div class="tutorial-prompt">
                            <p>Sandwich the light piece to capture it.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="capture">â˜ Capture an enemy piece</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 11: Double Capture (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="11" data-interactive="true">
                    <h2>Capturing: Multiple & Immunity</h2>
                    <div class="tutorial-body">
                        <p>You can capture <strong>multiple pieces</strong> in one move if you sandwich them in different directions.</p>
                        <p>But remember: pieces that <strong>share a trait</strong> (shape or color) with your moving piece are <strong>immune</strong> to capture!</p>
                        <div class="tutorial-prompt">
                            <p>Capture two pieces at once. Notice the third piece is immune!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="double-capture">â˜ Capture two pieces in one move</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 12: Safe Movement (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="12" data-interactive="true">
                    <h2>Capturing: Safe Movement</h2>
                    <div class="tutorial-body">
                        <p>You can safely move <strong>between</strong> enemy pieces if your piece shares a trait with at least one of them.</p>
                        <p>This immunity works both ways â€” you can't capture them, but they can't capture you either!</p>
                        <div class="tutorial-prompt">
                            <p>Move between the enemy pieces without being captured.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="safe-move">â˜ Move safely between enemy pieces</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 13: Shadows (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="13" data-interactive="true">
                    <h2>Shadows</h2>
                    <div class="tutorial-body">
                        <p>After moving, you may leave a <strong>shadow</strong> on your vacated square by clicking the shadow button before moving.</p>
                        <p>Shadows act as stepping stones for diagonal jumps and block enemy movement paths.</p>
                        <p><strong>Note:</strong> Dark cannot place shadows until Light has placed one first.</p>
                        <p><strong>Warning:</strong> If ANY of your shadows is captured, ALL your shadows are removed!</p>
                        <div class="tutorial-prompt">
                            <p>The shadow toggle is already on. Move to leave a shadow behind!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="shadow-place">â˜ Place a shadow</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 14: Reactivation (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="14" data-interactive="true">
                    <h2>Reactivation</h2>
                    <div class="tutorial-body">
                        <p>Instead of moving, you can <strong>reactivate</strong> a captured piece:</p>
                        <ul>
                            <li>You must have a mask in your supply and a shadow on the board</li>
                            <li>The mask must match <strong>BOTH</strong> your active glyph <strong>AND</strong> your resting glyph</li>
                            <li>If the mirror â—‡ is your active or resting glyph, it copies the other glyph's requirement</li>
                            <li>Click the mask, then click a shadow to place the golem</li>
                        </ul>
                        <div class="tutorial-prompt">
                            <p>Select the right glyph and reactivate the mask onto the shadow.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate">â˜ Reactivate a mask</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 15: Reactivation Capture (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="15" data-interactive="true">
                    <h2>Reactivation: Capture</h2>
                    <div class="tutorial-body">
                        <p>When you reactivate a golem, it can <strong>capture</strong> enemy pieces just like a regular move!</p>
                        <p>The reactivated golem captures any adjacent enemy pieces it sandwiches (that don't share a trait).</p>
                        <div class="tutorial-prompt">
                            <p>Reactivate your mask to capture the enemy piece.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate-capture">â˜ Capture through reactivation</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 16: Ready to Play -->
                <div class="tutorial-capsule" data-capsule="16">
                    <h2>Ready to Play!</h2>
                    <div class="tutorial-body">
                        <p>You now know the essentials of Inara:</p>
                        <ul>
                            <li>Race to your opponent's back row to win</li>
                            <li>Use glyphs to select which pieces can move</li>
                            <li>Step, jump, and chain your way forward</li>
                            <li>Capture to defend, reactivate to recover</li>
                        </ul>
                        <p style="margin-top: 12px;"><strong>Draw:</strong> If none of your glyphs allow you to move or reactivate, the game ends in a draw.</p>
                        <button class="btn" onclick="closeTutorial(); showNewGameModal();" style="margin-top: 15px; width: 100%;">Start Playing</button>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div class="modal" id="victoryModal">
        <div class="modal-content victory-content">
            <h2 id="victoryTitle">Victory!</h2>
            <p id="victoryMessage">Dark Wins!</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn" onclick="startNewGame()">Play Again</button>
                <button class="btn" onclick="closeVictoryModal()" style="background: var(--slate); color: var(--pearl);">Analyze Game</button>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div class="modal" id="aboutModal">
        <div class="modal-content" style="max-width: 360px; text-align: center;">
            <span class="close-modal" onclick="closeAbout()">&times;</span>
            
            <!-- About Language Selection (shown first) -->
            <div id="aboutLangSelect" class="tutorial-lang-select">
                <h2 style="font-size: 2rem; margin-bottom: 20px; font-family: 'Philosopher', sans-serif;">About</h2>
                <p style="color: var(--silver); margin-bottom: 20px;">Select Language</p>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 200px; margin: 0 auto;">
                    <button class="btn" onclick="showAboutWithLang('en')" style="width: 100%;">English</button>
                    <button class="btn" onclick="showAboutWithLang('zh')" style="width: 100%; background: var(--slate); color: var(--pearl);">ä¸­æ–‡</button>
                    <button class="btn" onclick="showAboutWithLang('es')" style="width: 100%; background: var(--slate); color: var(--pearl);">EspaÃ±ol</button>
                </div>
            </div>
            
            <!-- About Content (hidden until language selected) -->
            <div id="aboutContent" style="display: none;">
                <h2 style="font-size: 2rem; margin-bottom: 25px; font-family: 'Philosopher', sans-serif;">About</h2>
                <p id="aboutText" style="color: var(--pearl); line-height: 1.7; margin-bottom: 20px;">I've been working on this game with support from friends and family since 2017. Most of it came together within a year, some of it took longer to draw out. I hope others find as much joy and connection in playing it as I have found in making it.</p>
                <p style="color: var(--silver); font-style: italic; margin-bottom: 20px;">James Kuang<br>2025</p>
                <p id="aboutContact" style="color: var(--silver); font-size: 0.9rem;">If you have thoughts about the game, feel free to drop me a line!<br><a href="mailto:jfkuang@proton.me" style="color: var(--gold);">jfkuang@proton.me</a></p>
            </div>
        </div>
    </div>

    <!-- Resign Confirmation Modal -->
    <div class="modal" id="resignModal">
        <div class="modal-content" style="max-width: 340px; text-align: center;">
            <h2 style="font-size: 1.5rem; margin-bottom: 15px;">End Game?</h2>
            <p id="resignMessage" style="margin-bottom: 20px;">What would you like to do?</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn" onclick="executeResign()" style="background: #ef4444;">Resign</button>
                    <button class="btn" onclick="showDrawOffer()" style="background: #f59e0b;">Offer Draw</button>
                </div>
                <button class="btn" onclick="cancelResign()" style="background: var(--slate); color: var(--pearl);">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Draw Offer Modal -->
    <div class="modal" id="drawOfferModal">
        <div class="modal-content" style="max-width: 340px; text-align: center;">
            <h2 style="font-size: 1.5rem; margin-bottom: 15px;">Draw Offered</h2>
            <p id="drawOfferMessage" style="margin-bottom: 20px;">Dark offers a draw. Light, do you accept?</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn" onclick="acceptDraw()" style="background: #22c55e;">Accept</button>
                <button class="btn" onclick="declineDraw()" style="background: var(--slate); color: var(--pearl);">Decline</button>
            </div>
        </div>
    </div>

    <!-- Welcome Screen Modal -->
    <div class="modal show" id="welcomeModal">
        <div class="modal-content" style="max-width: 360px; text-align: center;">
            <h2 style="font-size: 2.5rem; margin-bottom: 25px; font-family: 'Philosopher', sans-serif;">INARA</h2>
            
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button class="btn" onclick="closeWelcome(); showNewGameModal();" style="padding: 14px; font-size: 1.1rem;">New Game</button>
                <button class="btn" onclick="closeWelcome(); openTutorial();" style="padding: 14px; font-size: 1.1rem; background: var(--slate); color: var(--pearl);">Tutorial</button>
                <button class="btn" onclick="closeWelcome(); toggleRules();" style="padding: 14px; font-size: 1.1rem; background: var(--slate); color: var(--pearl);">Rules</button>
                <button class="btn" onclick="closeWelcome(); document.getElementById('welcomeImportInput').click();" style="padding: 14px; font-size: 1.1rem; background: var(--slate); color: var(--pearl);">Load Game</button>
                <input type="file" id="welcomeImportInput" accept=".json" style="display:none" onchange="importGameJSON(event)">
                <button class="btn" onclick="closeWelcome(); showAbout();" style="padding: 14px; font-size: 1.1rem; background: var(--slate); color: var(--pearl);">About</button>
            </div>
        </div>
    </div>

    <!-- New Game Setup Modal -->
    <div class="modal" id="newGameModal">
        <div class="modal-content" style="max-width: 360px; text-align: center;">
            <h2 style="font-size: 1.5rem; margin-bottom: 20px;">New Game</h2>
            
            <!-- CPU Opponent Toggle -->
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">Opponent</label>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn" id="humanBtn" onclick="setGameMode('human')" style="flex: 1; background: var(--gold);">Local</button>
                    <button class="btn" id="onlineBtn" onclick="setGameMode('online')" style="flex: 1; background: var(--slate); color: var(--pearl);">Online</button>
                    <button class="btn" id="cpuBtn" onclick="setGameMode('cpu')" style="flex: 1; background: var(--slate); color: var(--pearl);">CPU</button>
                </div>
            </div>
            
            <!-- CPU Side Selection (hidden when vs Human or Spectate) -->
            <div id="cpuSideSelect" style="margin-bottom: 20px; display: none;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">You Play As</label>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn" id="playDarkBtn" onclick="setPlayerSide('dark')" style="flex: 1; background: var(--gold);">Dark<br><small style="opacity: 0.7; font-size: 0.75em;">(1st Move)</small></button>
                    <button class="btn" id="playLightBtn" onclick="setPlayerSide('light')" style="flex: 1; background: var(--slate); color: var(--pearl);">Light<br><small style="opacity: 0.7; font-size: 0.75em; white-space: nowrap;">(1st Shadow)</small></button>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">Lives</label>
                <div style="display: flex; gap: 8px; justify-content: center; margin-bottom: 10px;">
                    <button class="btn lives-btn" id="lives1Btn" onclick="setLives(1)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 10px;">
                        <span style="color: #e74c3c;">â™¥â™¥</span>
                    </button>
                    <button class="btn lives-btn" id="lives2Btn" onclick="setLives(2)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 10px;">
                        <span style="color: #e74c3c;">â™¥â™¥â™¥</span>
                    </button>
                    <button class="btn lives-btn" id="lives3Btn" onclick="setLives(3)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 10px;">
                        <span style="color: #e74c3c;">â™¥â™¥â™¥â™¥</span>
                    </button>
                </div>
                <button class="btn lives-btn" id="lives0Btn" onclick="setLives(0)" style="width: 100%; background: var(--gold);">Sudden Death</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">Time per Player</label>
                <div class="time-display" id="timeDisplay">10:00</div>
                <input type="range" class="time-slider" id="timeSlider" min="0" max="30" value="10" oninput="updateTimeDisplay()">
                <div class="time-labels">
                    <span>No limit</span>
                    <span>30 min</span>
                </div>
            </div>
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">Increment per Move</label>
                <div class="time-display increment-display" id="incrementDisplay">+0s</div>
                <input type="range" class="time-slider" id="incrementSlider" min="0" max="30" value="0" oninput="updateIncrementDisplay()">
                <div class="time-labels">
                    <span>None</span>
                    <span>+30s</span>
                </div>
            </div>
            <button class="btn" onclick="startGameWithTime()" style="width: 100%;">Start Game</button>
        </div>
    </div>

    <!-- Online Game Modal -->
    <div class="modal" id="onlineModal">
        <div class="modal-content" style="max-width: 380px; text-align: center;">
            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 20px; position: relative;">
                <button onclick="closeOnlineModal()" style="position: absolute; left: 0; background: none; border: none; color: var(--silver); font-size: 1.2rem; cursor: pointer; padding: 5px;">â†</button>
                <h2 style="font-size: 1.5rem;">Play Online</h2>
            </div>
            
            <!-- Connection Status -->
            <div id="onlineStatus" style="margin-bottom: 20px; padding: 10px; border-radius: 8px; background: var(--slate);">
                <span style="color: var(--silver);">Connecting to server...</span>
            </div>
            
            <!-- Create/Join Options -->
            <div id="onlineOptions" style="display: none;">
                <!-- Player Names Input -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; color: var(--silver);">Player Names</label>
                    <input type="text" id="playerNameInput" placeholder="(You)" maxlength="5"
                        style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--slate); 
                               background: var(--onyx); color: var(--pearl); font-size: 1rem; text-align: center;
                               text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 10px;">
                    <input type="text" id="opponentNameInput" placeholder="(Them)" maxlength="5"
                        style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--slate); 
                               background: var(--onyx); color: var(--pearl); font-size: 1rem; text-align: center;
                               text-transform: uppercase; letter-spacing: 0.1em;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                        <button class="btn" id="hostDarkBtn" onclick="setHostSide('dark')" style="flex: 1; background: var(--slate); color: var(--pearl); font-size: 0.85rem; padding: 10px;">
                            Dark<br><small style="opacity: 0.7;">1st move</small>
                        </button>
                        <button class="btn" id="hostRandomBtn" onclick="setHostSide('random')" style="flex: 1; background: var(--gold); font-size: 0.85rem; padding: 10px;">
                            Random
                        </button>
                        <button class="btn" id="hostLightBtn" onclick="setHostSide('light')" style="flex: 1; background: var(--slate); color: var(--pearl); font-size: 0.85rem; padding: 10px;">
                            Light<br><small style="opacity: 0.7;">1st shadow</small>
                        </button>
                    </div>
                    
                    <!-- Lives selector for online -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--silver); font-size: 0.9rem;">Lives</label>
                        <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                            <button class="btn online-lives-btn" id="onlineLives1Btn" onclick="setOnlineLives(1)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 8px; font-size: 0.85rem;">
                                <span style="color: #e74c3c;">â™¥â™¥</span>
                            </button>
                            <button class="btn online-lives-btn" id="onlineLives2Btn" onclick="setOnlineLives(2)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 8px; font-size: 0.85rem;">
                                <span style="color: #e74c3c;">â™¥â™¥â™¥</span>
                            </button>
                            <button class="btn online-lives-btn" id="onlineLives3Btn" onclick="setOnlineLives(3)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 8px; font-size: 0.85rem;">
                                <span style="color: #e74c3c;">â™¥â™¥â™¥â™¥</span>
                            </button>
                        </div>
                        <button class="btn online-lives-btn" id="onlineLives0Btn" onclick="setOnlineLives(0)" style="width: 100%; background: var(--gold); font-size: 0.85rem;">Sudden Death</button>
                    </div>
                    
                    <!-- Time indicator (greyed out for online) -->
                    <div style="margin-bottom: 15px; opacity: 0.5;">
                        <label style="display: block; margin-bottom: 8px; color: var(--silver); font-size: 0.9rem;">Time</label>
                        <div style="padding: 10px; background: var(--slate); border-radius: 8px; color: var(--silver); font-size: 0.9rem;">
                            No Limit
                        </div>
                    </div>
                    
                    <button class="btn" onclick="createOnlineGame()" style="width: 100%;">
                        Create Game
                    </button>
                </div>
                
                <div style="border-top: 1px solid var(--slate); padding-top: 20px;">
                    <label style="display: block; margin-bottom: 10px; color: var(--silver);">Join a Game</label>
                    <input type="text" id="joinCodeInput" placeholder="e.g. blue-tiger-42" 
                        style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--slate); 
                               background: var(--onyx); color: var(--pearl); font-size: 1rem; text-align: center;
                               margin-bottom: 10px;">
                    <button class="btn" onclick="joinOnlineGame()" style="width: 100%; background: var(--slate); color: var(--pearl);">
                        Join Game
                    </button>
                </div>
            </div>
            
            <!-- Waiting for opponent -->
            <div id="onlineWaiting" style="display: none;">
                <p style="color: var(--silver); margin-bottom: 15px;">Share this link with your opponent:</p>
                <div id="roomLink" style="font-size: 0.9rem; color: var(--gold); 
                                          margin-bottom: 10px; padding: 15px; background: var(--slate); border-radius: 8px;
                                          cursor: pointer; word-break: break-all;" onclick="copyRoomLink()">
                    ---
                </div>
                <p style="color: var(--silver); font-size: 0.85rem; margin-bottom: 5px;">Click to copy</p>
                <p style="color: var(--silver); font-size: 0.75rem; margin-bottom: 20px;">Room code: <span id="roomCode">----</span></p>
                <p style="color: var(--silver);">Waiting for opponent to join...</p>
                <div class="waiting-spinner" style="margin: 20px auto; width: 30px; height: 30px; border: 3px solid var(--slate); 
                                                     border-top-color: var(--gold); border-radius: 50%; animation: spin 1s linear infinite;"></div>
            </div>
            
            <!-- Joining -->
            <div id="onlineJoining" style="display: none;">
                <p style="color: var(--silver);">Connecting to game...</p>
                <div class="waiting-spinner" style="margin: 20px auto; width: 30px; height: 30px; border: 3px solid var(--slate); 
                                                     border-top-color: var(--gold); border-radius: 50%; animation: spin 1s linear infinite;"></div>
            </div>
            
            <!-- Error state -->
            <div id="onlineError" style="display: none;">
                <p id="onlineErrorMsg" style="color: #e74c3c; margin-bottom: 15px;">Connection failed</p>
                <button class="btn" onclick="retryOnlineConnection()" style="background: var(--slate); color: var(--pearl);">Try Again</button>
            </div>
            
            <button class="btn" onclick="closeOnlineModal()" style="width: 100%; margin-top: 20px; background: var(--slate); color: var(--pearl);">Cancel</button>
        </div>
    </div>

    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #joinCodeInput::placeholder {
            color: var(--silver);
            opacity: 0.5;
        }
    </style>

    <script>
        // === CONSTANTS ===
        const SHAPES = ['Î©', 'Î§', 'Î›']; // Moon, Sand, Peak
        const SHAPE_NAMES = { 'Î©': 'Moon', 'Î§': 'Sand', 'Î›': 'Peak' };
        const COLORS = ['white', 'orange', 'blue'];
        const MIRROR = 'â—‡';
        
        // === LANGUAGE / TRANSLATION SYSTEM ===
        let currentLanguage = 'en';
        let originalRulesQuick = null;
        let originalRulesFull = null;
        let originalTutorialCapsules = null;
        
        const translations = {
            zh: {
                quick: `
                <h3>ç›®æ ‡</h3>
                <p><strong>çªç„¶æ­»äº¡ï¼š</strong>å°†ä½ çš„é­”åƒæŽ¨è¿›åˆ°å¯¹æ–¹çš„åº•çº¿ï¼Œå…ˆåˆ°è€…èŽ·èƒœï¼</p>
                <p><strong>é¢å¤–ç”Ÿå‘½ï¼š</strong>æ¯æ¬¡æˆåŠŸçªç ´éƒ½ä¼šè®©å¯¹æ‰‹å¤±åŽ»ä¸€æ¡ç”Ÿå‘½ã€‚å°†å¯¹æ‰‹çš„ç”Ÿå‘½å€¼é™ä¸ºé›¶å³å¯èŽ·èƒœï¼</p>

                <h3>å›žåˆè¡ŒåŠ¨</h3>
                <ul>
                    <li>ä»Žæ‰‹ç‰Œä¸­é€‰æ‹©ä¸€ä¸ªç¬¦æ–‡</li>
                    <li>ç§»åŠ¨ä¸€ä¸ªä¸Žç¬¦æ–‡å½¢çŠ¶æˆ–é¢œè‰²åŒ¹é…çš„é­”åƒ</li>
                    <li>ä½¿ç”¨é•œåƒç¬¦æ–‡æ—¶ï¼Œæ”¹ä¸ºåŒ¹é…ä¼‘æ¯ç¬¦æ–‡</li>
                    <li>ä½¿ç”¨è¿‡çš„ç¬¦æ–‡æˆä¸ºå¯¹æ‰‹çš„ä¼‘æ¯ç¬¦æ–‡</li>
                    <li>å°†ä½ çš„ä¼‘æ¯ç¬¦æ–‡æ”¶å›žæ‰‹ä¸­</li>
                </ul>

                <h3>ç§»åŠ¨æ–¹å¼</h3>
                <ul>
                    <li><strong>æ­¥è¡Œï¼š</strong>å¦‚æžœä¸­é—´æ ¼ä¸ºç©ºï¼Œå¯æ²¿æ­£äº¤æ–¹å‘ç§»åŠ¨2æ ¼ï¼Œæˆ–æ²¿å¯¹è§’çº¿ç§»åŠ¨1æ ¼</li>
                    <li><strong>è·³è·ƒï¼š</strong>æ²¿å¯¹è§’çº¿è·³è¿‡å·±æ–¹æ£‹å­åˆ°è¾¾ä¸‹ä¸€ä¸ªç©ºæ ¼</li>
                    <li>å¯ä»¥åœ¨ä¸€å›žåˆå†…è¿žç»­è·³è·ƒï¼</li>
                </ul>

                <h3>æ•èŽ·</h3>
                <ul>
                    <li>ä»Žä¸¤ä¾§ï¼ˆæ°´å¹³æˆ–åž‚ç›´ï¼‰åŒ…å›´å¯¹æ–¹æ£‹å­</li>
                    <li>ä½ ç§»åŠ¨çš„æ£‹å­ä¸èƒ½ä¸Žç›®æ ‡æ£‹å­çš„å½¢çŠ¶æˆ–é¢œè‰²åŒ¹é…</li>
                    <li>è¢«æ•èŽ·çš„é­”åƒå°†å…¶é¢å…·å’Œå½±å­è¿”è¿˜ç»™æ‰€æœ‰è€…çš„è¡¥ç»™</li>
                </ul>

                <h3>å¾—åˆ†ï¼ˆé¢å¤–ç”Ÿå‘½æ¨¡å¼ï¼‰</h3>
                <ul>
                    <li>å®Œæˆçªç ´çš„é­”åƒä»å¯åœ¨è¯¥å›žåˆè¿›è¡Œæ•èŽ·å’Œæ”¾ç½®å½±å­</li>
                    <li>å®Œæˆçªç ´åŽï¼Œè¯¥é­”åƒä½œä¸ºé¢å…·å’Œå½±å­è¿”å›žä½ çš„è¡¥ç»™</li>
                </ul>

                <h3>å½±å­</h3>
                <ul>
                    <li>ç§»åŠ¨åŽï¼Œä½ å¯ä»¥åœ¨ç¦»å¼€çš„æ ¼å­ä¸Šæ”¾ç½®ä¸€ä¸ªå½±å­ï¼ˆå¦‚æžœæœ‰çš„è¯ï¼‰</li>
                    <li>åœ¨å…‰æ–¹æ”¾ç½®å½±å­ä¹‹å‰ï¼Œæš—æ–¹ä¸èƒ½æ”¾ç½®å½±å­</li>
                    <li>å½±å­å¯ä»¥å¸®åŠ©æ•èŽ·å’Œé˜»æŒ¡ç§»åŠ¨</li>
                    <li>å¦‚æžœä¸€ä¸ªå½±å­è¢«æ•èŽ·ï¼Œä½ æ‰€æœ‰çš„å½±å­éƒ½ä¼šè¢«ç§»é™¤ï¼</li>
                </ul>

                <h3>é‡æ–°æ¿€æ´»</h3>
                <ul>
                    <li>ä½œä¸ºç§»åŠ¨çš„æ›¿ä»£ï¼Œå°†è¡¥ç»™ä¸­çš„é¢å…·æ”¾ç½®åœ¨ä½ çš„ä¸€ä¸ªå½±å­ä¸Š</li>
                    <li>é¢å…·å¿…é¡»åŒæ—¶åŒ¹é…æ¿€æ´»ç¬¦æ–‡å’Œä¼‘æ¯ç¬¦æ–‡</li>
                    <li>ä½¿ç”¨é•œåƒæ—¶ï¼Œå®ƒä¼šå¤åˆ¶å¦ä¸€ä¸ªç¬¦æ–‡çš„è¦æ±‚</li>
                </ul>

                <h3>ç¬¦å·å‚è€ƒ</h3>
                <p><strong>å½¢çŠ¶ï¼š</strong>Î© æœˆäº®, Î§ æ²™, Î› å±±å³°</p>
                <p><strong>é¢œè‰²ï¼š</strong>ç™½è‰², æ©™è‰², è“è‰²</p>
                <p><strong>é•œåƒï¼š</strong>â—‡ï¼ˆå¤åˆ¶ä¼‘æ¯ç¬¦æ–‡ï¼‰</p>
                `,
                full: `
                <h3>æ¦‚è¿°</h3>
                <p>Inaraæ˜¯ä¸€åœºæŠ€å·§å®šä½å’Œé€‚åº”ä¸æ–­å˜åŒ–èµ„æºçš„è¾ƒé‡ã€‚æ¸¸æˆå¼€å§‹åŽæ²¡æœ‰éšæœºå› ç´ ï¼Œä¹Ÿæ²¡æœ‰éšè—ä¿¡æ¯ã€‚</p>

                <h3>æ¸¸æˆææ–™</h3>
                <ul>
                    <li>ä¸€ä¸ª8Ã—8çš„æ£‹ç›˜ï¼Œæœ‰æ˜Žæš—ç›¸é—´çš„æ ¼å­</li>
                    <li>7ä¸ªç¬¦æ–‡æ ‡è®°ï¼š3ç§å½¢çŠ¶ï¼ˆæœˆäº®ã€æ²™ã€å±±å³°ï¼‰ã€3ç§é¢œè‰²ï¼ˆç™½ã€æ©™ã€è“ï¼‰å’Œ1ä¸ªé•œåƒ</li>
                    <li>ä¸¤ç»„å„9ä¸ªé­”åƒï¼ˆå…‰æ–¹å’Œæš—æ–¹ï¼‰ï¼Œæ¯ä¸ªéƒ½æœ‰ä¸€ä¸ªå½±å­çŸ³å’Œæ ‡è®°é¢å…·ï¼Œæ˜¾ç¤ºä¹ç§ç‹¬ç‰¹çš„å½¢çŠ¶/é¢œè‰²ç»„åˆä¹‹ä¸€</li>
                </ul>

                <h3>æ¸¸æˆå‡†å¤‡</h3>
                <ol>
                    <li>ç»™æ¯ä½çŽ©å®¶ä¸€ç»„é­”åƒã€‚æ‹¥æœ‰æš—è‰²é­”åƒçš„çŽ©å®¶å…ˆè¡Œã€‚</li>
                    <li>åœ¨ä½ çš„å‰ä¸¤æŽ’äº¤æ›¿æ ¼å­ä¸Šéšæœºæ”¾ç½®8ä¸ªé­”åƒã€‚å…‰æ–¹é­”åƒæ”¾åœ¨æš—æ ¼ä¸Šï¼›æš—æ–¹é­”åƒæ”¾åœ¨äº®æ ¼ä¸Šã€‚</li>
                    <li>å°†ç¬¬9ä¸ªé­”åƒæ”¾åœ¨ä¸€æ—â€”â€”æ‹†è§£å®ƒï¼Œå°†é¢å…·å’Œå½±å­æ”¾å…¥ä½ çš„è¡¥ç»™ã€‚</li>
                    <li>éšæœºåˆ†é…ç¬¦æ–‡ï¼šæš—æ–¹èŽ·å¾—3ä¸ªï¼Œå…‰æ–¹èŽ·å¾—3ä¸ªã€‚å‰©ä½™çš„ç¬¦æ–‡æˆä¸ºæš—æ–¹çš„ä¼‘æ¯ç¬¦æ–‡ã€‚</li>
                </ol>

                <h3>ç›®æ ‡</h3>
                <p>å°†ä½ çš„é­”åƒæŽ¨è¿›åˆ°æ£‹ç›˜å¯¹é¢ï¼Œæˆä¸ºç¬¬ä¸€ä¸ªå°†é­”åƒç§»å…¥å¯¹æ‰‹åº•çº¿çš„çŽ©å®¶ã€‚å…ˆåˆ°è€…èŽ·èƒœï¼</p>

                <h3>å›žåˆæ‘˜è¦</h3>
                <p>çŽ©å®¶è½®æµè¡ŒåŠ¨ã€‚å›žåˆå¼€å§‹æ—¶ï¼Œä½ æ‰‹ä¸­æœ‰3ä¸ªç¬¦æ–‡å’Œ1ä¸ªä¼‘æ¯ç¬¦æ–‡ã€‚ä½ å¿…é¡»é‡‡å–è¡ŒåŠ¨â€”â€”ä¸èƒ½è·³è¿‡å›žåˆã€‚</p>
                <ol>
                    <li><strong>æ‰“å‡ºä¸€ä¸ªç¬¦æ–‡</strong>ä½œä¸ºæ¿€æ´»ç¬¦æ–‡ï¼Œç„¶åŽï¼š
                        <ul>
                            <li>ç§»åŠ¨ä¸€ä¸ªä¸Žæ¿€æ´»ç¬¦æ–‡çš„å½¢çŠ¶æˆ–é¢œè‰²åŒ¹é…çš„é­”åƒï¼ˆå¦‚æžœé•œåƒæ˜¯æ¿€æ´»ç¬¦æ–‡ï¼Œåˆ™åŒ¹é…ä¼‘æ¯ç¬¦æ–‡ï¼‰</li>
                            <li>æˆ–è€…é‡æ–°æ¿€æ´»ä¸€ä¸ªé­”åƒ</li>
                        </ul>
                    </li>
                    <li><strong>è§£å†³</strong>ç”±ç§»åŠ¨æˆ–é‡æ–°æ¿€æ´»äº§ç”Ÿçš„æ•èŽ·</li>
                    <li>é€šè¿‡æ‹¿èµ·ä¼‘æ¯ç¬¦æ–‡<strong>ç»“æŸå›žåˆ</strong></li>
                    <li>ä½ ä½¿ç”¨çš„ç¬¦æ–‡æˆä¸ºå¯¹æ‰‹çš„æ–°ä¼‘æ¯ç¬¦æ–‡</li>
                </ol>

                <h3>å¦‚ä½•ç§»åŠ¨</h3>
                <p>æ¯ä¸ªæ ¼å­æœ€å¤šåªèƒ½å®¹çº³ä¸€ä¸ªé­”åƒæˆ–å½±å­ã€‚</p>
                <h4>æ­¥è¡Œ</h4>
                <ul>
                    <li>æ²¿æ­£äº¤æ–¹å‘ç§»åŠ¨2æ ¼ï¼ˆä¸œ/å—/è¥¿/åŒ—ï¼‰ã€‚è¿™å¯èƒ½è¢«ä¸­é—´æ ¼çš„å¯¹æ–¹æ£‹å­é˜»æŒ¡ã€‚</li>
                    <li>æˆ–è€…æ²¿å¯¹è§’çº¿ç§»åŠ¨1æ ¼ã€‚è¿™ä¸ä¼šè¢«é™„è¿‘çš„æ£‹å­é˜»ç¢ã€‚</li>
                </ul>
                <h4>è·³è·ƒ</h4>
                <ul>
                    <li>æ²¿å¯¹è§’çº¿è·³è¿‡å·±æ–¹æ£‹å­ï¼ˆåŒ…æ‹¬å½±å­ï¼‰åˆ°è¾¾ä¸‹ä¸€ä¸ªç©ºæ ¼</li>
                    <li>ä½ å¯ä»¥è·³è¿‡ä¸€ä¸ªæˆ–å¤šä¸ªè¿žç»­æŽ’åˆ—çš„æ£‹å­</li>
                    <li>å¯ä»¥å°†å¤šæ¬¡è·³è·ƒè¿žæŽ¥æˆä¸€æ¬¡ç§»åŠ¨</li>
                    <li>åŒä¸€å›žåˆå†…ä¸èƒ½è·³å›žèµ·å§‹æ ¼</li>
                </ul>

                <h3>æ•èŽ·æ£‹å­</h3>
                <ul>
                    <li>ç§»åŠ¨æˆ–é‡æ–°æ¿€æ´»åŽï¼Œä½ çš„é­”åƒä¼šæ•èŽ·ä»»ä½•è¢«ç§»åŠ¨çš„é­”åƒå’Œä½ çš„å¦ä¸€ä¸ªæ£‹å­ä»Žä¸¤ä¾§ï¼ˆæ°´å¹³æˆ–åž‚ç›´ï¼‰åŒ…å›´çš„å¯¹æ–¹æ£‹å­</li>
                    <li>ç§»åŠ¨çš„æ£‹å­ä¼šæ•èŽ·ä»»ä½•ä¸Žå®ƒåœ¨å½¢çŠ¶ã€é¢œè‰²æˆ–ä¸¤è€…ä¸Š<strong>ä¸</strong>åŒ¹é…çš„å¯¹æ–¹æ£‹å­ã€‚å½¢çŠ¶æˆ–é¢œè‰²åŒ¹é…çš„æ£‹å­æ˜¯å®‰å…¨çš„ã€‚</li>
                    <li>é™æ­¢æ£‹å­çš„å½¢çŠ¶/é¢œè‰²æ— å…³ç´§è¦â€”â€”åªæœ‰ç§»åŠ¨æ£‹å­çš„å±žæ€§æ‰é‡è¦</li>
                    <li>è¢«æ•èŽ·çš„æ£‹å­è¢«æ‹†è§£å¹¶è¿”è¿˜ç»™å…¶æ‰€æœ‰è€…çš„è¡¥ç»™</li>
                    <li>ç§»å…¥ä¸¤ä¸ªå¯¹æ–¹æ£‹å­ä¹‹é—´<strong>ä¸ä¼š</strong>å¯¼è‡´ä½ è¢«æ•èŽ·</li>
                </ul>

                <h3>å½±å­</h3>
                <ul>
                    <li>å½“ä½ çš„é­”åƒç§»åŠ¨æ—¶ï¼Œä½ å¯ä»¥åœ¨ç¦»å¼€çš„æ ¼å­ä¸Šæ”¾ç½®ä¸€ä¸ªå½±å­ï¼ˆå¦‚æžœè¡¥ç»™ä¸­æœ‰çš„è¯ï¼‰</li>
                    <li><strong>åœ¨å…‰æ–¹æ”¾ç½®å½±å­ä¹‹å‰ï¼Œæš—æ–¹ä¸èƒ½æ”¾ç½®å½±å­</strong></li>
                    <li>å½±å­ä¸èƒ½ç§»åŠ¨ï¼Œä½†å¯ä»¥é˜»æŒ¡å¯¹æ–¹çš„æ­¥è¡Œ</li>
                    <li>ä½ çš„é­”åƒå¯ä»¥è·³è¿‡è‡ªå·±çš„å½±å­</li>
                    <li>å½±å­å¯ä»¥ä½œä¸ºæ•èŽ·çš„é™æ­¢æ£‹å­</li>
                    <li>å½±å­å¯ä»¥è¢«ä»»ä½•å¯¹æ–¹æ£‹å­æ•èŽ·ï¼ˆä¸éœ€è¦åŒ¹é…ï¼‰</li>
                    <li><strong>å½±å­æ•èŽ·è§„åˆ™ï¼š</strong>å¦‚æžœä½ çš„ä¸€ä¸ªå½±å­è¢«æ•èŽ·ï¼Œä½ æ‰€æœ‰å‰©ä½™çš„å½±å­ç«‹å³è¢«ç§»é™¤å¹¶è¿”å›žè¡¥ç»™</li>
                </ul>

                <h3>é‡æ–°æ¿€æ´»</h3>
                <ul>
                    <li>ä½œä¸ºç§»åŠ¨çš„æ›¿ä»£ï¼Œå°†è¡¥ç»™ä¸­çš„é¢å…·æ”¾ç½®åœ¨æ£‹ç›˜ä¸Šä½ çš„ä¸€ä¸ªå½±å­ä¸Š</li>
                    <li>é¢å…·å¿…é¡»åŒæ—¶åŒ¹é…æ¿€æ´»ç¬¦æ–‡<strong>å’Œ</strong>ä¼‘æ¯ç¬¦æ–‡</li>
                    <li>å¦‚æžœé•œåƒæ˜¯ä½ çš„æ¿€æ´»æˆ–ä¼‘æ¯ç¬¦æ–‡ï¼Œä½ å¯ä»¥é‡æ–°æ¿€æ´»ä»»ä½•åŒ¹é…å¦ä¸€ä¸ªç¬¦æ–‡çš„æ£‹å­</li>
                    <li>é‡æ–°æ¿€æ´»åŽï¼Œè§£å†³ä»»ä½•æ•èŽ·</li>
                </ul>

                <h3>ç»“æŸæ¸¸æˆ</h3>
                <p><strong>çªç„¶æ­»äº¡ï¼š</strong>å½“ä¸€åçŽ©å®¶å°†é­”åƒç§»å…¥å¯¹æ‰‹çš„åº•çº¿æ—¶ï¼Œæ¸¸æˆç«‹å³ç»“æŸã€‚è¯¥çŽ©å®¶èŽ·èƒœï¼</p>
                <p><strong>é¢å¤–ç”Ÿå‘½ï¼š</strong>æ¯æ¬¡ä½ å®Œæˆçªç ´åˆ°å¯¹æ‰‹åº•çº¿ï¼Œå¯¹æ‰‹éƒ½ä¼šå¤±åŽ»ä¸€æ¡ç”Ÿå‘½ã€‚å¾—åˆ†çš„é­”åƒä»å¯åœ¨è¯¥å›žåˆè¿›è¡Œæ•èŽ·å’Œæ”¾ç½®å½±å­ã€‚å®Œæˆçªç ´åŽï¼Œè¯¥é­”åƒä½œä¸ºé¢å…·å’Œå½±å­è¿”å›žä½ çš„è¡¥ç»™ã€‚å°†å¯¹æ‰‹çš„ç”Ÿå‘½å€¼é™ä¸ºé›¶å³å¯èŽ·èƒœï¼</p>
                <p>å¦‚æžœä¸€åçŽ©å®¶æ— æ³•é‡‡å–ä»»ä½•æœ‰æ•ˆè¡ŒåŠ¨ï¼ˆæ²¡æœ‰ç¬¦æ–‡å…è®¸ç§»åŠ¨æˆ–é‡æ–°æ¿€æ´»ï¼‰ï¼Œæ¸¸æˆä»¥<strong>å¹³å±€</strong>ç»“æŸã€‚</p>

                <h3>ç¬¦å·å‚è€ƒ</h3>
                <p><strong>å½¢çŠ¶ï¼š</strong>Î© æœˆäº®, Î§ æ²™, Î› å±±å³°</p>
                <p><strong>é¢œè‰²ï¼š</strong>ç™½è‰², æ©™è‰², è“è‰²</p>
                <p><strong>é•œåƒï¼š</strong>â—‡ï¼ˆå¤åˆ¶ä¼‘æ¯ç¬¦æ–‡ï¼‰</p>
                `,
                tutorial: [
                    // Capsule 1: Objective
                    `<h2>ç›®æ ‡</h2>
                    <div class="tutorial-body">
                        <p>Inaraæ˜¯ä¸€æ¬¾å›žåˆåˆ¶åŒäººæŠ½è±¡ç­–ç•¥æ¸¸æˆã€‚</p>
                        <p><strong>ä½ çš„ç›®æ ‡ï¼š</strong>ç”¨ä½ çš„<em>é­”åƒ</em>åœ¨å¯¹æ‰‹çš„åº•çº¿å®Œæˆçªç ´ä»¥èŽ·èƒœã€‚</p>
                    </div>`,
                    
                    // Capsule 2: Components
                    `<h2>ç»„ä»¶</h2>
                    <div class="tutorial-body">
                        <p>æ¸¸æˆåœ¨ä¸€ä¸ª8Ã—8çš„æ£‹ç›˜ä¸Šè¿›è¡Œï¼Œä¸¤åçŽ©å®¶é¢å¯¹é¢åç€ã€‚</p>
                        <p>æœ‰<strong>7ä¸ªç¬¦æ–‡</strong>ï¼ˆ3ç§é¢œè‰²ã€3ç§å½¢çŠ¶å’Œä¸€ä¸ªé•œåƒï¼‰ï¼Œä»¥åŠæ¯ä½çŽ©å®¶<strong>9ä¸ªé­”åƒ</strong>ã€‚</p>
                        <p>æ¯ä¸ªé­”åƒæœ‰2ä¸ªä¸Žç¬¦æ–‡åŒ¹é…çš„ç‰¹å¾ï¼ˆä¸€ç§é¢œè‰²å’Œä¸€ç§å½¢çŠ¶ï¼‰ï¼š</p>
                        <ul>
                            <li><strong>é¢œè‰²ï¼š</strong>è“è‰²ã€æ©™è‰²ã€ç™½è‰²</li>
                            <li><strong>å½¢çŠ¶ï¼š</strong>Î› å±±å³°, Î§ æ²™, Î© æœˆäº®</li>
                        </ul>
                    </div>`,
                    
                    // Capsule 3: Preparation
                    `<h2>å‡†å¤‡</h2>
                    <div class="tutorial-body">
                        <p>å†³å®šè°å…ˆè¡Œã€‚ä½ å¯ä»¥é€‰æ‹©è®¡æ—¶æˆ–ä¸è®¡æ—¶ã€‚</p>
                        <p>ä½œä¸º<strong>æš—æ–¹</strong>ï¼Œä½ ä½œä¸ºå…ˆæ‰‹çŽ©å®¶æŽ§åˆ¶æš—è‰²æ£‹å­ã€‚ä½ çš„<strong>å…‰æ–¹</strong>å¯¹æ‰‹ä½¿ç”¨æµ…è‰²æ£‹å­ã€‚</p>
                        <p>æš—è‰²æ£‹å­åœ¨äº®æ ¼ä¸Šç§»åŠ¨ï¼›æµ…è‰²æ£‹å­åœ¨æš—æ ¼ä¸Šç§»åŠ¨ã€‚</p>
                        <p>æ‹¿èµ·ç¬¦æ–‡ï¼Œéšæœºç»™æ¯ä½çŽ©å®¶3ä¸ªä½œä¸ºèµ·å§‹æ‰‹ç‰Œã€‚å‰©ä½™çš„ç¬¦æ–‡æˆä¸ºå…ˆæ‰‹çŽ©å®¶çš„<em>ä¼‘æ¯</em>ç¬¦æ–‡ã€‚</p>
                        <p>æ¯ä½çŽ©å®¶æœ‰9ä¸ªé­”åƒã€‚éšæœºå°†8ä¸ªæ”¾ç½®åœ¨ä½ å‰ä¸¤æŽ’çš„èµ·å§‹æ ¼ä¸Šã€‚å‰©ä½™çš„é­”åƒè¢«æ‹†è§£ï¼Œé¢å…·ä¿å­˜åœ¨ä½ çš„è¡¥ç»™ä¸­ã€‚</p>
                    </div>`,
                    
                    // Capsule 4: Glyphs (INTERACTIVE)
                    `<h2>ç¬¦æ–‡</h2>
                    <div class="tutorial-body">
                        <p>æ¯å›žåˆï¼Œæ¿€æ´»ä¸€ä¸ªç¬¦æ–‡æ¥æ‰§è¡Œä¸€ä¸ªè¡ŒåŠ¨ã€‚</p>
                        <p><strong>è¡ŒåŠ¨ï¼š</strong>æ­¥è¡Œã€è·³è·ƒæˆ–é‡æ–°æ¿€æ´»</p>
                        <p>æ‰§è¡Œè¯¥è¡ŒåŠ¨çš„é­”åƒå¿…é¡»ä¸Žç¬¦æ–‡çš„å½¢çŠ¶æˆ–é¢œè‰²åŒ¹é…ã€‚<strong>é•œåƒç¬¦æ–‡ â—‡</strong>è®©ä½ å¤åˆ¶å½“å‰å›žåˆçš„ä¼‘æ¯ç¬¦æ–‡ã€‚</p>
                        <p>æ‰§è¡Œå®Œè¡ŒåŠ¨åŽï¼Œä½ æ¿€æ´»çš„ç¬¦æ–‡æˆä¸ºå¯¹æ‰‹çš„ä¼‘æ¯ç¬¦æ–‡ã€‚ä½ å°†ä¼‘æ¯ç¬¦æ–‡æ”¶å›žæ‰‹ä¸­ã€‚</p>
                        <p><strong>è­¦å‘Šï¼š</strong>å¦‚æžœé­”åƒä¸åŒ¹é…ä½ æ‰‹ä¸­çš„ä»»ä½•ç¬¦æ–‡ï¼Œå®ƒåœ¨è¯¥å›žåˆæ— æ³•æ‰§è¡Œä»»ä½•è¡ŒåŠ¨ï¼</p>
                        <div class="tutorial-prompt">
                            <p>é€‰æ‹©ä¸åŒçš„ç¬¦æ–‡å’Œé­”åƒæ¥çœ‹å®ƒä»¬å¦‚ä½•åŒ¹é…ï¼š</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="select-golem-1">â˜ é€‰æ‹©ä¸€ä¸ªä¸Žç¬¦æ–‡åŒ¹é…çš„é­”åƒ</li>
                                <li data-objective="select-golem-2">â˜ é€‰æ‹©å¦ä¸€ä¸ªä¸Žç¬¦æ–‡åŒ¹é…çš„é­”åƒ</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 5: Steps (INTERACTIVE)
                    `<h2>æ­¥è¡Œ</h2>
                    <div class="tutorial-body">
                        <p><strong>æ­£äº¤æ­¥è¡Œï¼š</strong>æ²¿ç›´çº¿ï¼ˆä¸œ/å—/è¥¿/åŒ—ï¼‰ç§»åŠ¨æ­£å¥½2æ ¼ã€‚ä¸­é—´æ ¼å¿…é¡»ä¸ºç©ºã€‚</p>
                        <p><strong>å¯¹è§’æ­¥è¡Œï¼š</strong>æ²¿å¯¹è§’çº¿ç§»åŠ¨æ­£å¥½1æ ¼ã€‚</p>
                        <div class="tutorial-prompt">
                            <p>å°è¯•ä¸¤ç§æ­¥è¡Œæ–¹å¼ï¼š</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="ortho-step">â˜ æ­£äº¤æ­¥è¡Œï¼ˆ2æ ¼ï¼‰</li>
                                <li data-objective="diag-step">â˜ å¯¹è§’æ­¥è¡Œï¼ˆ1æ ¼ï¼‰</li>
                            </ul>
                            <button class="tutorial-reset-btn" onclick="resetTutorialScenario()">é‡ç½®</button>
                            <button class="tutorial-continue-btn" id="tutorialContinueBtn" onclick="tutorialNext()" disabled>ç»§ç»­</button>
                        </div>
                    </div>`,
                    
                    // Capsule 6: Single Jump (INTERACTIVE)
                    `<h2>è·³è·ƒï¼šå•è·³</h2>
                    <div class="tutorial-body">
                        <p><strong>å¯¹è§’</strong>è·³è¿‡ä¸€ä¸ªå‹æ–¹æ£‹å­ï¼Œè½åœ¨å®ƒåŽé¢çš„ç©ºæ ¼ä¸Šã€‚</p>
                        <p>ä½ ä¸èƒ½è·³è¿‡æ•Œäººæˆ–ç©ºæ ¼ã€‚</p>
                        <div class="tutorial-prompt">
                            <p>å‘å‰è·³è¿‡ä¸€ä¸ªæ£‹å­ã€‚</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="single-jump">â˜ å‘å‰åšä¸€æ¬¡å•æ£‹å­è·³è·ƒ</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 7: Multi-Piece Jump (INTERACTIVE)
                    `<h2>è·³è·ƒï¼šå¤šæ£‹å­</h2>
                    <div class="tutorial-body">
                        <p>ä½ å¯ä»¥åœ¨ä¸€æ¬¡è·³è·ƒä¸­è·³è¿‡<strong>å¤šä¸ªè¿žç»­çš„æ£‹å­</strong>ã€‚è½åœ¨å®ƒä»¬ä¹‹åŽçš„ç¬¬ä¸€ä¸ªç©ºæ ¼ä¸Šã€‚</p>
                        <div class="tutorial-prompt">
                            <p>ä¸€æ¬¡è·³è¿‡ä¸¤ä¸ªæˆ–æ›´å¤šæ£‹å­ã€‚</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="multi-piece-jump">â˜ ä¸€æ¬¡è·³è·ƒè·³è¿‡å¤šä¸ªæ£‹å­</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 8: Chain Jumps (INTERACTIVE)
                    `<h2>è·³è·ƒï¼šè¿žç»­è·³è·ƒ</h2>
                    <div class="tutorial-body">
                        <p>è½åœ°åŽï¼Œå¦‚æžœå¦ä¸€ä¸ªå‹æ–¹æ£‹å­ç›¸é‚»ï¼Œä½ å¯ä»¥<strong>ç»§ç»­</strong>å‘ä»»ä½•å¯¹è§’æ–¹å‘è·³è·ƒã€‚æ‰€æœ‰è·³è·ƒåœ¨ä¸€å›žåˆå†…å®Œæˆï¼</p>
                        <div class="tutorial-prompt">
                            <p>ç”¨ä½ çš„å½±å­ä½œä¸ºè¸è„šçŸ³ã€‚è¿›è¡Œ2æ¬¡æˆ–æ›´å¤šè·³è·ƒçš„è¿žç»­è·³è·ƒï¼</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="chain-jump">â˜ è¿›è¡Œè¿žç»­è·³è·ƒï¼ˆä¸€æ¬¡ç§»åŠ¨ä¸­2+æ¬¡è·³è·ƒï¼‰</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 9: Completing a Run (INTERACTIVE)
                    `<h2>å®Œæˆçªç ´</h2>
                    <div class="tutorial-body">
                        <p><strong>æš—æ–¹</strong>é€šè¿‡åˆ°è¾¾ç¬¬1è¡Œï¼ˆå…‰æ–¹åº•çº¿ï¼‰å®Œæˆçªç ´ã€‚</p>
                        <p><strong>å…‰æ–¹</strong>é€šè¿‡åˆ°è¾¾ç¬¬8è¡Œï¼ˆæš—æ–¹åº•çº¿ï¼‰å®Œæˆçªç ´ã€‚</p>
                        <p>åœ¨<strong>çªç„¶æ­»äº¡</strong>æ¨¡å¼ä¸­ï¼Œç¬¬ä¸€ä¸ªå®Œæˆçªç ´çš„çŽ©å®¶ç«‹å³èŽ·èƒœï¼</p>
                        <p>åœ¨<strong>å¤šç”Ÿå‘½</strong>æ¨¡å¼ä¸­ï¼Œå®Œæˆçªç ´çš„é­”åƒé¦–å…ˆåœ¨ç›®æ ‡æ ¼è¿›è¡Œæ•èŽ·ï¼Œç„¶åŽä½œä¸ºå½±å­å’Œé¢å…·è¿”å›žä½ çš„è¡¥ç»™ã€‚</p>
                        <div class="tutorial-prompt">
                            <p>åˆ°è¾¾é¡¶è¡Œå®Œæˆçªç ´ï¼</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reach-goal">â˜ å°†é­”åƒç§»åˆ°ç¬¬1è¡Œ</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 10: Capturing (INTERACTIVE)
                    `<h2>æ•èŽ·</h2>
                    <div class="tutorial-body">
                        <p>é€šè¿‡ç”¨ä¸¤ä¸ªå·±æ–¹æ£‹å­ä»Žä¸¤ä¾§åŒ…å›´å¯¹æ–¹æ£‹å­æ¥æ•èŽ·å®ƒä»¬ã€‚</p>
                        <p>ä½ å¿…é¡»åœ¨å›žåˆä¸­ç”¨ä½ ç§»åŠ¨æˆ–é‡æ–°æ¿€æ´»çš„é­”åƒåˆ›é€ è¿™ä¸ª"å¤¹å‡»"ã€‚</p>
                        <p>ä½ æ¿€æ´»çš„é­”åƒåªæœ‰åœ¨ä¸Žç›®æ ‡é­”åƒçš„å½¢çŠ¶æˆ–é¢œè‰²<strong>ä¸</strong>åŒ¹é…æ—¶æ‰ä¼šæ•èŽ·å®ƒã€‚</p>
                        <div class="tutorial-prompt">
                            <p>å¤¹å‡»æµ…è‰²æ£‹å­æ¥æ•èŽ·å®ƒã€‚</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="capture">â˜ æ•èŽ·ä¸€ä¸ªæ•Œæ–¹æ£‹å­</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 11: Double Capture (INTERACTIVE)
                    `<h2>æ•èŽ·ï¼šå¤šé‡ä¸Žå…ç–«</h2>
                    <div class="tutorial-body">
                        <p>å¦‚æžœä½ åœ¨ä¸åŒæ–¹å‘å¤¹å‡»å¤šä¸ªæ£‹å­ï¼Œå¯ä»¥åœ¨ä¸€æ¬¡ç§»åŠ¨ä¸­æ•èŽ·<strong>å¤šä¸ªæ£‹å­</strong>ã€‚</p>
                        <p>ä½†è®°ä½ï¼šä¸Žä½ ç§»åŠ¨çš„æ£‹å­<strong>å…±äº«ç‰¹å¾</strong>ï¼ˆå½¢çŠ¶æˆ–é¢œè‰²ï¼‰çš„æ£‹å­<strong>å…ç–«</strong>æ•èŽ·ï¼</p>
                        <div class="tutorial-prompt">
                            <p>ä¸€æ¬¡æ•èŽ·ä¸¤ä¸ªæ£‹å­ã€‚æ³¨æ„ç¬¬ä¸‰ä¸ªæ£‹å­æ˜¯å…ç–«çš„ï¼</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="double-capture">â˜ ä¸€æ¬¡ç§»åŠ¨æ•èŽ·ä¸¤ä¸ªæ£‹å­</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 12: Safe Movement (INTERACTIVE)
                    `<h2>æ•èŽ·ï¼šå®‰å…¨ç§»åŠ¨</h2>
                    <div class="tutorial-body">
                        <p>å¦‚æžœä½ çš„æ£‹å­ä¸Žæ•Œæ–¹æ£‹å­è‡³å°‘å…±äº«ä¸€ä¸ªç‰¹å¾ï¼Œä½ å¯ä»¥å®‰å…¨åœ°ç§»åŠ¨åˆ°æ•Œæ–¹æ£‹å­<strong>ä¹‹é—´</strong>ã€‚</p>
                        <p>è¿™ç§å…ç–«æ˜¯åŒå‘çš„â€”â€”ä½ ä¸èƒ½æ•èŽ·å®ƒä»¬ï¼Œä½†å®ƒä»¬ä¹Ÿä¸èƒ½æ•èŽ·ä½ ï¼</p>
                        <div class="tutorial-prompt">
                            <p>åœ¨æ•Œæ–¹æ£‹å­ä¹‹é—´ç§»åŠ¨è€Œä¸è¢«æ•èŽ·ã€‚</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="safe-move">â˜ åœ¨æ•Œæ–¹æ£‹å­ä¹‹é—´å®‰å…¨ç§»åŠ¨</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 13: Shadows (INTERACTIVE)
                    `<h2>å½±å­</h2>
                    <div class="tutorial-body">
                        <p>ç§»åŠ¨åŽï¼Œä½ å¯ä»¥é€šè¿‡åœ¨ç§»åŠ¨å‰ç‚¹å‡»å½±å­æŒ‰é’®ï¼Œåœ¨ç¦»å¼€çš„æ ¼å­ä¸Šç•™ä¸‹ä¸€ä¸ª<strong>å½±å­</strong>ã€‚</p>
                        <p>å½±å­å¯ä½œä¸ºå¯¹è§’è·³è·ƒçš„è¸è„šçŸ³ï¼Œå¹¶é˜»æŒ¡æ•Œäººçš„ç§»åŠ¨è·¯å¾„ã€‚</p>
                        <p><strong>æ³¨æ„ï¼š</strong>åœ¨å…‰æ–¹æ”¾ç½®å½±å­ä¹‹å‰ï¼Œæš—æ–¹ä¸èƒ½æ”¾ç½®å½±å­ã€‚</p>
                        <p><strong>è­¦å‘Šï¼š</strong>å¦‚æžœä½ çš„ä»»ä½•å½±å­è¢«æ•èŽ·ï¼Œä½ æ‰€æœ‰çš„å½±å­éƒ½ä¼šè¢«ç§»é™¤ï¼</p>
                        <div class="tutorial-prompt">
                            <p>å½±å­å¼€å…³å·²æ‰“å¼€ã€‚ç§»åŠ¨ä»¥åœ¨èº«åŽç•™ä¸‹å½±å­ï¼</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="shadow-place">â˜ æ”¾ç½®ä¸€ä¸ªå½±å­</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 14: Reactivation (INTERACTIVE)
                    `<h2>é‡æ–°æ¿€æ´»</h2>
                    <div class="tutorial-body">
                        <p>ä½œä¸ºç§»åŠ¨çš„æ›¿ä»£ï¼Œä½ å¯ä»¥<strong>é‡æ–°æ¿€æ´»</strong>ä¸€ä¸ªè¢«æ•èŽ·çš„æ£‹å­ï¼š</p>
                        <ul>
                            <li>ä½ å¿…é¡»åœ¨è¡¥ç»™ä¸­æœ‰é¢å…·ï¼Œå¹¶ä¸”æ£‹ç›˜ä¸Šæœ‰å½±å­</li>
                            <li>é¢å…·å¿…é¡»åŒæ—¶åŒ¹é…ä½ çš„æ¿€æ´»ç¬¦æ–‡<strong>å’Œ</strong>ä¼‘æ¯ç¬¦æ–‡</li>
                            <li>å¦‚æžœé•œåƒ â—‡ æ˜¯ä½ çš„æ¿€æ´»æˆ–ä¼‘æ¯ç¬¦æ–‡ï¼Œå®ƒä¼šå¤åˆ¶å¦ä¸€ä¸ªç¬¦æ–‡çš„è¦æ±‚</li>
                            <li>ç‚¹å‡»é¢å…·ï¼Œç„¶åŽç‚¹å‡»å½±å­æ¥æ”¾ç½®é­”åƒ</li>
                        </ul>
                        <div class="tutorial-prompt">
                            <p>é€‰æ‹©æ­£ç¡®çš„ç¬¦æ–‡ï¼Œå°†é¢å…·é‡æ–°æ¿€æ´»åˆ°å½±å­ä¸Šã€‚</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate">â˜ é‡æ–°æ¿€æ´»ä¸€ä¸ªé¢å…·</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 15: Reactivation Capture (INTERACTIVE)
                    `<h2>é‡æ–°æ¿€æ´»ï¼šæ•èŽ·</h2>
                    <div class="tutorial-body">
                        <p>å½“ä½ é‡æ–°æ¿€æ´»ä¸€ä¸ªé­”åƒæ—¶ï¼Œå®ƒå¯ä»¥åƒæ™®é€šç§»åŠ¨ä¸€æ ·<strong>æ•èŽ·</strong>æ•Œæ–¹æ£‹å­ï¼</p>
                        <p>é‡æ–°æ¿€æ´»çš„é­”åƒä¼šæ•èŽ·ä»»ä½•å®ƒå¤¹å‡»çš„ç›¸é‚»æ•Œæ–¹æ£‹å­ï¼ˆä¸å…±äº«ç‰¹å¾çš„ï¼‰ã€‚</p>
                        <div class="tutorial-prompt">
                            <p>é‡æ–°æ¿€æ´»ä½ çš„é¢å…·æ¥æ•èŽ·æ•Œæ–¹æ£‹å­ã€‚</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate-capture">â˜ é€šè¿‡é‡æ–°æ¿€æ´»æ•èŽ·</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 16: Ready to Play
                    `<h2>å‡†å¤‡å¼€å§‹ï¼</h2>
                    <div class="tutorial-body">
                        <p>ä½ çŽ°åœ¨å·²ç»äº†è§£äº†Inaraçš„åŸºæœ¬è¦ç´ ï¼š</p>
                        <ul>
                            <li>ç«žé€Ÿåˆ°è¾¾å¯¹æ‰‹åº•çº¿èŽ·èƒœ</li>
                            <li>ä½¿ç”¨ç¬¦æ–‡é€‰æ‹©å“ªäº›æ£‹å­å¯ä»¥ç§»åŠ¨</li>
                            <li>æ­¥è¡Œã€è·³è·ƒï¼Œå¹¶è¿žç»­å‘å‰æŽ¨è¿›</li>
                            <li>æ•èŽ·ä»¥é˜²å®ˆï¼Œé‡æ–°æ¿€æ´»ä»¥æ¢å¤</li>
                        </ul>
                        <p style="margin-top: 12px;"><strong>å¹³å±€ï¼š</strong>å¦‚æžœä½ çš„ç¬¦æ–‡éƒ½ä¸å…è®¸ç§»åŠ¨æˆ–é‡æ–°æ¿€æ´»ï¼Œæ¸¸æˆä»¥å¹³å±€ç»“æŸã€‚</p>
                        <button class="btn" onclick="closeTutorial(); showNewGameModal();" style="margin-top: 15px; width: 100%;">å¼€å§‹æ¸¸æˆ</button>
                    </div>`
                ]
            },
            es: {
                quick: `
                <h3>Objetivo</h3>
                <p><strong>Muerte SÃºbita:</strong> Â¡Lleva tus golems a travÃ©s del tablero y sÃ© el primero en mover uno a una casilla en la fila de inicio de tu oponente para ganar!</p>
                <p><strong>Vidas Extra:</strong> Â¡Tu oponente pierde una vida cada vez que completas una de estas carreras. Reduce sus vidas a cero para ganar!</p>

                <h3>En Tu Turno</h3>
                <ul>
                    <li>Selecciona un glifo de tu mano</li>
                    <li>Mueve un golem que coincida con la forma o color del glifo</li>
                    <li>Si usas el glifo Espejo, coincide con el glifo en reposo</li>
                    <li>El glifo usado se convierte en el glifo en reposo de tu oponente</li>
                    <li>Recoge tu glifo en reposo a tu mano</li>
                </ul>

                <h3>Movimiento</h3>
                <ul>
                    <li><strong>Paso:</strong> Mueve 2 espacios ortogonalmente (N/S/E/O) si la casilla del medio estÃ¡ vacÃ­a, O 1 espacio en diagonal</li>
                    <li><strong>Salto:</strong> Salta diagonalmente sobre tus propias piezas hasta la siguiente casilla vacÃ­a</li>
                    <li>Â¡Encadena mÃºltiples saltos en un turno!</li>
                </ul>

                <h3>Captura</h3>
                <ul>
                    <li>Rodea una pieza del oponente en lados opuestos (horizontal o vertical)</li>
                    <li>Tu pieza en movimiento NO debe coincidir con el objetivo en forma o color</li>
                    <li>Los golems capturados devuelven su mÃ¡scara y sombra al suministro del propietario</li>
                </ul>

                <h3>PuntuaciÃ³n (Vidas Extra)</h3>
                <ul>
                    <li>Los golems que completan una carrera aÃºn pueden hacer capturas y dejar sombras en ese turno</li>
                    <li>Completar una carrera devuelve ese golem a tu suministro como mÃ¡scara y sombra</li>
                </ul>

                <h3>Sombras</h3>
                <ul>
                    <li>DespuÃ©s de mover, puedes dejar una sombra en la casilla desocupada (si estÃ¡ disponible)</li>
                    <li>Oscuro no puede colocar sombras hasta que Claro haya colocado una primero</li>
                    <li>Las sombras pueden ayudar a capturar y bloquear movimiento</li>
                    <li>Â¡Si UNA sombra es capturada, TODAS tus sombras son removidas!</li>
                </ul>

                <h3>ReactivaciÃ³n</h3>
                <ul>
                    <li>En lugar de mover, coloca una mÃ¡scara de tu suministro sobre una de tus sombras</li>
                    <li>La mÃ¡scara debe coincidir TANTO con el glifo activo COMO con el glifo en reposo</li>
                    <li>Si usas Espejo, copia el requisito del otro glifo</li>
                </ul>

                <h3>SÃ­mbolos</h3>
                <p><strong>Formas:</strong> Î© Luna, Î§ Arena, Î› Pico</p>
                <p><strong>Colores:</strong> Blanco, Naranja, Azul</p>
                <p><strong>Espejo:</strong> â—‡ (copia el glifo en reposo)</p>
                `,
                full: `
                <h3>DescripciÃ³n</h3>
                <p>Inara es una contienda de posicionamiento hÃ¡bil y adaptaciÃ³n a recursos en constante cambio. No hay azar una vez que el juego ha comenzado y no hay informaciÃ³n oculta.</p>

                <h3>Materiales</h3>
                <ul>
                    <li>Un tablero de ajedrez (8Ã—8) con casillas claras y oscuras</li>
                    <li>7 fichas de Glifo: 3 formas (Luna, Arena, Pico), 3 colores (Blanco, Naranja, Azul) y 1 Espejo</li>
                    <li>Dos conjuntos de 9 golems (Claro y Oscuro), cada uno con una piedra de sombra y mÃ¡scara marcada mostrando una de nueve combinaciones Ãºnicas de forma/color</li>
                </ul>

                <h3>PreparaciÃ³n del Juego</h3>
                <ol>
                    <li>Dale a cada jugador un conjunto de golems. El jugador con golems oscuros mueve primero.</li>
                    <li>Coloca 8 de tus golems aleatoriamente en casillas alternadas en tus dos primeras filas. Los golems claros van en casillas oscuras; los golems oscuros van en casillas claras.</li>
                    <li>Deja tu 9Âº golem aparteâ€”desmÃ³ntalo y pon la mÃ¡scara y sombra en tu suministro.</li>
                    <li>Distribuye los glifos aleatoriamente: Oscuro recibe 3, Claro recibe 3. El glifo restante se convierte en el glifo en reposo de Oscuro.</li>
                </ol>

                <h3>Objetivo</h3>
                <p>Â¡Lleva tus golems a travÃ©s del tablero y sÃ© el primero en mover uno a la fila trasera de tu oponente. La victoria es tuya si lo logras antes que ellos!</p>

                <h3>Resumen del Turno</h3>
                <p>Los jugadores alternan turnos. Al inicio de tu turno, tienes 3 glifos en mano y 1 en reposo. Debes tomar una acciÃ³nâ€”no puedes pasar.</p>
                <ol>
                    <li><strong>Juega un glifo</strong> de tu mano como el glifo activo, luego:
                        <ul>
                            <li>Mueve un golem que coincida con la forma o color del glifo activo (o si Espejo estÃ¡ activo, coincide con el glifo en reposo)</li>
                            <li>O Reactiva un golem</li>
                        </ul>
                    </li>
                    <li><strong>Resuelve capturas</strong> resultantes del movimiento o reactivaciÃ³n</li>
                    <li><strong>Termina tu turno</strong> recogiendo el glifo en reposo</li>
                    <li>Tu glifo usado se convierte en el nuevo glifo en reposo para tu oponente</li>
                </ol>

                <h3>CÃ³mo Mover</h3>
                <p>Cada casilla puede contener como mÃ¡ximo un golem o sombra.</p>
                <h4>Paso</h4>
                <ul>
                    <li>Mueve ortogonalmente 2 espacios (N/S/E/O). Esto puede ser bloqueado por piezas oponentes en la casilla intermedia.</li>
                    <li>O mueve 1 espacio diagonalmente. Esto no puede ser obstaculizado por piezas cercanas.</li>
                </ul>
                <h4>Salto</h4>
                <ul>
                    <li>Salta diagonalmente sobre tus propias piezas (incluyendo sombras) hasta la siguiente casilla vacÃ­a</li>
                    <li>Puedes saltar sobre una pieza o mÃºltiples piezas alineadas en fila</li>
                    <li>Encadena varios saltos juntos como un solo movimiento</li>
                    <li>No puedes saltar de vuelta a tu casilla inicial en el mismo turno</li>
                </ul>

                <h3>Capturar Piezas</h3>
                <ul>
                    <li>DespuÃ©s de mover o reactivar, tu golem captura cualquier pieza oponente rodeada en dos lados opuestos (horizontal o vertical) por el golem en movimiento y otra de tus piezas</li>
                    <li>La pieza en movimiento captura cualquier pieza oponente que <strong>no</strong> coincida con ella en forma, color o ambos. Las piezas que coinciden por forma o color estÃ¡n a salvo.</li>
                    <li>La forma/color de la pieza estacionaria no importaâ€”solo cuentan los atributos de la pieza en movimiento</li>
                    <li>Las piezas capturadas son desmontadas y devueltas al suministro de su propietario</li>
                    <li>Mover a una casilla entre dos piezas oponentes <strong>no</strong> resulta en tu captura</li>
                </ul>

                <h3>Sombras</h3>
                <ul>
                    <li>Cuando tu golem se mueve, puedes dejar una sombra en la casilla desocupada (si tienes una en suministro)</li>
                    <li><strong>Oscuro no puede colocar sombras hasta que Claro haya colocado una primero</strong></li>
                    <li>Las sombras no pueden moverse pero pueden bloquear pasos del oponente</li>
                    <li>Tus golems pueden saltar sobre tus propias sombras</li>
                    <li>Las sombras pueden ser piezas estacionarias para capturar</li>
                    <li>Las sombras pueden ser capturadas por cualquier pieza oponente (no se requiere coincidencia)</li>
                    <li><strong>Regla de Captura de Sombras:</strong> Si una de tus sombras es capturada, TODAS tus sombras restantes son inmediatamente removidas y devueltas a tu suministro</li>
                </ul>

                <h3>ReactivaciÃ³n</h3>
                <ul>
                    <li>En lugar de mover, coloca una mÃ¡scara de tu suministro sobre una de tus sombras en el tablero</li>
                    <li>La mÃ¡scara debe coincidir <strong>tanto</strong> con el glifo activo COMO con el glifo en reposo</li>
                    <li>Si Espejo es tu glifo activo o en reposo, puedes reactivar cualquier pieza que coincida con el otro glifo</li>
                    <li>DespuÃ©s de reactivar, resuelve cualquier captura</li>
                </ul>

                <h3>Fin del Juego</h3>
                <p><strong>Muerte SÃºbita:</strong> Â¡El juego termina inmediatamente cuando un jugador mueve un golem a la primera fila de su oponente. Ese jugador gana!</p>
                <p><strong>Vidas Extra:</strong> Tu oponente pierde una vida cada vez que completas una carrera a su fila trasera. El golem que anota aÃºn puede hacer capturas y dejar una sombra en ese turno. Completar una carrera tambiÃ©n devuelve ese golem a tu suministro como mÃ¡scara y sombra. Â¡Reduce sus vidas a cero para ganar!</p>
                <p>Si un jugador no puede tomar ninguna acciÃ³n vÃ¡lida (ningÃºn glifo permite movimiento o reactivaciÃ³n), el juego termina en <strong>empate</strong>.</p>

                <h3>Referencia de SÃ­mbolos</h3>
                <p><strong>Formas:</strong> Î© Luna, Î§ Arena, Î› Pico</p>
                <p><strong>Colores:</strong> Blanco, Naranja, Azul</p>
                <p><strong>Espejo:</strong> â—‡ (copia el glifo en reposo)</p>
                `,
                tutorial: [
                    // Capsule 1: Objective
                    `<h2>Objetivo</h2>
                    <div class="tutorial-body">
                        <p>Inara es un juego de estrategia abstracta por turnos para dos jugadores.</p>
                        <p><strong>Tu objetivo:</strong> Completa carreras en el lado de tu oponente con tus <em>golems</em> para ganar.</p>
                    </div>`,
                    
                    // Capsule 2: Components
                    `<h2>Componentes</h2>
                    <div class="tutorial-body">
                        <p>El juego se juega en un tablero de ajedrez 8Ã—8 con dos jugadores sentados uno frente al otro.</p>
                        <p>Hay <strong>7 glifos</strong> (3 colores, 3 formas y un espejo), asÃ­ como <strong>9 golems</strong> para cada jugador.</p>
                        <p>Cada golem tiene 2 rasgos (un color y una forma) que coinciden con los glifos:</p>
                        <ul>
                            <li><strong>Colores:</strong> Azul, Naranja, Blanco</li>
                            <li><strong>Formas:</strong> Î› Pico, Î§ Arena, Î© Luna</li>
                        </ul>
                    </div>`,
                    
                    // Capsule 3: Preparation
                    `<h2>PreparaciÃ³n</h2>
                    <div class="tutorial-body">
                        <p>Decide quiÃ©n irÃ¡ primero. Puedes jugar con o sin tiempo.</p>
                        <p>Como <strong>Oscuro</strong>, controlas las piezas oscuras como jugador inicial. Tu oponente <strong>Claro</strong> toma las piezas claras.</p>
                        <p>Las piezas oscuras se mueven en casillas claras; las piezas claras se mueven en casillas oscuras.</p>
                        <p>Toma los glifos y dale a cada jugador 3 aleatoriamente como sus manos iniciales. El glifo sobrante se convierte en el glifo <em>en reposo</em> del primer jugador.</p>
                        <p>Cada jugador tiene 9 golems. Coloca aleatoriamente 8 de ellos â€” uno en cada casilla inicial en tus dos primeras filas. Tu golem restante se desmonta y se guarda en tu suministro como mÃ¡scara.</p>
                    </div>`,
                    
                    // Capsule 4: Glyphs (INTERACTIVE)
                    `<h2>Glifos</h2>
                    <div class="tutorial-body">
                        <p>Cada turno, activa un glifo para realizar una acciÃ³n.</p>
                        <p><strong>Acciones:</strong> Paso, Salto o Reactivar</p>
                        <p>El golem que realiza esa acciÃ³n debe coincidir con el glifo por forma o color. El <strong>glifo espejo â—‡</strong> te permite copiar el glifo en reposo en tu turno.</p>
                        <p>Una vez que hayas realizado esa acciÃ³n, el glifo que activaste va a tu oponente como su glifo en reposo. Recoges tu glifo en reposo a tu mano.</p>
                        <p><strong>Advertencia:</strong> Â¡Si un golem no coincide con ningÃºn glifo en tu mano, no puede realizar ninguna acciÃ³n ese turno!</p>
                        <div class="tutorial-prompt">
                            <p>Selecciona diferentes glifos y golems para ver cÃ³mo coinciden:</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="select-golem-1">â˜ Selecciona un golem con un glifo coincidente</li>
                                <li data-objective="select-golem-2">â˜ Selecciona un golem diferente con un glifo coincidente</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 5: Steps (INTERACTIVE)
                    `<h2>Pasos</h2>
                    <div class="tutorial-body">
                        <p><strong>Paso Ortogonal:</strong> Mueve exactamente 2 casillas en lÃ­nea recta (N/S/E/O). La casilla del medio debe estar vacÃ­a.</p>
                        <p><strong>Paso Diagonal:</strong> Mueve exactamente 1 casilla diagonalmente.</p>
                        <div class="tutorial-prompt">
                            <p>Prueba ambos tipos de pasos:</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="ortho-step">â˜ Haz un paso ortogonal (2 casillas)</li>
                                <li data-objective="diag-step">â˜ Haz un paso diagonal (1 casilla)</li>
                            </ul>
                            <button class="tutorial-reset-btn" onclick="resetTutorialScenario()">Reiniciar</button>
                            <button class="tutorial-continue-btn" id="tutorialContinueBtn" onclick="tutorialNext()" disabled>Continuar</button>
                        </div>
                    </div>`,
                    
                    // Capsule 6: Single Jump (INTERACTIVE)
                    `<h2>Saltos: Salto Simple</h2>
                    <div class="tutorial-body">
                        <p>Salta <strong>diagonalmente</strong> sobre una pieza aliada para aterrizar en la casilla vacÃ­a justo detrÃ¡s de ella.</p>
                        <p>No puedes saltar sobre enemigos o casillas vacÃ­as.</p>
                        <div class="tutorial-prompt">
                            <p>Salta hacia adelante sobre una pieza.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="single-jump">â˜ Haz un salto simple hacia adelante</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 7: Multi-Piece Jump (INTERACTIVE)
                    `<h2>Saltos: MÃºltiples Piezas</h2>
                    <div class="tutorial-body">
                        <p>Puedes saltar sobre <strong>mÃºltiples piezas contiguas</strong> en un solo salto. Aterriza en la primera casilla vacÃ­a mÃ¡s allÃ¡ de todas ellas.</p>
                        <div class="tutorial-prompt">
                            <p>Salta sobre dos o mÃ¡s piezas a la vez.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="multi-piece-jump">â˜ Salta sobre mÃºltiples piezas en un salto</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 8: Chain Jumps (INTERACTIVE)
                    `<h2>Saltos: Saltos Encadenados</h2>
                    <div class="tutorial-body">
                        <p>DespuÃ©s de aterrizar, puedes <strong>continuar saltando</strong> en cualquier direcciÃ³n diagonal si otra pieza aliada estÃ¡ adyacente. Â¡Todos los saltos ocurren en un turno!</p>
                        <div class="tutorial-prompt">
                            <p>Usa tus sombras como escalones. Â¡Haz un salto encadenado con 2 o mÃ¡s saltos!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="chain-jump">â˜ Haz un salto encadenado (2+ saltos en un movimiento)</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 9: Completing a Run (INTERACTIVE)
                    `<h2>Completar una Carrera</h2>
                    <div class="tutorial-body">
                        <p><strong>Oscuro</strong> completa una carrera llegando a la fila 1 (fila trasera de Claro).</p>
                        <p><strong>Claro</strong> completa una carrera llegando a la fila 8 (fila trasera de Oscuro).</p>
                        <p>En <strong>Muerte SÃºbita</strong>, Â¡el primer jugador en completar una carrera gana inmediatamente!</p>
                        <p>Con <strong>mÃºltiples vidas</strong>, el golem que completa la carrera primero realiza cualquier captura en la casilla de destino, luego regresa a tu suministro como sombra y mÃ¡scara.</p>
                        <div class="tutorial-prompt">
                            <p>Â¡Alcanza la fila superior para completar una carrera!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reach-goal">â˜ Mueve un golem a la fila 1</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 10: Capturing (INTERACTIVE)
                    `<h2>Captura</h2>
                    <div class="tutorial-body">
                        <p>Captura las piezas de tu oponente rodeÃ¡ndolas en dos lados opuestos entre dos de tus piezas.</p>
                        <p>Debes crear este "sÃ¡ndwich" en tu turno con el golem que moviste o reactivaste.</p>
                        <p>El golem que activaste solo capturarÃ¡ otro golem si <strong>NO</strong> coincide con el golem objetivo por forma o color.</p>
                        <div class="tutorial-prompt">
                            <p>Encierra la pieza clara para capturarla.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="capture">â˜ Captura una pieza enemiga</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 11: Double Capture (INTERACTIVE)
                    `<h2>Captura: MÃºltiple e Inmunidad</h2>
                    <div class="tutorial-body">
                        <p>Puedes capturar <strong>mÃºltiples piezas</strong> en un movimiento si las encierras en diferentes direcciones.</p>
                        <p>Â¡Pero recuerda: las piezas que <strong>comparten un rasgo</strong> (forma o color) con tu pieza en movimiento son <strong>inmunes</strong> a la captura!</p>
                        <div class="tutorial-prompt">
                            <p>Captura dos piezas a la vez. Â¡Nota que la tercera pieza es inmune!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="double-capture">â˜ Captura dos piezas en un movimiento</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 12: Safe Movement (INTERACTIVE)
                    `<h2>Captura: Movimiento Seguro</h2>
                    <div class="tutorial-body">
                        <p>Puedes mover con seguridad <strong>entre</strong> piezas enemigas si tu pieza comparte un rasgo con al menos una de ellas.</p>
                        <p>Â¡Esta inmunidad funciona en ambas direcciones â€” no puedes capturarlas, pero ellas tampoco pueden capturarte!</p>
                        <div class="tutorial-prompt">
                            <p>Mueve entre las piezas enemigas sin ser capturado.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="safe-move">â˜ Mueve con seguridad entre piezas enemigas</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 13: Shadows (INTERACTIVE)
                    `<h2>Sombras</h2>
                    <div class="tutorial-body">
                        <p>DespuÃ©s de mover, puedes dejar una <strong>sombra</strong> en tu casilla desocupada haciendo clic en el botÃ³n de sombra antes de mover.</p>
                        <p>Las sombras actÃºan como escalones para saltos diagonales y bloquean las rutas de movimiento enemigas.</p>
                        <p><strong>Nota:</strong> Oscuro no puede colocar sombras hasta que Claro haya colocado una primero.</p>
                        <p><strong>Advertencia:</strong> Â¡Si CUALQUIERA de tus sombras es capturada, TODAS tus sombras son removidas!</p>
                        <div class="tutorial-prompt">
                            <p>El interruptor de sombra ya estÃ¡ activado. Â¡Mueve para dejar una sombra atrÃ¡s!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="shadow-place">â˜ Coloca una sombra</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 14: Reactivation (INTERACTIVE)
                    `<h2>ReactivaciÃ³n</h2>
                    <div class="tutorial-body">
                        <p>En lugar de mover, puedes <strong>reactivar</strong> una pieza capturada:</p>
                        <ul>
                            <li>Debes tener una mÃ¡scara en tu suministro y una sombra en el tablero</li>
                            <li>La mÃ¡scara debe coincidir <strong>TANTO</strong> con tu glifo activo <strong>COMO</strong> con tu glifo en reposo</li>
                            <li>Si el espejo â—‡ es tu glifo activo o en reposo, copia el requisito del otro glifo</li>
                            <li>Haz clic en la mÃ¡scara, luego en una sombra para colocar el golem</li>
                        </ul>
                        <div class="tutorial-prompt">
                            <p>Selecciona el glifo correcto y reactiva la mÃ¡scara sobre la sombra.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate">â˜ Reactiva una mÃ¡scara</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 15: Reactivation Capture (INTERACTIVE)
                    `<h2>ReactivaciÃ³n: Captura</h2>
                    <div class="tutorial-body">
                        <p>Â¡Cuando reactivas un golem, puede <strong>capturar</strong> piezas enemigas igual que un movimiento regular!</p>
                        <p>El golem reactivado captura cualquier pieza enemiga adyacente que encierre (que no comparta un rasgo).</p>
                        <div class="tutorial-prompt">
                            <p>Reactiva tu mÃ¡scara para capturar la pieza enemiga.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate-capture">â˜ Captura mediante reactivaciÃ³n</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 16: Ready to Play
                    `<h2>Â¡Listo para Jugar!</h2>
                    <div class="tutorial-body">
                        <p>Ahora conoces lo esencial de Inara:</p>
                        <ul>
                            <li>Corre hacia la fila trasera de tu oponente para ganar</li>
                            <li>Usa glifos para seleccionar quÃ© piezas pueden moverse</li>
                            <li>Da pasos, salta y encadena tu camino hacia adelante</li>
                            <li>Captura para defender, reactiva para recuperar</li>
                        </ul>
                        <p style="margin-top: 12px;"><strong>Empate:</strong> Si ninguno de tus glifos permite mover o reactivar, el juego termina en empate.</p>
                        <button class="btn" onclick="closeTutorial(); showNewGameModal();" style="margin-top: 15px; width: 100%;">Comenzar a Jugar</button>
                    </div>`
                ]
            }
        };
        
        function setLanguage(lang) {
            currentLanguage = lang;
            
            // Update language button states
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
            
            // Store original English content on first call
            if (!originalRulesQuick) {
                originalRulesQuick = document.getElementById('rules-quick').innerHTML;
                originalRulesFull = document.getElementById('rules-full').innerHTML;
                originalTutorialCapsules = [];
                document.querySelectorAll('.tutorial-capsule').forEach(capsule => {
                    originalTutorialCapsules.push(capsule.innerHTML);
                });
            }
            
            // Apply translations or restore English
            if (lang === 'en' || !translations[lang]) {
                document.getElementById('rules-quick').innerHTML = originalRulesQuick;
                document.getElementById('rules-full').innerHTML = originalRulesFull;
                document.querySelectorAll('.tutorial-capsule').forEach((capsule, i) => {
                    capsule.innerHTML = originalTutorialCapsules[i];
                });
            } else {
                document.getElementById('rules-quick').innerHTML = translations[lang].quick;
                document.getElementById('rules-full').innerHTML = translations[lang].full;
                document.querySelectorAll('.tutorial-capsule').forEach((capsule, i) => {
                    if (translations[lang].tutorial[i]) {
                        capsule.innerHTML = translations[lang].tutorial[i];
                    }
                });
            }
            
            // Save preference
            localStorage.setItem('inaraLanguage', lang);
        }
        
        // Load saved language preference on startup
        function loadLanguagePreference() {
            const saved = localStorage.getItem('inaraLanguage');
            if (saved && saved !== 'en') {
                setLanguage(saved);
            }
        }

        // === DOM ELEMENT CACHE ===
        const domCache = {};
        function getEl(id) {
            if (!domCache[id]) {
                domCache[id] = document.getElementById(id);
            }
            return domCache[id];
        }

        // === GAME STATE ===
        let gameState = null;
        let cpuMode = false;  // true = playing against CPU
        let cpuPlayer = 'light';  // which side CPU plays
        let historyStack = [];
        let tutorialMode = false;  // true = in tutorial mode
        let tutorialCurrentCapsule = 1;
        let tutorialSavedState = null;
        let tutorialObjectives = {};
        let tutorialSelectedGolems = new Set(); // Track unique golems selected in Glyphs tutorial
        
        // === ONLINE MULTIPLAYER STATE ===
        let onlineMode = false;
        let localPlayer = null;  // 'dark' or 'light'
        let peer = null;
        let conn = null;
        let isHost = false;
        let selectedHostSide = 'random'; // 'dark', 'light', or 'random'
        let localPlayerName = '';
        let remotePlayerName = '';
        
        // === ANALYSIS DATA ===
        let analysisData = {
            initialState: null,
            moves: [],
            currentMoveIndex: -1, // -1 means showing initial state
            isAnalysisMode: false
        };

        // === GAME SETTINGS ===
        let selectedTime = 0; // Default timeless
        let selectedIncrement = 0; // Default no increment
        let selectedLives = 0; // Default 0 extra lives (sudden death)

        function createInitialState() {
            return {
                board: Array(8).fill(null).map(() => Array(8).fill(null)),
                currentPlayer: 'dark',
                selectedGlyph: null,
                selectedPiece: null,
                selectedMask: null,
                darkHand: [],
                lightHand: [],
                darkResting: null,
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                gameOver: false,
                lightHasPlacedShadow: false,
                shadowPrimed: false,
                darkTime: selectedTime,
                lightTime: selectedTime,
                increment: selectedIncrement,
                noTimeLimit: selectedTime === 0,
                clockInterval: null,
                lastMoveTime: null,
                lastMove: null,
                isPaused: false,
                darkLives: selectedLives + 1,
                lightLives: selectedLives + 1
            };
        }

        // === INITIALIZATION ===
        function initGame() {
            if (gameState?.clockInterval) {
                clearInterval(gameState.clockInterval);
            }

            gameState = createInitialState();
            historyStack = [];
            
            // Reset board rendering state
            previousBoardState = null;
            boardInitialized = false;
            
            // Reset analysis data
            analysisData = {
                initialState: null,
                moves: [],
                currentMoveIndex: -1,
                isAnalysisMode: false
            };
            
            // Hide analysis UI if visible
            hideAnalysisUI();

            // Reset pause buttons
            const pauseBtns = document.querySelectorAll('.pause-btn');
            pauseBtns.forEach(btn => {
                btn.textContent = 'â¸';
                btn.classList.remove('paused');
                btn.title = 'Pause';
            });

            setupBoard();
            distributeGlyphs();
            
            // Save initial state for analysis (after board and glyphs are set up)
            analysisData.initialState = serializeGameState();
            
            gameState.lastMoveTime = Date.now();
            startClock();
            renderGame();
        }
        
        function serializeGameState() {
            // Deep clone the relevant game state for analysis
            return {
                board: gameState.board.map(row => row.map(cell => cell ? {...cell} : null)),
                currentPlayer: gameState.currentPlayer,
                darkHand: gameState.darkHand.map(g => ({...g})),
                lightHand: gameState.lightHand.map(g => ({...g})),
                darkResting: gameState.darkResting ? {...gameState.darkResting} : null,
                lightResting: gameState.lightResting ? {...gameState.lightResting} : null,
                darkSupply: {
                    shadows: gameState.darkSupply.shadows,
                    masks: gameState.darkSupply.masks.map(m => ({...m}))
                },
                lightSupply: {
                    shadows: gameState.lightSupply.shadows,
                    masks: gameState.lightSupply.masks.map(m => ({...m}))
                },
                lightHasPlacedShadow: gameState.lightHasPlacedShadow,
                lastMove: gameState.lastMove ? {...gameState.lastMove} : null,
                darkTime: gameState.darkTime,
                lightTime: gameState.lightTime,
                noTimeLimit: gameState.noTimeLimit,
                darkLives: gameState.darkLives,
                lightLives: gameState.lightLives
            };
        }
        
        function recordMove(moveData) {
            analysisData.moves.push({
                turnNumber: analysisData.moves.length + 1,
                timestamp: Date.now(),
                darkClock: gameState.darkTime,
                lightClock: gameState.lightTime,
                ...moveData
            });
        }

        function setupBoard() {
            const combinations = [];
            for (const shape of SHAPES) {
                for (const color of COLORS) {
                    combinations.push({ shape, color });
                }
            }

            const darkPieces = shuffle([...combinations]);
            const lightPieces = shuffle([...combinations]);

            // Light golems on rows 0-1 (top of board)
            let lightIndex = 0;
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 8; col++) {
                    if ((row + col) % 2 === 1 && lightIndex < 8) {
                        gameState.board[row][col] = {
                            type: 'golem',
                            player: 'light',
                            ...lightPieces[lightIndex++]
                        };
                    }
                }
            }
            gameState.lightSupply.masks.push(lightPieces[8]);

            // Dark golems on rows 6-7 (bottom of board)
            let darkIndex = 0;
            for (let row = 6; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if ((row + col) % 2 === 0 && darkIndex < 8) {
                        gameState.board[row][col] = {
                            type: 'golem',
                            player: 'dark',
                            ...darkPieces[darkIndex++]
                        };
                    }
                }
            }
            gameState.darkSupply.masks.push(darkPieces[8]);
        }

        function distributeGlyphs() {
            const allGlyphs = [];
            SHAPES.forEach(shape => allGlyphs.push({ type: 'shape', value: shape }));
            COLORS.forEach(color => allGlyphs.push({ type: 'color', value: color }));
            allGlyphs.push({ type: 'mirror', value: MIRROR });

            const shuffled = shuffle(allGlyphs);
            gameState.darkHand = shuffled.slice(0, 3);
            gameState.lightHand = shuffled.slice(3, 6);
            gameState.darkResting = shuffled[6];
            gameState.lightResting = null;
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // === CLOCK ===
        let lastRenderedClockDisplay = { dark: '', light: '' };
        
        function startClock() {
            if (gameState.clockInterval) clearInterval(gameState.clockInterval);
            if (!gameState.noTimeLimit) {
                // Update every 100ms for accuracy, but only render when display changes
                gameState.clockInterval = setInterval(updateClock, 100);
            }
            lastRenderedClockDisplay = { dark: '', light: '' }; // Force initial render
            renderClocks();
        }

        function updateClock() {
            if (gameState.gameOver || gameState.isPaused || gameState.noTimeLimit) {
                return;
            }

            const now = Date.now();
            const elapsed = (now - gameState.lastMoveTime) / 1000;

            if (gameState.currentPlayer === 'dark') {
                gameState.darkTime = Math.max(0, gameState.darkTime - elapsed);
                if (gameState.darkTime === 0) {
                    endGame('light', 'Dark ran out of time!');
                }
            } else {
                gameState.lightTime = Math.max(0, gameState.lightTime - elapsed);
                if (gameState.lightTime === 0) {
                    endGame('dark', 'Light ran out of time!');
                }
            }

            gameState.lastMoveTime = now;
            
            // Only render if displayed value has changed
            const darkDisplay = formatTime(gameState.darkTime);
            const lightDisplay = formatTime(gameState.lightTime);
            if (darkDisplay !== lastRenderedClockDisplay.dark || lightDisplay !== lastRenderedClockDisplay.light) {
                renderClocks();
            }
        }

        function renderClocks() {
            const darkClock = getEl('darkClock');
            const lightClock = getEl('lightClock');

            if (gameState.noTimeLimit) {
                darkClock.textContent = 'âˆž';
                lightClock.textContent = 'âˆž';
                darkClock.classList.remove('warning');
                lightClock.classList.remove('warning');
                lastRenderedClockDisplay.dark = 'âˆž';
                lastRenderedClockDisplay.light = 'âˆž';
            } else {
                const darkDisplay = formatTime(gameState.darkTime);
                const lightDisplay = formatTime(gameState.lightTime);
                darkClock.textContent = darkDisplay;
                lightClock.textContent = lightDisplay;
                darkClock.classList.toggle('warning', gameState.darkTime < 30);
                lightClock.classList.toggle('warning', gameState.lightTime < 30);
                lastRenderedClockDisplay.dark = darkDisplay;
                lastRenderedClockDisplay.light = lightDisplay;
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms}`;
        }

        function togglePause() {
            if (gameState.gameOver) return;
            
            gameState.isPaused = !gameState.isPaused;
            
            const pauseBtns = document.querySelectorAll('.pause-btn');
            pauseBtns.forEach(btn => {
                if (gameState.isPaused) {
                    btn.textContent = 'â–¶';
                    btn.classList.add('paused');
                    btn.title = 'Resume';
                } else {
                    btn.textContent = 'â¸';
                    btn.classList.remove('paused');
                    btn.title = 'Pause';
                }
            });
            
            if (!gameState.isPaused) {
                gameState.lastMoveTime = Date.now();
            }
        }

        // === RENDERING ===
        function renderGame() {
            renderBoard();
            renderGlyphs();
            renderSupply();
            renderPanels();
            
            // Update online indicator if in online mode
            if (onlineMode) {
                updateOnlineIndicator();
            }
        }

        // Board state tracking moved to renderBoard delta system
        
        // Track previous board state for delta rendering
        let previousBoardState = null;
        let boardInitialized = false;
        
        function initializeBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'dark' : 'light'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.id = `sq-${row}-${col}`;
                    
                    // Coordinates will be added/updated by updateCoordinates()
                    
                    boardEl.appendChild(square);
                }
            }
            
            // Add coordinates based on flip state
            updateCoordinates();
            
            // Attach event delegation ONCE
            boardEl.addEventListener('click', function(e) {
                const square = e.target.closest('.square');
                if (square && square.dataset.row !== undefined && square.dataset.col !== undefined) {
                    handleSquareClick(parseInt(square.dataset.row, 10), parseInt(square.dataset.col, 10));
                }
            });
            
            boardInitialized = true;
        }
        
        function renderBoard() {
            if (!boardInitialized) {
                initializeBoard();
            }
            
            // Cache getValidMoves result to avoid duplicate calls
            let cachedMoves = null;
            const getMoves = () => {
                if (cachedMoves === null && gameState.selectedPiece) {
                    cachedMoves = getValidMoves(gameState.selectedPiece.row, gameState.selectedPiece.col);
                }
                return cachedMoves || [];
            };
            
            const validMoves = (gameState.selectedPiece && gameState.selectedGlyph) ? getMoves() : [];

            // Get projected moves when piece selected but no glyph yet
            let projectedMoves = [];
            let blockedMoves = [];
            if (gameState.selectedPiece && !gameState.selectedGlyph) {
                const piece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const matchingGlyphs = hand.filter(glyph => glyphMatchesPiece(glyph, piece));
                
                const moves = getMoves();
                
                if (matchingGlyphs.length === 0) {
                    blockedMoves = moves;
                } else {
                    projectedMoves = moves;
                }
            }

            // Get reactivation targets
            let reactivationTargets = [];
            if (gameState.selectedMask !== null && gameState.selectedGlyph && !gameState.selectedPiece) {
                const player = gameState.currentPlayer;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = gameState.board[r][c];
                        if (p?.type === 'shadow' && p.player === player) {
                            reactivationTargets.push({ row: r, col: c });
                        }
                    }
                }
            } else if (gameState.selectedGlyph && !gameState.selectedPiece && gameState.selectedMask === null) {
                reactivationTargets = getReactivationTargets();
            }

            // Get selectable pieces
            const selectablePieces = [];
            if (gameState.selectedGlyph && !gameState.selectedPiece && gameState.selectedMask === null) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (canSelectPiece(r, c)) {
                            selectablePieces.push({ row: r, col: c });
                        }
                    }
                }
            }

            // Convert arrays to Sets for O(1) lookup instead of O(n) .some()
            const toKey = (r, c) => (r << 3) | c; // Fast key: row*8 + col using bit shift
            const validSet = new Set(validMoves.map(m => toKey(m.row, m.col)));
            const projectedSet = new Set(projectedMoves.map(m => toKey(m.row, m.col)));
            const blockedSet = new Set(blockedMoves.map(m => toKey(m.row, m.col)));
            const reactivateSet = new Set(reactivationTargets.map(t => toKey(t.row, t.col)));
            const selectableSet = new Set(selectablePieces.map(p => toKey(p.row, p.col)));

            // Build current state snapshot for comparison
            const currentState = [];
            for (let row = 0; row < 8; row++) {
                currentState[row] = [];
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    const key = toKey(row, col);
                    currentState[row][col] = {
                        piece: piece ? `${piece.type}-${piece.player}-${piece.shape || ''}-${piece.color || ''}` : null,
                        isValid: validSet.has(key),
                        isProjected: projectedSet.has(key),
                        isBlocked: blockedSet.has(key),
                        isReactivate: reactivateSet.has(key),
                        isSelectable: selectableSet.has(key),
                        isLastFrom: gameState.lastMove?.fromRow === row && gameState.lastMove?.fromCol === col,
                        isLastTo: gameState.lastMove?.toRow === row && gameState.lastMove?.toCol === col,
                        isSelected: gameState.selectedPiece?.row === row && gameState.selectedPiece?.col === col
                    };
                }
            }

            // Update only changed cells
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const curr = currentState[row][col];
                    const prev = previousBoardState?.[row]?.[col];
                    
                    // Skip if nothing changed
                    if (prev && 
                        prev.piece === curr.piece &&
                        prev.isValid === curr.isValid &&
                        prev.isProjected === curr.isProjected &&
                        prev.isBlocked === curr.isBlocked &&
                        prev.isReactivate === curr.isReactivate &&
                        prev.isSelectable === curr.isSelectable &&
                        prev.isLastFrom === curr.isLastFrom &&
                        prev.isLastTo === curr.isLastTo &&
                        prev.isSelected === curr.isSelected) {
                        continue;
                    }
                    
                    const square = document.getElementById(`sq-${row}-${col}`);
                    if (!square) continue;
                    
                    // Update highlight classes
                    square.classList.toggle('highlighted', curr.isValid);
                    square.classList.toggle('projected', curr.isProjected);
                    square.classList.toggle('blocked-move', curr.isBlocked);
                    square.classList.toggle('reactivate-target', curr.isReactivate);
                    square.classList.toggle('selectable', curr.isSelectable);
                    square.classList.toggle('last-move-from', curr.isLastFrom);
                    square.classList.toggle('last-move-to', curr.isLastTo);
                    
                    // Update piece only if changed
                    if (!prev || prev.piece !== curr.piece || prev.isSelected !== curr.isSelected) {
                        // Remove old piece (keep coordinates)
                        const oldPiece = square.querySelector('.piece, .shadow-piece');
                        if (oldPiece) oldPiece.remove();
                        
                        // Add new piece
                        const piece = gameState.board[row][col];
                        if (piece) {
                            square.appendChild(createPieceElement(piece, row, col));
                        }
                    }
                }
            }
            
            previousBoardState = currentState;
        }

        function createPieceElement(piece, row, col) {
            const el = document.createElement('div');

            if (piece.type === 'shadow') {
                el.className = `shadow-piece ${piece.player}-shadow`;
            } else {
                el.className = `piece ${piece.player}-golem`;
                
                const shapeEl = document.createElement('div');
                shapeEl.className = 'piece-shape';
                shapeEl.textContent = piece.shape;
                shapeEl.style.color = getColorValue(piece.color);
                el.appendChild(shapeEl);

                if (gameState.selectedPiece?.row === row && gameState.selectedPiece?.col === col) {
                    const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                    const hasMatchingGlyph = hand.some(glyph => glyphMatchesPiece(glyph, piece));
                    
                    if (hasMatchingGlyph) {
                        el.classList.add('selected');
                    } else {
                        el.classList.add('blocked');
                    }
                }
            }

            return el;
        }

        function getColorValue(color) {
            const map = {
                'white': 'var(--glyph-white)',
                'orange': 'var(--glyph-orange)',
                'blue': 'var(--glyph-blue)'
            };
            return map[color] || '#fff';
        }

        function renderGlyphs() {
            renderPlayerGlyphs('dark');
            renderPlayerGlyphs('light');
        }

        function renderPlayerGlyphs(player) {
            const handEl = getEl(`${player}Hand`);
            const restingEl = getEl(`${player}Resting`);
            const restingDesktopEl = getEl(`${player}RestingDesktop`);
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;

            handEl.innerHTML = '';
            restingEl.innerHTML = '';
            if (restingDesktopEl) restingDesktopEl.innerHTML = '';

            hand.forEach((glyph, index) => {
                handEl.appendChild(createGlyphElement(glyph, player, index, false));
            });

            if (resting) {
                restingEl.appendChild(createGlyphElement(resting, player, -1, true));
                if (restingDesktopEl) {
                    restingDesktopEl.appendChild(createGlyphElement(resting, player, -1, true));
                }
            }
        }

        function createGlyphElement(glyph, player, index, isResting) {
            const el = document.createElement('div');
            el.className = 'glyph';

            if (glyph.type === 'mirror') {
                el.classList.add('mirror');
                
                // Get the resting glyph to determine mirror appearance
                const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
                
                if (resting && !isResting) {
                    if (resting.type === 'color') {
                        // Show diamond filled with incoming color
                        const colorEl = document.createElement('div');
                        colorEl.className = 'mirror-color';
                        colorEl.style.background = getColorValue(resting.value);
                        el.appendChild(colorEl);
                    } else if (resting.type === 'shape') {
                        // Show silvery shape
                        const shapeEl = document.createElement('div');
                        shapeEl.className = 'mirror-shape';
                        shapeEl.textContent = resting.value;
                        el.appendChild(shapeEl);
                    } else {
                        // Resting is also a mirror - show default diamond
                        el.textContent = glyph.value;
                    }
                } else {
                    // No resting or is the resting glyph - show default
                    el.textContent = glyph.value;
                }
            } else if (glyph.type === 'shape') {
                const shapeEl = document.createElement('div');
                shapeEl.className = 'glyph-shape';
                shapeEl.textContent = glyph.value;
                el.appendChild(shapeEl);
            } else {
                // Color glyph - solid fill
                el.classList.add('color-glyph');
                el.style.background = getColorValue(glyph.value);
            }

            if (isResting) {
                el.classList.add('resting');
            } else if (player !== gameState.currentPlayer) {
                el.classList.add('disabled');
            } else {
                el.addEventListener('click', () => selectGlyph(player, index));
                if (gameState.selectedGlyph?.player === player && gameState.selectedGlyph?.index === index) {
                    el.classList.add('selected');
                }
                // Highlight valid glyphs in purple when a piece is selected but no glyph yet (choice required)
                if (gameState.selectedPiece && !gameState.selectedGlyph) {
                    const piece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                    if (piece && glyphMatchesPiece(glyph, piece)) {
                        el.classList.add('choice-required');
                    }
                    // Non-matching glyphs stay normal (clickable but not highlighted)
                }
                // Highlight valid glyphs when a mask is selected but no glyph yet
                if (gameState.selectedMask !== null && !gameState.selectedGlyph) {
                    const supply = gameState.currentPlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                    const mask = supply.masks[gameState.selectedMask];
                    const resting = gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
                    if (mask && resting && maskMatchesBothGlyphs(mask, glyph, resting)) {
                        el.classList.add('choice-required');
                    }
                }
            }

            return el;
        }

        function renderSupply() {
            renderShadowButton('dark');
            renderShadowButton('light');
            renderMasksDisplay('dark');
            renderMasksDisplay('light');
        }

        function renderShadowButton(player) {
            const btn = document.getElementById(`${player}ShadowBtn`);
            const countEl = document.getElementById(`${player}ShadowCount`);
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;

            countEl.textContent = supply.shadows;

            // Check if shadows are locked (Dark can't place until Light has)
            const isLocked = player === 'dark' && !gameState.lightHasPlacedShadow;
            const isCurrentPlayer = player === gameState.currentPlayer;
            const hasShadows = supply.shadows > 0;

            btn.classList.remove('locked', 'disabled', 'primed');

            if (isLocked) {
                btn.classList.add('locked');
            } else if (!isCurrentPlayer || !hasShadows) {
                btn.classList.add('disabled');
            } else if (gameState.shadowPrimed) {
                btn.classList.add('primed');
            }
        }

        function toggleShadowPrimed(player) {
            if (gameState.gameOver || gameState.isPaused) return;
            if (player !== gameState.currentPlayer) return;
            
            // In online mode, only allow on local player's turn
            if (onlineMode && !isLocalPlayerTurn()) return;

            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            if (supply.shadows === 0) return;

            // Check if locked
            if (player === 'dark' && !gameState.lightHasPlacedShadow) return;

            gameState.shadowPrimed = !gameState.shadowPrimed;
            renderSupply();
        }

        // Track scroll position per player
        const maskScrollPosition = { dark: 0, light: 0 };

        function renderMasksDisplay(player) {
            const container = document.getElementById(`${player}MasksDisplay`);
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            container.innerHTML = '';

            if (supply.masks.length === 0) return;

            // Check if player has any shadows on the board
            let hasShadows = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = gameState.board[r][c];
                    if (piece?.type === 'shadow' && piece.player === player) {
                        hasShadows = true;
                        break;
                    }
                }
                if (hasShadows) break;
            }

            // Find which masks are valid for reactivation
            const maskData = supply.masks.map((mask, index) => {
                const validGlyphIndices = [];
                if (player === gameState.currentPlayer && resting && hasShadows) {
                    hand.forEach((glyph, glyphIndex) => {
                        if (maskMatchesBothGlyphs(mask, glyph, resting)) {
                            validGlyphIndices.push(glyphIndex);
                        }
                    });
                }
                return { mask, index, validGlyphIndices, canReactivate: validGlyphIndices.length > 0 };
            });

            // Auto-scroll to first valid mask if any
            const firstValidIndex = maskData.findIndex(m => m.canReactivate);
            if (firstValidIndex !== -1 && player === gameState.currentPlayer) {
                // Scroll so the valid mask is visible (ideally first in view)
                maskScrollPosition[player] = Math.max(0, Math.min(firstValidIndex, supply.masks.length - 3));
            }

            // Clamp scroll position
            const maxScroll = Math.max(0, supply.masks.length - 3);
            maskScrollPosition[player] = Math.max(0, Math.min(maskScrollPosition[player], maxScroll));

            const needsScroll = supply.masks.length > 3;
            const scrollPos = maskScrollPosition[player];

            // Build scroller UI
            const scroller = document.createElement('div');
            scroller.className = 'masks-scroller';

            // Left arrow
            if (needsScroll) {
                const leftBtn = document.createElement('button');
                leftBtn.className = 'masks-scroll-btn';
                leftBtn.textContent = 'â—€';
                leftBtn.disabled = scrollPos === 0;
                leftBtn.onclick = (e) => {
                    e.stopPropagation();
                    maskScrollPosition[player] = Math.max(0, scrollPos - 1);
                    renderMasksDisplay(player);
                };
                scroller.appendChild(leftBtn);
            }

            // Viewport showing up to 3 masks
            const viewport = document.createElement('div');
            viewport.className = 'masks-viewport';

            const visibleMasks = maskData.slice(scrollPos, scrollPos + 3);
            visibleMasks.forEach(({ mask, index, validGlyphIndices, canReactivate }) => {
                const el = document.createElement('div');
                el.className = `mask-piece ${player}-mask`;
                el.textContent = mask.shape;
                el.style.color = getColorValue(mask.color);

                if (canReactivate) {
                    el.classList.add('available');
                    el.addEventListener('click', () => selectMaskForReactivation(index, validGlyphIndices));
                    
                    if (gameState.selectedMask === index) {
                        el.classList.add('selected');
                    }
                } else {
                    el.classList.add('dimmed');
                }

                viewport.appendChild(el);
            });

            scroller.appendChild(viewport);

            // Right arrow
            if (needsScroll) {
                const rightBtn = document.createElement('button');
                rightBtn.className = 'masks-scroll-btn';
                rightBtn.textContent = 'â–¶';
                rightBtn.disabled = scrollPos >= maxScroll;
                rightBtn.onclick = (e) => {
                    e.stopPropagation();
                    maskScrollPosition[player] = Math.min(maxScroll, scrollPos + 1);
                    renderMasksDisplay(player);
                };
                scroller.appendChild(rightBtn);
            }

            container.appendChild(scroller);
        }

        function renderPanels() {
            getEl('darkPanel').classList.toggle('active', gameState.currentPlayer === 'dark');
            getEl('lightPanel').classList.toggle('active', gameState.currentPlayer === 'light');
            
            // Update lives display - only show when using extra lives (lives > 1, not sudden death)
            const showLives = gameState.darkLives > 1 || gameState.lightLives > 1;
            
            const darkLivesEl = getEl('darkLives');
            const lightLivesEl = getEl('lightLives');
            
            darkLivesEl.classList.toggle('visible', showLives);
            lightLivesEl.classList.toggle('visible', showLives);
            
            if (showLives) {
                darkLivesEl.innerHTML = `<span style="color: #e74c3c;">â™¥</span> ${gameState.darkLives}`;
                lightLivesEl.innerHTML = `<span style="color: #e74c3c;">â™¥</span> ${gameState.lightLives}`;
            }
        }

        // === GAME LOGIC ===
        function selectGlyph(player, index) {
            if (gameState.gameOver || gameState.isPaused || player !== gameState.currentPlayer) return;
            
            // In online mode, only allow moves on local player's turn
            if (onlineMode && !isLocalPlayerTurn()) return;

            // If a mask is selected, check if this glyph is valid for reactivation
            if (gameState.selectedMask !== null) {
                const supply = gameState.currentPlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                const mask = supply.masks[gameState.selectedMask];
                const resting = gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const glyph = hand[index];
                
                if (mask && resting && maskMatchesBothGlyphs(mask, glyph, resting)) {
                    // Valid glyph for this mask - select it (keep mask selected)
                    gameState.selectedGlyph = { player, index };
                    
                    // Tutorial objective
                    if (tutorialMode) completeTutorialObjective('select-glyph');
                    
                    renderGame();
                    return;
                }
                // Invalid glyph for this mask - ignore
                return;
            }

            // Normal glyph selection (no mask selected)
            // Toggle off if clicking same glyph
            if (gameState.selectedGlyph?.player === player && gameState.selectedGlyph?.index === index) {
                gameState.selectedGlyph = null;
                gameState.selectedPiece = null;
            } else {
                // Select this glyph
                gameState.selectedGlyph = { player, index };
                
                // Tutorial objective
                if (tutorialMode) completeTutorialObjective('select-glyph');
                
                // If a piece was selected, check if it still matches
                if (gameState.selectedPiece) {
                    const piece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                    const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                    const glyph = hand[index];
                    
                    if (!glyphMatchesPiece(glyph, piece)) {
                        // Piece doesn't match new glyph, deselect piece
                        gameState.selectedPiece = null;
                    }
                    // If piece matches, the squares will now show as green (valid moves)
                    // and player can click to complete the move
                }
            }

            renderGame();
        }

        function selectMaskForReactivation(maskIndex, validGlyphIndices) {
            if (gameState.gameOver || gameState.isPaused) return;
            
            // In online mode, only allow on local player's turn
            if (onlineMode && !isLocalPlayerTurn()) return;

            // Toggle off if clicking same mask
            if (gameState.selectedMask === maskIndex) {
                gameState.selectedMask = null;
                gameState.selectedGlyph = null;
                renderGame();
                return;
            }

            // Clear piece selection, we're doing reactivation
            gameState.selectedPiece = null;
            gameState.selectedMask = maskIndex;

            // If only one glyph works, auto-select it
            if (validGlyphIndices.length === 1) {
                gameState.selectedGlyph = { player: gameState.currentPlayer, index: validGlyphIndices[0] };
            } else {
                // Multiple glyphs work - clear glyph selection, user must choose
                gameState.selectedGlyph = null;
            }

            renderGame();
        }

        // Check if a glyph can move a specific piece
        function glyphMatchesPiece(glyph, piece) {
            if (glyph.type === 'mirror') {
                const resting = gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
                if (!resting) return false;
                return matchesGlyph(piece, resting);
            }
            return matchesGlyph(piece, glyph);
        }

        function flashChoiceRequiredGlyphs() {
            const glyphs = document.querySelectorAll('.glyph.choice-required');
            glyphs.forEach(glyph => {
                glyph.classList.remove('flash');
                // Force reflow to restart animation
                void glyph.offsetWidth;
                glyph.classList.add('flash');
            });
        }

        function handleSquareClick(row, col) {
            if (gameState.gameOver || gameState.isPaused) return;
            
            // In online mode, only allow moves on local player's turn
            if (onlineMode && !isLocalPlayerTurn()) return;

            const piece = gameState.board[row][col];

            // Check for reactivation on shadow (mask selected + glyph selected)
            if (piece?.type === 'shadow' && piece.player === gameState.currentPlayer && 
                gameState.selectedMask !== null && gameState.selectedGlyph) {
                executeReactivation(row, col, gameState.selectedMask);
                return;
            }

            // Legacy: Check for reactivation on shadow (glyph selected, find matching mask)
            if (piece?.type === 'shadow' && piece.player === gameState.currentPlayer && 
                gameState.selectedGlyph && gameState.selectedMask === null) {
                const targets = getReactivationTargets();
                const target = targets.find(t => t.row === row && t.col === col);
                if (target) {
                    executeReactivation(row, col, target.maskIndex);
                    return;
                }
            }

            // Moving to valid square
            if (gameState.selectedPiece && gameState.selectedGlyph) {
                const validMoves = getValidMoves(gameState.selectedPiece.row, gameState.selectedPiece.col);
                if (validMoves.some(m => m.row === row && m.col === col)) {
                    saveState();
                    movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
                    return;
                }
            }

            // Clicking a projected square (piece selected but no glyph) - flash the choice-required glyphs
            if (gameState.selectedPiece && !gameState.selectedGlyph) {
                const piece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const matchingGlyphs = hand.filter(glyph => glyphMatchesPiece(glyph, piece));
                
                // Only flash if there are matching glyphs (choice required, not blocked)
                if (matchingGlyphs.length > 0) {
                    const projectedMoves = getValidMoves(gameState.selectedPiece.row, gameState.selectedPiece.col);
                    if (projectedMoves.some(m => m.row === row && m.col === col)) {
                        flashChoiceRequiredGlyphs();
                        return;
                    }
                }
            }

            // Selecting a piece (with or without glyph selected)
            if (piece?.type === 'golem' && piece.player === gameState.currentPlayer) {
                // Clear mask selection when selecting a piece
                gameState.selectedMask = null;
                
                // Toggle off if clicking same piece
                if (gameState.selectedPiece?.row === row && gameState.selectedPiece?.col === col) {
                    gameState.selectedPiece = null;
                    gameState.selectedGlyph = null;
                    renderGame();
                    return;
                }
                
                // Select this piece
                gameState.selectedPiece = { row, col };
                
                // Tutorial objective - track golem selections for Glyphs capsule
                if (tutorialMode && tutorialCurrentCapsule === 4) {
                    checkGlyphTutorialGolemSelection(row, col);
                }
                
                // If glyph already selected, check if this piece matches it
                if (gameState.selectedGlyph) {
                    if (!canSelectPiece(row, col)) {
                        // Piece doesn't match current glyph, deselect glyph
                        gameState.selectedGlyph = null;
                    }
                }
                
                // If no glyph selected (or was just deselected), check for auto-select
                if (!gameState.selectedGlyph) {
                    const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                    const matchingGlyphs = [];
                    hand.forEach((glyph, index) => {
                        if (glyphMatchesPiece(glyph, piece)) {
                            matchingGlyphs.push(index);
                        }
                    });
                    
                    // If exactly one glyph matches, auto-select it
                    if (matchingGlyphs.length === 1) {
                        gameState.selectedGlyph = { player: gameState.currentPlayer, index: matchingGlyphs[0] };
                        
                        // Tutorial objective - auto-selected glyph counts
                        if (tutorialMode) completeTutorialObjective('select-glyph');
                    }
                }
                
                renderGame();
            }
        }

        function canSelectPiece(row, col) {
            if (!gameState.selectedGlyph) return false;

            const piece = gameState.board[row][col];
            if (!piece || piece.type !== 'golem' || piece.player !== gameState.currentPlayer) return false;

            const glyph = getCurrentGlyph();

            if (glyph.type === 'mirror') {
                const resting = getOpponentResting();
                if (!resting) return false;
                return matchesGlyph(piece, resting);
            }

            return matchesGlyph(piece, glyph);
        }

        function getCurrentGlyph() {
            const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
            return hand[gameState.selectedGlyph.index];
        }

        function getOpponentResting() {
            return gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
        }

        function matchesGlyph(piece, glyph) {
            if (glyph.type === 'shape') return piece.shape === glyph.value;
            if (glyph.type === 'color') return piece.color === glyph.value;
            return false;
        }

        // === MOVEMENT ===
        function getValidMoves(row, col) {
            const moves = [];
            const piece = gameState.board[row][col];
            if (!piece || piece.type !== 'golem') return moves;

            // Orthogonal steps (2 spaces) - blocked only by OPPONENT pieces in the middle
            const orthDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dr, dc] of orthDirs) {
                const midRow = row + dr;
                const midCol = col + dc;
                const newRow = row + 2 * dr;
                const newCol = col + 2 * dc;

                if (isValidPos(newRow, newCol) && !gameState.board[newRow][newCol]) {
                    const midPiece = gameState.board[midRow][midCol];
                    // Can move if middle is empty OR middle has own piece (not blocked by own pieces)
                    // Blocked only by opponent pieces
                    if (!midPiece || midPiece.player === piece.player) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }

            // Diagonal steps (1 space) - cannot be hindered
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dr, dc] of diagDirs) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPos(newRow, newCol) && !gameState.board[newRow][newCol]) {
                    moves.push({ row: newRow, col: newCol });
                }
            }

            // Diagonal jumps - must jump over at least one own piece
            const jumps = getDiagonalJumps(row, col, piece.player, new Set([`${row},${col}`]), row, col);
            moves.push(...jumps);

            // Remove duplicates
            const seen = new Set();
            return moves.filter(m => {
                const key = `${m.row},${m.col}`;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        function getDiagonalJumps(row, col, player, visited, origRow, origCol) {
            const jumps = [];
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

            for (const [dr, dc] of diagDirs) {
                // First square must be an own piece (golem or shadow) to start a jump
                const firstRow = row + dr;
                const firstCol = col + dc;
                
                if (!isValidPos(firstRow, firstCol)) continue;
                
                // The original piece's position is empty (piece is moving) - can't jump over empty
                if (firstRow === origRow && firstCol === origCol) continue;
                
                const firstPiece = gameState.board[firstRow][firstCol];
                
                // Must be own piece - golem or shadow (not empty, not opponent)
                if (!firstPiece || firstPiece.player !== player) continue;
                
                // We have an adjacent own piece - now continue jumping over contiguous own pieces
                let checkRow = firstRow + dr;
                let checkCol = firstCol + dc;
                
                while (isValidPos(checkRow, checkCol)) {
                    // The original piece's position is effectively empty - treat as landing spot or blocker
                    if (checkRow === origRow && checkCol === origCol) {
                        // Can't land on original position (already visited), and can't jump "through" it
                        // since it's empty. Break here.
                        break;
                    }
                    
                    const checkPiece = gameState.board[checkRow][checkCol];
                    
                    if (!checkPiece) {
                        // Empty square - valid landing spot
                        const key = `${checkRow},${checkCol}`;
                        if (!visited.has(key)) {
                            jumps.push({ row: checkRow, col: checkCol });
                            visited.add(key);
                            // Chain jumps from this position
                            const chainJumps = getDiagonalJumps(checkRow, checkCol, player, visited, origRow, origCol);
                            jumps.push(...chainJumps);
                        }
                        break;
                    } else if (checkPiece.player === player) {
                        // Another own piece (golem or shadow) - continue over it
                        checkRow += dr;
                        checkCol += dc;
                    } else {
                        // Opponent piece - blocked, cannot jump over
                        break;
                    }
                }
            }

            return jumps;
        }

        function isValidPos(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const player = gameState.currentPlayer;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const glyphUsed = hand[gameState.selectedGlyph.index];
            
            // Prepare move data for analysis
            const moveData = {
                player,
                type: 'movement',
                piece: { shape: piece.shape, color: piece.color },
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                glyphUsed: { ...glyphUsed },
                shadowPlaced: null,
                captures: []
            };
            
            // Check tutorial objectives BEFORE moving
            if (tutorialMode) {
                checkTutorialMoveObjective(fromRow, fromCol, toRow, toCol);
                
                // Detect if this is a diagonal jump (moved more than 1 square diagonally)
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                // Only check for jumps if it's a diagonal move (both row and col changed)
                // Orthogonal steps (rowDiff=0 or colDiff=0) are not jumps
                if (rowDiff > 0 && colDiff > 0 && (rowDiff >= 2 || colDiff >= 2)) {
                    let piecesJumped = 0;
                    let emptySquares = 0;
                    
                    // Only count straight-line pieces if it's a straight diagonal
                    if (rowDiff === colDiff && rowDiff >= 2) {
                        const dr = toRow > fromRow ? 1 : -1;
                        const dc = toCol > fromCol ? 1 : -1;
                        let checkR = fromRow + dr;
                        let checkC = fromCol + dc;
                        while (checkR !== toRow && checkC !== toCol) {
                            if (gameState.board[checkR][checkC]) {
                                piecesJumped++;
                            } else {
                                emptySquares++;
                            }
                            checkR += dr;
                            checkC += dc;
                        }
                    } else {
                        // Non-straight diagonal path = chain jump (direction changed)
                        emptySquares = 1; // Treat as having gaps to trigger chain jump detection
                    }
                    
                    // Track for tutorial objectives
                    const squaresTraveled = Math.max(rowDiff, colDiff);
                    checkTutorialJumpObjective(fromRow, fromCol, toRow, toCol, piecesJumped, emptySquares, squaresTraveled);
                }
            }
            
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;

            gameState.lastMove = { fromRow, fromCol, toRow, toCol };

            // Check for breakthrough - dark wins by reaching row 0, light by reaching row 7
            const isBreakthrough = (piece.player === 'dark' && toRow === 0) || 
                                   (piece.player === 'light' && toRow === 7);
            
            if (isBreakthrough) {
                // Handle captures FIRST (scoring golem still participates)
                const captures = handleCaptures(toRow, toCol, piece);
                moveData.captures = captures;
                
                if (tutorialMode) {
                    recordMove(moveData);
                    completeTutorialObjective('reach-goal');
                    return;
                }
                
                // Check opponent's lives
                const opponent = piece.player === 'dark' ? 'light' : 'dark';
                
                // Decrement opponent's lives
                if (opponent === 'dark') {
                    gameState.darkLives--;
                } else {
                    gameState.lightLives--;
                }
                
                const remainingLives = opponent === 'dark' ? gameState.darkLives : gameState.lightLives;
                
                // If opponent has no lives left, immediate win
                if (remainingLives <= 0) {
                    recordMove(moveData);
                    endGame(piece.player);
                    return;
                }
                
                // Dismantle scoring golem back to scorer's supply as mask + shadow
                gameState.board[toRow][toCol] = null;
                const supply = piece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                supply.masks.push({ shape: piece.shape, color: piece.color });
                supply.shadows++;
                
                // Place shadow on origin square if primed (before checking game end)
                const canPlaceShadow = supply.shadows > 0 && 
                    (piece.player === 'light' || gameState.lightHasPlacedShadow);
                if (canPlaceShadow && gameState.shadowPrimed) {
                    placeShadow(fromRow, fromCol, piece.player);
                    moveData.shadowPlaced = { row: fromRow, col: fromCol };
                }
                gameState.shadowPrimed = false;
                
                // Record move data for breakthrough
                moveData.breakthrough = true;
                moveData.dismantled = { shape: piece.shape, color: piece.color };
                recordMove(moveData);
                
                // Send move to opponent in online mode
                if (onlineMode && isLocalPlayerTurn()) {
                    sendOnlineMessage({
                        type: 'move',
                        move: moveData
                    });
                }
                
                // Game continues - show breakthrough notification
                showBreakthroughNotification(piece.player, remainingLives);
                
                completeTurn();
                return;
            }

            // Handle captures (and collect capture data)
            const captures = handleCaptures(toRow, toCol, piece);
            moveData.captures = captures;
            
            // Check tutorial capture objectives
            if (tutorialMode && captures.length > 0) {
                checkTutorialCaptureObjective(captures.length);
            }
            
            // Check tutorial safe move objective (moved between enemies without being captured)
            if (tutorialMode && captures.length === 0) {
                checkTutorialSafeMoveObjective(toRow, toCol);
            }

            // Place shadow if primed
            const supply = piece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            const canPlaceShadow = supply.shadows > 0 && 
                (piece.player === 'light' || gameState.lightHasPlacedShadow);

            if (canPlaceShadow && gameState.shadowPrimed) {
                placeShadow(fromRow, fromCol, piece.player);
                moveData.shadowPlaced = { row: fromRow, col: fromCol };
                
                // Check tutorial shadow objective
                if (tutorialMode) {
                    checkTutorialShadowObjective();
                }
            }

            // Reset shadow primed state
            gameState.shadowPrimed = false;

            // Record the move for analysis
            recordMove(moveData);
            
            // Send move to opponent in online mode
            if (onlineMode && isLocalPlayerTurn()) {
                sendOnlineMessage({
                    type: 'move',
                    move: moveData
                });
            }

            completeTurn();
        }

        function placeShadow(row, col, player) {
            if (gameState.board[row][col]) {
                return; // Square occupied (shouldn't happen but safety check)
            }

            gameState.board[row][col] = { type: 'shadow', player };
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            supply.shadows--;

            if (player === 'light') {
                gameState.lightHasPlacedShadow = true;
            }
        }

        // === CAPTURES ===
        function handleCaptures(row, col, movingPiece) {
            const directions = [
                [[0, -1], [0, 1]],   // horizontal
                [[-1, 0], [1, 0]]    // vertical
            ];

            const capturedShadowOwners = new Set();
            const captures = []; // Track captures for analysis

            for (const [dir1, dir2] of directions) {
                // Check both directions
                for (const dir of [dir1, dir2]) {
                    const enemyRow = row + dir[0];
                    const enemyCol = col + dir[1];
                    const supportRow = row + dir[0] * 2;
                    const supportCol = col + dir[1] * 2;

                    if (!isValidPos(enemyRow, enemyCol) || !isValidPos(supportRow, supportCol)) continue;

                    const enemyPiece = gameState.board[enemyRow][enemyCol];
                    const supportPiece = gameState.board[supportRow][supportCol];

                    if (!enemyPiece || !supportPiece) continue;
                    if (enemyPiece.player === movingPiece.player) continue;
                    if (supportPiece.player !== movingPiece.player) continue;

                    // Check if capture is valid
                    if (canCapture(movingPiece, enemyPiece)) {
                        // Record capture data before removing
                        captures.push({
                            piece: enemyPiece.type === 'shadow' 
                                ? { type: 'shadow', player: enemyPiece.player }
                                : { shape: enemyPiece.shape, color: enemyPiece.color },
                            position: { row: enemyRow, col: enemyCol }
                        });
                        capturePiece(enemyRow, enemyCol, enemyPiece, capturedShadowOwners);
                    }
                }
            }

            // Remove all shadows of captured shadow owners (shadow cascade)
            for (const owner of capturedShadowOwners) {
                removeAllShadows(owner);
                // Mark that a shadow cascade occurred
                captures.forEach(c => {
                    if (c.piece.type === 'shadow' && c.piece.player === owner) {
                        c.shadowCascade = true;
                    }
                });
            }
            
            return captures;
        }

        function canCapture(movingPiece, targetPiece) {
            if (targetPiece.type === 'shadow') return true;
            if (movingPiece.shape === targetPiece.shape) return false;
            if (movingPiece.color === targetPiece.color) return false;
            return true;
        }

        function capturePiece(row, col, piece, capturedShadowOwners) {
            gameState.board[row][col] = null;
            const supply = piece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;

            if (piece.type === 'shadow') {
                capturedShadowOwners.add(piece.player);
                supply.shadows++; // Return the captured shadow to supply
            } else {
                supply.shadows++;
                supply.masks.push({ shape: piece.shape, color: piece.color });
            }
        }

        function removeAllShadows(player) {
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'shadow' && piece.player === player) {
                        gameState.board[row][col] = null;
                        supply.shadows++;
                    }
                }
            }
        }

        // === REACTIVATION ===
        function getReactivationTargets() {
            if (!gameState.selectedGlyph) return [];

            const player = gameState.currentPlayer;
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;

            if (!resting || supply.masks.length === 0) return [];

            const targets = [];
            const activeGlyph = getCurrentGlyph();

            // Find all shadows
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'shadow' && piece.player === player) {
                        // Check if any mask matches both glyphs
                        supply.masks.forEach((mask, maskIndex) => {
                            if (maskMatchesBothGlyphs(mask, activeGlyph, resting)) {
                                targets.push({ row, col, maskIndex });
                            }
                        });
                    }
                }
            }

            return targets;
        }

        function maskMatchesBothGlyphs(mask, activeGlyph, restingGlyph) {
            const matchActive = glyphMatchesMask(activeGlyph, mask, restingGlyph);
            const matchResting = glyphMatchesMask(restingGlyph, mask, activeGlyph);
            return matchActive && matchResting;
        }

        function glyphMatchesMask(glyph, mask, otherGlyph) {
            if (glyph.type === 'mirror') {
                // Mirror copies the other glyph
                return glyphMatchesMask(otherGlyph, mask, null);
            }
            if (glyph.type === 'shape') return mask.shape === glyph.value;
            if (glyph.type === 'color') return mask.color === glyph.value;
            return false;
        }

        function maskMatchesGlyphs(mask, glyphIndex) {
            const player = gameState.currentPlayer;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            const activeGlyph = hand[glyphIndex];

            if (!resting) return false;
            return maskMatchesBothGlyphs(mask, activeGlyph, resting);
        }

        function executeReactivation(row, col, maskIndex) {
            saveState();

            const player = gameState.currentPlayer;
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const mask = supply.masks[maskIndex];
            const glyphUsed = hand[gameState.selectedGlyph.index];

            // Prepare move data for analysis
            const moveData = {
                player,
                type: 'reactivation',
                mask: { shape: mask.shape, color: mask.color },
                position: { row, col },
                glyphUsed: { ...glyphUsed },
                captures: []
            };

            // Remove shadow and place golem
            gameState.board[row][col] = {
                type: 'golem',
                player,
                shape: mask.shape,
                color: mask.color
            };

            supply.masks.splice(maskIndex, 1);

            gameState.lastMove = { fromRow: row, fromCol: col, toRow: row, toCol: col };

            // Handle captures from reactivation
            const captures = handleCaptures(row, col, gameState.board[row][col]);
            moveData.captures = captures;

            // Record the move for analysis
            recordMove(moveData);
            
            // Send move to opponent in online mode
            if (onlineMode && isLocalPlayerTurn()) {
                sendOnlineMessage({
                    type: 'move',
                    move: moveData
                });
            }

            // Check tutorial reactivation objective
            if (tutorialMode && tutorialCurrentCapsule === 14) {
                completeTutorialObjective('reactivate');
            }
            
            // Check tutorial reactivation capture objective
            if (tutorialMode && tutorialCurrentCapsule === 15 && captures.length > 0) {
                completeTutorialObjective('reactivate-capture');
            }

            completeTurn();
        }

        // === TURN MANAGEMENT ===
        function completeTurn() {
            const player = gameState.currentPlayer;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const usedGlyph = hand.splice(gameState.selectedGlyph.index, 1)[0];

            // Add increment to the player who just moved (before switching)
            if (!gameState.noTimeLimit && gameState.increment > 0) {
                if (player === 'dark') {
                    gameState.darkTime += gameState.increment;
                } else {
                    gameState.lightTime += gameState.increment;
                }
            }

            // Pick up resting glyph
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            if (resting) {
                hand.push(resting);
            }

            // Tutorial mode: keep it Dark's turn, simulate glyph exchange
            if (tutorialMode) {
                // In tutorial, we simulate Light's turn:
                // 1. The glyph Dark just used (usedGlyph) goes to Light as their resting
                // 2. Light "uses" a random glyph from their hand (becomes Dark's new resting)
                // 3. Light picks up their resting (the glyph Dark just used)
                
                // Determine which glyphs Light currently has (all glyphs not in Dark's hand or Dark's resting)
                const allGlyphs = [
                    { type: 'shape', value: 'Î›' },
                    { type: 'shape', value: 'Î§' },
                    { type: 'shape', value: 'Î©' },
                    { type: 'color', value: 'white' },
                    { type: 'color', value: 'blue' },
                    { type: 'color', value: 'orange' },
                    { type: 'mirror', value: 'â—‡' }
                ];
                
                // Find glyphs not in Dark's hand and not Dark's current resting
                const darkHandKeys = gameState.darkHand.map(g => g.type + ':' + g.value);
                const darkRestingKey = gameState.darkResting ? gameState.darkResting.type + ':' + gameState.darkResting.value : null;
                const lightGlyphs = allGlyphs.filter(g => {
                    const key = g.type + ':' + g.value;
                    return !darkHandKeys.includes(key) && key !== darkRestingKey;
                });
                
                // Light "uses" a random glyph from their hand, which becomes Dark's new resting
                if (lightGlyphs.length > 0) {
                    const randomIndex = Math.floor(Math.random() * lightGlyphs.length);
                    gameState.darkResting = JSON.parse(JSON.stringify(lightGlyphs[randomIndex]));
                }
                
                gameState.currentPlayer = 'dark'; // Stay as Dark
                
                gameState.selectedGlyph = null;
                gameState.selectedPiece = null;
                gameState.selectedMask = null;
                gameState.lastMoveTime = Date.now();

                renderGame();
                return;
            }

            // Normal game: Set opponent's resting and switch players
            if (player === 'dark') {
                gameState.lightResting = usedGlyph;
                gameState.darkResting = null;
                gameState.currentPlayer = 'light';
            } else {
                gameState.darkResting = usedGlyph;
                gameState.lightResting = null;
                gameState.currentPlayer = 'dark';
            }

            gameState.selectedGlyph = null;
            gameState.selectedPiece = null;
            gameState.selectedMask = null;
            gameState.lastMoveTime = Date.now();

            renderGame();

            // Check for draw (no valid actions)
            if (!hasValidActions(gameState.currentPlayer)) {
                endGame('draw', 'Draw - no valid moves available!');
            }
            
            // Trigger CPU move if it's CPU's turn
            triggerCpuMoveIfNeeded();
        }

        function hasValidActions(player) {
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;

            for (let i = 0; i < hand.length; i++) {
                const glyph = hand[i];
                const effectiveGlyph = glyph.type === 'mirror' ? resting : glyph;

                if (!effectiveGlyph) continue;

                // Check if any golem can move with this glyph
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = gameState.board[row][col];
                        if (piece?.type === 'golem' && piece.player === player) {
                            if (matchesGlyph(piece, effectiveGlyph)) {
                                if (getValidMoves(row, col).length > 0) return true;
                            }
                        }
                    }
                }

                // Check for reactivation with this glyph
                if (resting) {
                    const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                    for (const mask of supply.masks) {
                        if (maskMatchesBothGlyphs(mask, glyph, resting)) {
                            // Check if there's a shadow to reactivate on
                            for (let row = 0; row < 8; row++) {
                                for (let col = 0; col < 8; col++) {
                                    const piece = gameState.board[row][col];
                                    if (piece?.type === 'shadow' && piece.player === player) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return false;
        }

        // === CPU PLAYER (V3 Heuristic) ===
        
        function getCpuLegalMoves(player) {
            const moves = [];
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            
            // Shadow lock: Dark can only place shadows if Light has placed one
            const canPlaceShadow = supply.shadows > 0 && 
                (player === 'light' || gameState.lightHasPlacedShadow);

            for (let glyphIndex = 0; glyphIndex < hand.length; glyphIndex++) {
                const glyph = hand[glyphIndex];
                const effectiveGlyph = glyph.type === 'mirror' ? resting : glyph;
                if (!effectiveGlyph) continue;

                // Movement moves
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = gameState.board[row][col];
                        if (piece?.type === 'golem' && piece.player === player) {
                            if (matchesGlyph(piece, effectiveGlyph)) {
                                const destinations = getValidMoves(row, col);
                                for (const dest of destinations) {
                                    moves.push({
                                        type: 'movement',
                                        glyphIndex,
                                        from: { row, col },
                                        to: dest,
                                        placeShadow: false
                                    });
                                    if (canPlaceShadow) {
                                        moves.push({
                                            type: 'movement',
                                            glyphIndex,
                                            from: { row, col },
                                            to: dest,
                                            placeShadow: true
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                // Reactivation moves
                if (resting && supply.masks.length > 0) {
                    for (let maskIndex = 0; maskIndex < supply.masks.length; maskIndex++) {
                        const mask = supply.masks[maskIndex];
                        if (maskMatchesBothGlyphs(mask, glyph, resting)) {
                            for (let row = 0; row < 8; row++) {
                                for (let col = 0; col < 8; col++) {
                                    const piece = gameState.board[row][col];
                                    if (piece?.type === 'shadow' && piece.player === player) {
                                        moves.push({
                                            type: 'reactivation',
                                            glyphIndex,
                                            maskIndex,
                                            position: { row, col }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return moves;
        }

        function cpuPredictCaptures(move, player) {
            if (move.type === 'reactivation') return 0;
            
            const toRow = move.to.row;
            const toCol = move.to.col;
            const movingPiece = gameState.board[move.from.row][move.from.col];
            let captures = 0;
            
            const directions = [
                [[0, -1], [0, 1]],
                [[-1, 0], [1, 0]]
            ];
            
            for (const [dir1, dir2] of directions) {
                for (const dir of [dir1, dir2]) {
                    const enemyRow = toRow + dir[0];
                    const enemyCol = toCol + dir[1];
                    const supportRow = toRow + dir[0] * 2;
                    const supportCol = toCol + dir[1] * 2;
                    
                    if (!isValidPos(enemyRow, enemyCol) || !isValidPos(supportRow, supportCol)) continue;
                    
                    const enemyPiece = gameState.board[enemyRow][enemyCol];
                    const supportPiece = gameState.board[supportRow][supportCol];
                    
                    if (!enemyPiece || !supportPiece) continue;
                    if (enemyPiece.player === player) continue;
                    if (supportPiece.player !== player) continue;
                    
                    if (canCapture(movingPiece, enemyPiece)) {
                        captures++;
                    }
                }
            }
            
            return captures;
        }

        function cpuFindBlockingMoves(moves, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const opponentGoalRow = player === 'dark' ? 7 : 0;
            const blocking = [];
            
            // Find opponent pieces that can win next turn
            const threats = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'golem' && piece.player === opponent) {
                        const pieceMoves = getValidMoves(row, col);
                        for (const dest of pieceMoves) {
                            if (dest.row === opponentGoalRow) {
                                threats.push({ from: { row, col }, to: dest, piece });
                            }
                        }
                    }
                }
            }
            
            if (threats.length === 0) return [];
            
            for (const move of moves) {
                if (move.type !== 'movement') continue;
                
                for (const threat of threats) {
                    // Can we capture the threatening piece?
                    if (move.to.row === threat.from.row && move.to.col === threat.from.col) {
                        const movingPiece = gameState.board[move.from.row][move.from.col];
                        if (canCapture(movingPiece, threat.piece)) {
                            blocking.push(move);
                        }
                    }
                    // Can we block the destination?
                    if (move.to.row === threat.to.row && move.to.col === threat.to.col) {
                        blocking.push(move);
                    }
                }
            }
            
            return blocking;
        }

        function cpuMoveExposesToCapture(move) {
            if (move.type !== 'movement') return false;
            
            const player = gameState.currentPlayer;
            const opponent = player === 'dark' ? 'light' : 'dark';
            const destRow = move.to.row;
            const destCol = move.to.col;
            
            const directions = [
                [[-1, 0], [1, 0]],
                [[0, -1], [0, 1]]
            ];
            
            for (const [d1, d2] of directions) {
                const pos1 = { row: destRow + d1[0], col: destCol + d1[1] };
                const pos2 = { row: destRow + d2[0], col: destCol + d2[1] };
                
                if (!isValidPos(pos1.row, pos1.col) || !isValidPos(pos2.row, pos2.col)) continue;
                
                const piece1 = gameState.board[pos1.row][pos1.col];
                const piece2 = gameState.board[pos2.row][pos2.col];
                
                if (piece1?.player === opponent && piece2?.player === opponent) {
                    return true;
                }
            }
            
            return false;
        }

        function cpuHasOtherGlyphForPiece(piece, usedGlyphIndex, player) {
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            
            for (let i = 0; i < hand.length; i++) {
                if (i === usedGlyphIndex) continue;
                
                const glyph = hand[i];
                const effectiveGlyph = glyph.type === 'mirror' ? resting : glyph;
                if (!effectiveGlyph) continue;
                
                if (matchesGlyph(piece, effectiveGlyph)) {
                    return true;
                }
            }
            return false;
        }

        // Evaluate shadow placement as an offensive launchpad
        function cpuEvaluateShadowLaunchpad(shadowPos, player) {
            const goalRow = player === 'dark' ? 0 : 7;
            const direction = player === 'dark' ? -1 : 1;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            
            let launchpadScore = 0;
            
            // Check all 4 diagonal directions - who can jump OVER this shadow?
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for (const [dr, dc] of diagDirs) {
                // Piece that would jump is at shadowPos - (dr, dc)
                const jumperRow = shadowPos.row - dr;
                const jumperCol = shadowPos.col - dc;
                // Landing spot is at shadowPos + (dr, dc)
                const landRow = shadowPos.row + dr;
                const landCol = shadowPos.col + dc;
                
                if (!isValidPos(jumperRow, jumperCol) || !isValidPos(landRow, landCol)) continue;
                
                const jumper = gameState.board[jumperRow][jumperCol];
                const landing = gameState.board[landRow][landCol];
                
                // Need: friendly golem at jumper pos, empty landing, landing is toward goal
                if (!jumper || jumper.type !== 'golem' || jumper.player !== player) continue;
                if (landing) continue; // Landing must be empty
                
                // Is this jump toward our goal?
                const jumpTowardGoal = player === 'dark' 
                    ? landRow < jumperRow 
                    : landRow > jumperRow;
                if (!jumpTowardGoal) continue;
                
                // Can we actually move this jumper? Check glyphs
                let canMoveJumper = false;
                for (const glyph of hand) {
                    const effectiveGlyph = glyph.type === 'mirror' && resting ? resting : glyph;
                    if (!effectiveGlyph) continue;
                    
                    const matches = effectiveGlyph.type === 'color'
                        ? jumper.color === effectiveGlyph.value
                        : effectiveGlyph.type === 'shape'
                            ? jumper.shape === effectiveGlyph.value
                            : false;
                    
                    if (matches) {
                        canMoveJumper = true;
                        break;
                    }
                }
                
                if (canMoveJumper) {
                    // Score based on how close the landing gets us to goal
                    const distanceToGoal = Math.abs(landRow - goalRow);
                    const progressScore = (7 - distanceToGoal) * 10;
                    
                    // Bonus if landing is in opponent's half
                    const opponentHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
                    const inEnemyTerritory = opponentHalf.includes(landRow) ? 20 : 0;
                    
                    // Bonus if this creates a winning threat (landing 1 away from goal)
                    const createsWinThreat = distanceToGoal <= 1 ? 50 : 0;
                    
                    launchpadScore += progressScore + inEnemyTerritory + createsWinThreat;
                }
            }
            
            // Also check if shadow itself is in a good forward position (for future chains)
            const shadowDistanceToGoal = Math.abs(shadowPos.row - goalRow);
            if (shadowDistanceToGoal <= 3) {
                launchpadScore += (4 - shadowDistanceToGoal) * 5; // Forward shadows are valuable
            }
            
            return launchpadScore;
        }

        // Check if placing a shadow at this position would be immediately capturable
        function cpuShadowIsVulnerable(shadowPos, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            
            // Check all 4 orthogonal directions for potential captures
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            for (const [dr, dc] of directions) {
                // Attacker would be at shadowPos + direction
                const attackerRow = shadowPos.row + dr;
                const attackerCol = shadowPos.col + dc;
                // Support would be at shadowPos - direction  
                const supportRow = shadowPos.row - dr;
                const supportCol = shadowPos.col - dc;
                
                if (!isValidPos(attackerRow, attackerCol) || !isValidPos(supportRow, supportCol)) continue;
                
                const attacker = gameState.board[attackerRow][attackerCol];
                const support = gameState.board[supportRow][supportCol];
                
                // Is there an enemy piece that could capture with support?
                if (attacker?.player === opponent && attacker?.type === 'golem') {
                    if (support?.player === opponent) {
                        return true; // Shadow would be immediately capturable
                    }
                }
            }
            
            return false;
        }

        function cpuSelectShadowVariant(moves, player) {
            const moveGroups = new Map();
            
            for (const move of moves) {
                if (move.type !== 'movement') continue;
                
                const key = `${move.from.row},${move.from.col}->${move.to.row},${move.to.col}:${move.glyphIndex}`;
                
                if (!moveGroups.has(key)) {
                    moveGroups.set(key, { withShadow: null, withoutShadow: null });
                }
                
                if (move.placeShadow) {
                    moveGroups.get(key).withShadow = move;
                } else {
                    moveGroups.get(key).withoutShadow = move;
                }
            }
            
            const selectedMoves = [];
            
            for (const [key, group] of moveGroups) {
                if (group.withShadow && group.withoutShadow) {
                    // First check: would this shadow be immediately capturable?
                    const shadowVulnerable = cpuShadowIsVulnerable(group.withShadow.from, player);
                    
                    if (shadowVulnerable) {
                        // Don't place shadow if it would be captured
                        selectedMoves.push(group.withoutShadow);
                    } else {
                        // Evaluate the shadow as a launchpad
                        const launchpadScore = cpuEvaluateShadowLaunchpad(group.withShadow.from, player);
                        
                        // Use shadow if it creates a good launchpad (score > 40)
                        if (launchpadScore > 40) {
                            selectedMoves.push(group.withShadow);
                        } else {
                            selectedMoves.push(group.withoutShadow);
                        }
                    }
                } else {
                    selectedMoves.push(group.withShadow || group.withoutShadow);
                }
            }
            
            // Add non-movement moves
            for (const move of moves) {
                if (move.type !== 'movement') {
                    selectedMoves.push(move);
                }
            }
            
            return selectedMoves;
        }

        function cpuCountPiecesInOpponentHalf(player) {
            const opponentHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
            let count = 0;
            
            for (let row = 0; row < 8; row++) {
                if (!opponentHalf.includes(row)) continue;
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'golem' && piece.player === player) {
                        count++;
                    }
                }
            }
            
            return count;
        }

        function cpuGetMove() {
            const player = gameState.currentPlayer;
            const opponent = player === 'dark' ? 'light' : 'dark';
            const goalRow = player === 'dark' ? 0 : 7;
            
            let moves = getCpuLegalMoves(player);
            if (moves.length === 0) return null;
            
            // Apply smart shadow selection
            moves = cpuSelectShadowVariant(moves, player);
            
            // 1. Win if possible
            for (const move of moves) {
                if (move.type === 'movement' && move.to.row === goalRow) {
                    return move;
                }
            }
            
            // 2. Block opponent's winning threats
            const blockingMoves = cpuFindBlockingMoves(moves, player);
            if (blockingMoves.length > 0) {
                return blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
            }
            
            // 3. Capture if possible
            const capturingMoves = [];
            for (const move of moves) {
                const captures = cpuPredictCaptures(move, player);
                if (captures > 0) {
                    capturingMoves.push({ move, captures });
                }
            }
            if (capturingMoves.length > 0) {
                capturingMoves.sort((a, b) => b.captures - a.captures);
                return capturingMoves[0].move;
            }
            
            // 4. Safe advance toward goal
            const isEarlyGame = cpuCountPiecesInOpponentHalf(player) < 3;
            
            if (isEarlyGame) {
                const safeAdvances = [];
                const unsafeAdvances = [];
                
                for (const move of moves) {
                    if (move.type === 'movement') {
                        const advancesTowardGoal = player === 'dark'
                            ? move.to.row < move.from.row
                            : move.to.row > move.from.row;
                        
                        if (advancesTowardGoal) {
                            const piece = gameState.board[move.from.row][move.from.col];
                            const hasBackup = cpuHasOtherGlyphForPiece(piece, move.glyphIndex, player);
                            const isSafe = !cpuMoveExposesToCapture(move);
                            
                            if (isSafe) {
                                safeAdvances.push({ move, hasBackup });
                            } else {
                                unsafeAdvances.push({ move, hasBackup });
                            }
                        }
                    }
                }
                
                if (safeAdvances.length > 0) {
                    const withBackup = safeAdvances.filter(m => m.hasBackup);
                    if (withBackup.length > 0) {
                        return withBackup[Math.floor(Math.random() * withBackup.length)].move;
                    }
                    return safeAdvances[Math.floor(Math.random() * safeAdvances.length)].move;
                }
                
                if (unsafeAdvances.length > 0) {
                    const withBackup = unsafeAdvances.filter(m => m.hasBackup);
                    if (withBackup.length > 0) {
                        return withBackup[Math.floor(Math.random() * withBackup.length)].move;
                    }
                    return unsafeAdvances[Math.floor(Math.random() * unsafeAdvances.length)].move;
                }
            }
            
            // 5. Any advancing move
            const opponentHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
            const advancingMoves = moves.filter(m => 
                m.type === 'movement' && 
                opponentHalf.includes(m.to.row) &&
                (player === 'dark' ? m.to.row < m.from.row : m.to.row > m.from.row)
            );
            
            if (advancingMoves.length > 0) {
                return advancingMoves[Math.floor(Math.random() * advancingMoves.length)];
            }
            
            // 6. Random
            return moves[Math.floor(Math.random() * moves.length)];
        }

        // === CPU V4 - Medium difficulty with 2-ply lookahead ===
        
        function cpuSimulateMove(move, player) {
            // Create a minimal copy of relevant game state
            const boardCopy = gameState.board.map(row => row.map(cell => cell ? {...cell} : null));
            
            if (move.type === 'movement') {
                // Move the piece
                boardCopy[move.to.row][move.to.col] = boardCopy[move.from.row][move.from.col];
                boardCopy[move.from.row][move.from.col] = move.placeShadow 
                    ? { type: 'shadow', player } 
                    : null;
            }
            
            return boardCopy;
        }

        function cpuCanWinOnBoard(board, player) {
            const goalRow = player === 'dark' ? 0 : 7;
            
            // Check if any piece can reach goal row
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece?.type === 'golem' && piece.player === player) {
                        const moves = cpuGetValidMovesOnBoard(board, row, col, player);
                        for (const dest of moves) {
                            if (dest.row === goalRow) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function cpuGetValidMovesOnBoard(board, row, col, player) {
            // Simplified getValidMoves that works on a board copy
            const moves = [];
            const piece = board[row][col];
            if (!piece || piece.type !== 'golem') return moves;

            // Orthogonal steps (2 spaces)
            const orthDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dr, dc] of orthDirs) {
                const midRow = row + dr;
                const midCol = col + dc;
                const newRow = row + 2 * dr;
                const newCol = col + 2 * dc;

                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 && !board[newRow][newCol]) {
                    const midPiece = board[midRow]?.[midCol];
                    if (!midPiece || midPiece.player === piece.player) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }

            // Diagonal steps (1 space)
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dr, dc] of diagDirs) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 && !board[newRow][newCol]) {
                    moves.push({ row: newRow, col: newCol });
                }
            }

            // Diagonal jumps (simplified - just immediate jumps)
            for (const [dr, dc] of diagDirs) {
                const jumpOver = board[row + dr]?.[col + dc];
                if (jumpOver?.player === player) {
                    const landRow = row + 2 * dr;
                    const landCol = col + 2 * dc;
                    if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8 && !board[landRow][landCol]) {
                        moves.push({ row: landRow, col: landCol });
                    }
                }
            }

            return moves;
        }

        function cpuMoveCreatesWinThreat(move, player) {
            if (move.type !== 'movement') return false;
            
            const goalRow = player === 'dark' ? 0 : 7;
            const boardAfter = cpuSimulateMove(move, player);
            
            // Check if the moved piece can now reach goal
            const movedPieceMoves = cpuGetValidMovesOnBoard(boardAfter, move.to.row, move.to.col, player);
            for (const dest of movedPieceMoves) {
                if (dest.row === goalRow) {
                    return true;
                }
            }
            
            return false;
        }

        function cpuMoveAllowsOpponentWin(move, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const boardAfter = cpuSimulateMove(move, player);
            return cpuCanWinOnBoard(boardAfter, opponent);
        }

        // Check if a move sets up a future jump-threat (2-move threat)
        function cpuMoveCreatesSetup(move, player) {
            if (move.type !== 'movement') return false;
            
            const goalRow = player === 'dark' ? 0 : 7;
            const direction = player === 'dark' ? -1 : 1;
            const boardAfter = cpuSimulateMove(move, player);
            
            // Check if the moved piece will be able to CREATE a win threat next turn
            // by jumping over a friendly piece toward goal
            const destRow = move.to.row;
            const destCol = move.to.col;
            
            // Look for friendly pieces we could jump over next turn
            const diagDirs = [[direction, 1], [direction, -1]]; // Only toward goal
            
            for (const [dr, dc] of diagDirs) {
                const adjacentRow = destRow + dr;
                const adjacentCol = destCol + dc;
                const landRow = destRow + 2 * dr;
                const landCol = destCol + 2 * dc;
                
                // Check if there's a friendly piece adjacent and landing is valid
                if (adjacentRow >= 0 && adjacentRow < 8 && adjacentCol >= 0 && adjacentCol < 8 &&
                    landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8) {
                    
                    const adjacent = boardAfter[adjacentRow]?.[adjacentCol];
                    const landing = boardAfter[landRow]?.[landCol];
                    
                    if (adjacent?.player === player && !landing) {
                        // We can jump! Does the landing threaten goal?
                        if (landRow === goalRow) {
                            return true; // Jump leads directly to win
                        }
                        // Or is landing one diagonal step from goal?
                        if (Math.abs(landRow - goalRow) === 1) {
                            return true; // Jump puts us in winning position
                        }
                    }
                }
            }
            
            // Also check: does this move place us adjacent to a friendly piece
            // that could then jump over US toward goal?
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardAfter[r][c];
                    if (piece?.type === 'golem' && piece.player === player && !(r === destRow && c === destCol)) {
                        // Can this piece jump over our new position toward goal?
                        for (const [dr, dc] of diagDirs) {
                            if (r + dr === destRow && c + dc === destCol) {
                                // We're adjacent! Can they land?
                                const landRow = r + 2 * dr;
                                const landCol = c + 2 * dc;
                                if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8 && !boardAfter[landRow][landCol]) {
                                    if (landRow === goalRow || Math.abs(landRow - goalRow) === 1) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Check shadow placement setups
            if (move.placeShadow) {
                // Shadow at from position - can any piece jump over it?
                const shadowRow = move.from.row;
                const shadowCol = move.from.col;
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = boardAfter[r][c];
                        if (piece?.type === 'golem' && piece.player === player) {
                            for (const [dr, dc] of diagDirs) {
                                if (r + dr === shadowRow && c + dc === shadowCol) {
                                    const landRow = r + 2 * dr;
                                    const landCol = c + 2 * dc;
                                    if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8 && !boardAfter[landRow][landCol]) {
                                        if (landRow === goalRow || Math.abs(landRow - goalRow) === 1) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return false;
        }

        function cpuGetMoveV4() {
            const player = gameState.currentPlayer;
            const opponent = player === 'dark' ? 'light' : 'dark';
            const goalRow = player === 'dark' ? 0 : 7;
            
            let moves = getCpuLegalMoves(player);
            if (moves.length === 0) return null;
            
            // Apply smart shadow selection
            moves = cpuSelectShadowVariant(moves, player);
            
            // 1. Win if possible
            for (const move of moves) {
                if (move.type === 'movement' && move.to.row === goalRow) {
                    return move;
                }
            }
            
            // 2. Categorize all moves by safety, threat, and setup potential
            const safeMoves = [];          // Don't lose, no threat
            const safeThreats = [];        // Don't lose, creates immediate threat (best!)
            const safeSetups = [];         // Don't lose, sets up future threat (great!)
            const losingMoves = [];        // Lets opponent win
            const losingThreats = [];      // Lets opponent win, but we also threaten
            
            for (const move of moves) {
                const allowsWin = cpuMoveAllowsOpponentWin(move, player);
                const createsThreat = cpuMoveCreatesWinThreat(move, player);
                const createsSetup = cpuMoveCreatesSetup(move, player);
                
                if (allowsWin) {
                    if (createsThreat) {
                        losingThreats.push(move);
                    } else {
                        losingMoves.push(move);
                    }
                } else {
                    if (createsThreat) {
                        safeThreats.push(move);
                    } else if (createsSetup) {
                        safeSetups.push(move);
                    } else {
                        safeMoves.push(move);
                    }
                }
            }
            
            // 3. If we have safe immediate threats, pick one!
            if (safeThreats.length > 0) {
                return safeThreats[Math.floor(Math.random() * safeThreats.length)];
            }
            
            // 4. If we have safe setups (future threats), prioritize those!
            if (safeSetups.length > 0) {
                // Prefer setups that also advance toward goal
                const advancingSetups = safeSetups.filter(m =>
                    m.type === 'movement' &&
                    (player === 'dark' ? m.to.row < m.from.row : m.to.row > m.from.row)
                );
                if (advancingSetups.length > 0) {
                    return advancingSetups[Math.floor(Math.random() * advancingSetups.length)];
                }
                return safeSetups[Math.floor(Math.random() * safeSetups.length)];
            }
            
            // 5. Among safe moves, use V3 logic (block, capture, advance)
            if (safeMoves.length > 0) {
                // Block opponent threats
                const blockingMoves = cpuFindBlockingMoves(safeMoves, player);
                if (blockingMoves.length > 0) {
                    return blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
                }
                
                // Capture
                const capturingMoves = [];
                for (const move of safeMoves) {
                    const captures = cpuPredictCaptures(move, player);
                    if (captures > 0) {
                        capturingMoves.push({ move, captures });
                    }
                }
                if (capturingMoves.length > 0) {
                    capturingMoves.sort((a, b) => b.captures - a.captures);
                    return capturingMoves[0].move;
                }
                
                // Advance toward goal
                const advancingMoves = safeMoves.filter(m => 
                    m.type === 'movement' && 
                    (player === 'dark' ? m.to.row < m.from.row : m.to.row > m.from.row)
                );
                if (advancingMoves.length > 0) {
                    return advancingMoves[Math.floor(Math.random() * advancingMoves.length)];
                }
                
                // Any safe move
                return safeMoves[Math.floor(Math.random() * safeMoves.length)];
            }
            
            // 6. No safe moves! At least scare them with a counter-threat
            if (losingThreats.length > 0) {
                return losingThreats[Math.floor(Math.random() * losingThreats.length)];
            }
            
            // 7. We're doomed, just pick something
            return losingMoves.length > 0 
                ? losingMoves[Math.floor(Math.random() * losingMoves.length)]
                : moves[Math.floor(Math.random() * moves.length)];
        }

        // === CPU V6 - 3-ply lookahead with smart shadows ===
        
        function cpuApplyMoveToState(move, player) {
            // Create a simplified state after the move
            const newBoard = gameState.board.map(row => row.map(cell => cell ? {...cell} : null));
            const newHands = {
                darkHand: gameState.darkHand.map(g => ({...g})),
                lightHand: gameState.lightHand.map(g => ({...g})),
                darkResting: gameState.darkResting ? {...gameState.darkResting} : null,
                lightResting: gameState.lightResting ? {...gameState.lightResting} : null,
                darkSupply: { shadows: gameState.darkSupply.shadows },
                lightSupply: { shadows: gameState.lightSupply.shadows }
            };
            
            if (move.type === 'movement') {
                newBoard[move.to.row][move.to.col] = newBoard[move.from.row][move.from.col];
                newBoard[move.from.row][move.from.col] = move.placeShadow 
                    ? { type: 'shadow', player } 
                    : null;
                
                // Handle glyph transfer
                const hand = player === 'dark' ? newHands.darkHand : newHands.lightHand;
                const usedGlyph = hand.splice(move.glyphIndex, 1)[0];
                
                if (player === 'dark') {
                    if (newHands.darkResting) hand.push(newHands.darkResting);
                    newHands.darkResting = null;
                    newHands.lightResting = usedGlyph;
                } else {
                    if (newHands.lightResting) hand.push(newHands.lightResting);
                    newHands.lightResting = null;
                    newHands.darkResting = usedGlyph;
                }
                
                if (move.placeShadow) {
                    const supply = player === 'dark' ? newHands.darkSupply : newHands.lightSupply;
                    supply.shadows--;
                }
            }
            
            return { board: newBoard, ...newHands };
        }

        function cpuGetLegalMovesForState(simState, player) {
            // Generate legal moves for a simulated state
            const moves = [];
            const hand = player === 'dark' ? simState.darkHand : simState.lightHand;
            const resting = player === 'dark' ? simState.darkResting : simState.lightResting;
            const supply = player === 'dark' ? simState.darkSupply : simState.lightSupply;
            const canPlaceShadow = supply.shadows > 0;
            
            for (let glyphIndex = 0; glyphIndex < hand.length; glyphIndex++) {
                const glyph = hand[glyphIndex];
                const effectiveGlyph = glyph.type === 'mirror' && resting ? resting : glyph;
                
                // Find matching pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = simState.board[row][col];
                        if (!piece || piece.type !== 'golem' || piece.player !== player) continue;
                        
                        const matches = effectiveGlyph.type === 'color' 
                            ? piece.color === effectiveGlyph.value
                            : effectiveGlyph.type === 'shape' 
                                ? piece.shape === effectiveGlyph.value 
                                : false;
                        
                        if (!matches) continue;
                        
                        // Get valid destinations
                        const destinations = cpuGetValidMovesOnBoard(simState.board, row, col, player);
                        for (const dest of destinations) {
                            moves.push({
                                type: 'movement',
                                from: { row, col },
                                to: dest,
                                glyphIndex,
                                placeShadow: false
                            });
                            if (canPlaceShadow) {
                                moves.push({
                                    type: 'movement',
                                    from: { row, col },
                                    to: dest,
                                    glyphIndex,
                                    placeShadow: true
                                });
                            }
                        }
                    }
                }
            }
            
            return moves;
        }

        function cpuEvaluatePosition(board, player) {
            const goalRow = player === 'dark' ? 0 : 7;
            let bestDistance = 8;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece?.type === 'golem' && piece.player === player) {
                        const distance = Math.abs(row - goalRow);
                        if (distance < bestDistance) bestDistance = distance;
                    }
                }
            }
            
            return 8 - bestDistance;
        }

        function cpuMoveScore3Ply(move, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const goalRow = player === 'dark' ? 0 : 7;
            const opponentGoalRow = player === 'dark' ? 7 : 0;
            
            // Immediate win
            if (move.type === 'movement' && move.to.row === goalRow) {
                return 10000;
            }
            
            // Apply our move
            const stateAfterOurMove = cpuApplyMoveToState(move, player);
            
            // Check if opponent can win immediately
            const oppMoves = cpuGetLegalMovesForState(stateAfterOurMove, opponent);
            for (const oppMove of oppMoves) {
                if (oppMove.type === 'movement' && oppMove.to.row === opponentGoalRow) {
                    return -5000; // Losing move
                }
            }
            
            // Find opponent's best response
            let bestOppMove = null;
            let bestOppScore = -Infinity;
            
            for (const oppMove of oppMoves) {
                let score = 0;
                
                // Check if creates threat
                const boardAfterOpp = cpuSimulateMove(oppMove, opponent);
                const oppPieceMoves = cpuGetValidMovesOnBoard(boardAfterOpp, oppMove.to.row, oppMove.to.col, opponent);
                for (const dest of oppPieceMoves) {
                    if (dest.row === opponentGoalRow) {
                        score += 100;
                        break;
                    }
                }
                
                // Advancement
                if (oppMove.type === 'movement') {
                    const advancement = opponent === 'dark' 
                        ? oppMove.from.row - oppMove.to.row
                        : oppMove.to.row - oppMove.from.row;
                    score += advancement * 10;
                }
                
                if (score > bestOppScore) {
                    bestOppScore = score;
                    bestOppMove = oppMove;
                }
            }
            
            if (!bestOppMove) {
                return 5000; // Opponent has no moves
            }
            
            // Apply opponent's best response
            const stateAfterOppResponse = cpuApplyMoveToState(bestOppMove, opponent);
            stateAfterOppResponse.board = cpuSimulateMove(bestOppMove, opponent);
            
            // Check our next turn options
            const ourNextMoves = cpuGetLegalMovesForState(stateAfterOppResponse, player);
            
            let score = 0;
            
            // Can we win?
            for (const nextMove of ourNextMoves) {
                if (nextMove.type === 'movement' && nextMove.to.row === goalRow) {
                    score += 1000;
                    break;
                }
            }
            
            // Do we have threats?
            for (const nextMove of ourNextMoves) {
                if (cpuMoveCreatesWinThreat(nextMove, player)) {
                    score += 50;
                    break;
                }
            }
            
            // Position evaluation
            score += cpuEvaluatePosition(stateAfterOppResponse.board, player) * 5;
            score -= cpuEvaluatePosition(stateAfterOppResponse.board, opponent) * 5;
            
            // Bonus for immediate threat
            if (cpuMoveCreatesWinThreat(move, player)) {
                score += 200;
            }
            
            // Bonus for setup
            if (cpuMoveCreatesSetup(move, player)) {
                score += 30;
            }
            
            // Bonus for captures
            const captures = cpuPredictCaptures(move, player);
            if (captures > 0) {
                score += captures * 75; // Significant bonus for each capture
            }
            
            return score;
        }

        // Comprehensive threat assessment - considers stepping stones and jump chains
        function cpuAssessThreats(player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const oppHand = opponent === 'dark' ? gameState.darkHand : gameState.lightHand;
            const oppResting = opponent === 'dark' ? gameState.darkResting : gameState.lightResting;
            const ourGoalRow = player === 'dark' ? 7 : 0;
            const dangerZone = player === 'dark' ? [4, 5, 6, 7] : [0, 1, 2, 3];
            const direction = opponent === 'dark' ? -1 : 1; // Direction opponent advances
            
            // Find all opponent pieces
            const oppPieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.player === opponent && piece.type === 'golem') {
                        oppPieces.push({ row, col, piece });
                    }
                }
            }
            
            // Find pieces in our danger zone
            const piecesInDangerZone = oppPieces.filter(p => dangerZone.includes(p.row));
            
            // For each piece in danger zone, assess threat level
            const threats = [];
            
            for (const advanced of piecesInDangerZone) {
                let threatLevel = 0;
                const distanceToGoal = Math.abs(advanced.row - ourGoalRow);
                
                // 1. Can they move this piece directly? (check glyphs)
                let canMoveDirect = false;
                for (const glyph of oppHand) {
                    const effectiveGlyph = glyph.type === 'mirror' && oppResting ? oppResting : glyph;
                    if (!effectiveGlyph) continue;
                    
                    const matches = effectiveGlyph.type === 'color'
                        ? advanced.piece.color === effectiveGlyph.value
                        : effectiveGlyph.type === 'shape'
                            ? advanced.piece.shape === effectiveGlyph.value
                            : false;
                    
                    if (matches) {
                        canMoveDirect = true;
                        threatLevel += 30; // Direct threat
                        break;
                    }
                }
                
                // 2. Can other pieces use this as a stepping stone?
                let steppingStoneValue = 0;
                for (const other of oppPieces) {
                    if (other.row === advanced.row && other.col === advanced.col) continue;
                    
                    // Check if 'other' can jump over 'advanced' toward goal
                    const diagDirs = [[direction, 1], [direction, -1]];
                    for (const [dr, dc] of diagDirs) {
                        // Is 'advanced' diagonally adjacent to 'other' in the goal direction?
                        if (advanced.row === other.row + dr && advanced.col === other.col + dc) {
                            // Landing spot
                            const landRow = other.row + 2 * dr;
                            const landCol = other.col + 2 * dc;
                            
                            if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8) {
                                const landSpot = gameState.board[landRow][landCol];
                                if (!landSpot) {
                                    // Can jump! Check if they have glyph for 'other'
                                    for (const glyph of oppHand) {
                                        const effectiveGlyph = glyph.type === 'mirror' && oppResting ? oppResting : glyph;
                                        if (!effectiveGlyph) continue;
                                        
                                        const matches = effectiveGlyph.type === 'color'
                                            ? other.piece.color === effectiveGlyph.value
                                            : effectiveGlyph.type === 'shape'
                                                ? other.piece.shape === effectiveGlyph.value
                                                : false;
                                        
                                        if (matches) {
                                            const jumpDistance = Math.abs(landRow - ourGoalRow);
                                            steppingStoneValue += (8 - jumpDistance) * 5; // Closer = scarier
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                threatLevel += steppingStoneValue;
                
                // 3. Pieces behind that could chain through
                let chainPotential = 0;
                const behindRows = opponent === 'dark' 
                    ? [advanced.row + 1, advanced.row + 2] 
                    : [advanced.row - 1, advanced.row - 2];
                
                for (const other of oppPieces) {
                    if (behindRows.includes(other.row)) {
                        // Piece behind could potentially chain
                        chainPotential += 10;
                    }
                }
                
                threatLevel += chainPotential;
                
                // 4. Distance bonus - closer is more urgent
                threatLevel += (7 - distanceToGoal) * 15;
                
                if (threatLevel > 0) {
                    threats.push({
                        row: advanced.row,
                        col: advanced.col,
                        distanceToGoal,
                        piece: advanced.piece,
                        threatLevel,
                        canMoveDirect,
                        isSteppingStone: steppingStoneValue > 0
                    });
                }
            }
            
            // Sort by threat level
            threats.sort((a, b) => b.threatLevel - a.threatLevel);
            
            return threats;
        }

        // Count our pieces in opponent's half
        function cpuCountOurPenetration(player) {
            const theirHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
            let count = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'golem' && piece.player === player && theirHalf.includes(row)) {
                        count++;
                    }
                }
            }
            
            return count;
        }

        // Check if a move blocks or contests opponent's advanced pieces
        function cpuMoveContestsThreats(move, threats, player) {
            if (move.type !== 'movement') return 0;
            
            let contestScore = 0;
            
            for (const threat of threats) {
                // Does this move land adjacent to a threat? (potential capture setup)
                const rowDiff = Math.abs(move.to.row - threat.row);
                const colDiff = Math.abs(move.to.col - threat.col);
                
                if (rowDiff <= 1 && colDiff <= 1) {
                    contestScore += 10;
                }
                
                // Does this move block a path toward our goal?
                const ourGoalRow = player === 'dark' ? 7 : 0;
                if (move.to.col === threat.col && 
                    Math.abs(move.to.row - ourGoalRow) < Math.abs(threat.row - ourGoalRow)) {
                    contestScore += 20;
                }
                
                // Does this move land on a square the threat could reach?
                const threatMoves = cpuGetValidMovesOnBoard(gameState.board, threat.row, threat.col, 
                    player === 'dark' ? 'light' : 'dark');
                for (const tm of threatMoves) {
                    if (tm.row === move.to.row && tm.col === move.to.col) {
                        contestScore += 15; // We're taking a square they wanted
                        break;
                    }
                }
            }
            
            return contestScore;
        }

        function cpuGetMoveV6() {
            const player = gameState.currentPlayer;
            const goalRow = player === 'dark' ? 0 : 7;
            
            let moves = getCpuLegalMoves(player);
            if (moves.length === 0) return null;
            
            // 1. Win if possible (check before any filtering)
            for (const move of moves) {
                if (move.type === 'movement' && move.to.row === goalRow) {
                    return move;
                }
            }
            
            // 2. Assess threats with stepping stone detection
            const threats = cpuAssessThreats(player);
            const ourPenetration = cpuCountOurPenetration(player);
            
            // Calculate total threat level
            const totalThreatLevel = threats.reduce((sum, t) => sum + t.threatLevel, 0);
            const hasActiveThreats = threats.some(t => t.canMoveDirect || t.isSteppingStone);
            const hasUrgentThreat = threats.some(t => t.distanceToGoal <= 2);
            
            // Panic if: high threat level with active threats, and we're not counter-attacking
            const panicMode = totalThreatLevel >= 60 && hasActiveThreats && ourPenetration <= 1;
            const urgentMode = hasUrgentThreat;
            
            // 3. Filter shadow variants (after strategic assessment)
            moves = cpuSelectShadowVariant(moves, player);
            
            // 4. Score all moves with 3-ply lookahead
            const scoredMoves = moves.map(move => {
                let score = cpuMoveScore3Ply(move, player);
                
                // In panic/urgent mode, boost moves that contest threats
                if (panicMode || urgentMode) {
                    const contestScore = cpuMoveContestsThreats(move, threats, player);
                    score += contestScore * (urgentMode ? 3 : 2);
                    
                    // Penalize pure advancement when we should be defending
                    if (contestScore === 0 && move.type === 'movement') {
                        const isAdvancing = player === 'dark' 
                            ? move.to.row < move.from.row 
                            : move.to.row > move.from.row;
                        if (isAdvancing && panicMode) {
                            score -= 50; // Don't just advance when under attack!
                        }
                    }
                }
                
                return { move, score };
            });
            
            scoredMoves.sort((a, b) => b.score - a.score);
            
            const bestScore = scoredMoves[0].score;
            const bestMoves = scoredMoves.filter(m => m.score === bestScore);
            
            return bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
        }

        function executeCpuMove(move) {
            if (!move) return;
            
            saveState();
            
            // Select the glyph
            gameState.selectedGlyph = { index: move.glyphIndex };
            
            if (move.type === 'movement') {
                // Set shadow primed if needed
                gameState.shadowPrimed = move.placeShadow;
                
                // Execute the move
                movePiece(move.from.row, move.from.col, move.to.row, move.to.col);
            } else if (move.type === 'reactivation') {
                // Select the mask
                gameState.selectedMask = { index: move.maskIndex };
                
                // Execute reactivation
                executeReactivation(move.position.row, move.position.col, move.maskIndex);
            }
        }

        function triggerCpuMoveIfNeeded() {
            if (!cpuMode || gameState.gameOver) return;
            
            // In spectate mode, CPU plays both sides
            // In regular CPU mode, only play if it's the CPU's turn
            if (!spectateMode && gameState.currentPlayer !== cpuPlayer) return;
            
            // Use longer delay for spectate mode so viewers can follow
            const delay = spectateMode ? 4000 : 500;
            
            setTimeout(() => {
                // Check conditions again after delay
                if (gameState.gameOver) return;
                if (!spectateMode && gameState.currentPlayer !== cpuPlayer) return;
                
                const move = cpuGetMoveV6();
                if (move) {
                    executeCpuMove(move);
                }
            }, delay);
        }

        // === GAME END ===
        function showBreakthroughNotification(scorer, opponentLivesRemaining) {
            // Create temporary notification
            const notification = document.createElement('div');
            notification.className = 'breakthrough-notification';
            notification.innerHTML = `
                <div style="font-size: 1.2rem; font-weight: 600;">${capitalize(scorer)} scores!</div>
                <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 4px;">
                    ${opponentLivesRemaining} ${opponentLivesRemaining === 1 ? 'life' : 'lives'} remaining
                </div>
            `;
            document.body.appendChild(notification);
            
            // Animate in
            requestAnimationFrame(() => {
                notification.classList.add('show');
            });
            
            // Remove after delay
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 1500);
        }
        
        function endGame(winner, message) {
            gameState.gameOver = true;
            if (gameState.clockInterval) clearInterval(gameState.clockInterval);

            document.getElementById('victoryTitle').textContent = winner === 'draw' ? 'Draw!' : 'Victory!';
            document.getElementById('victoryMessage').textContent = 
                message || `${capitalize(winner)} Wins!`;
            document.getElementById('victoryModal').classList.add('show');
            
            // Show analysis console after a brief delay
            setTimeout(() => {
                showAnalysisUI();
            }, 500);
        }

        // === UNDO ===
        function saveState() {
            historyStack.push(JSON.stringify(gameState));
        }

        function undoMove() {
            if (historyStack.length === 0 || gameState.gameOver) return;

            const prevState = JSON.parse(historyStack.pop());
            
            // Also remove the last recorded move from analysis
            if (analysisData.moves.length > 0) {
                analysisData.moves.pop();
            }
            
            // Preserve clock interval
            const clockInterval = gameState.clockInterval;
            
            gameState = prevState;
            gameState.clockInterval = clockInterval;
            gameState.lastMoveTime = Date.now();

            renderGame();
        }

        // === UTILITIES ===
        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        function startNewGame() {
            document.getElementById('victoryModal').classList.remove('show');
            showNewGameModal();
        }

        // Board flip functionality
        let boardFlipped = false;

        function toggleBoardFlip() {
            boardFlipped = !boardFlipped;
            applyBoardFlip();
        }

        function setBoardFlip(flipped) {
            boardFlipped = flipped;
            applyBoardFlip();
        }

        function applyBoardFlip() {
            const board = document.getElementById('board');
            const sidebar = document.querySelector('.left-sidebar');
            const gameArea = document.querySelector('.game-area');
            board.classList.toggle('flipped', boardFlipped);
            sidebar.classList.toggle('flipped', boardFlipped);
            gameArea.classList.toggle('flipped', boardFlipped);
            updateCoordinates();
        }

        function updateCoordinates() {
            // Remove all existing coordinates
            document.querySelectorAll('.coord').forEach(el => el.remove());
            
            // When not flipped: ranks on col 0 (left), files on row 7 (bottom)
            // When flipped: ranks on col 7 (left after flip), files on row 0 (bottom after flip)
            
            const rankCol = boardFlipped ? 7 : 0;
            const fileRow = boardFlipped ? 0 : 7;
            
            for (let row = 0; row < 8; row++) {
                const square = document.getElementById(`sq-${row}-${rankCol}`);
                if (square) {
                    const rankCoord = document.createElement('span');
                    rankCoord.className = 'coord coord-rank';
                    rankCoord.textContent = 8 - row;
                    square.appendChild(rankCoord);
                }
            }
            
            for (let col = 0; col < 8; col++) {
                const square = document.getElementById(`sq-${fileRow}-${col}`);
                if (square) {
                    const fileCoord = document.createElement('span');
                    fileCoord.className = 'coord coord-file';
                    fileCoord.textContent = 'abcdefgh'[col];
                    square.appendChild(fileCoord);
                }
            }
        }

        function showNewGameModal() {
            // Restore sliders to last selected values
            const timeSlider = document.getElementById('timeSlider');
            const incrementSlider = document.getElementById('incrementSlider');
            
            // Convert selectedTime back to minutes for slider
            timeSlider.value = selectedTime === 0 ? 0 : selectedTime / 60;
            incrementSlider.value = selectedIncrement;
            
            updateTimeDisplay();
            updateIncrementDisplay();
            document.getElementById('newGameModal').classList.add('show');
        }

        function updateTimeDisplay() {
            const slider = document.getElementById('timeSlider');
            const display = document.getElementById('timeDisplay');
            const minutes = parseInt(slider.value);
            
            if (minutes === 0) {
                display.textContent = 'âˆž';
                selectedTime = 0;
            } else {
                display.textContent = `${minutes}:00`;
                selectedTime = minutes * 60;
            }
        }

        function updateIncrementDisplay() {
            const slider = document.getElementById('incrementSlider');
            const display = document.getElementById('incrementDisplay');
            const seconds = parseInt(slider.value);
            
            display.textContent = `+${seconds}s`;
            selectedIncrement = seconds;
        }

        function setLives(lives) {
            selectedLives = lives;
            
            // Update button styles (0, 1, 2, 3 are the options)
            [1, 2, 3].forEach(n => {
                const btn = document.getElementById(`lives${n}Btn`);
                btn.style.background = lives === n ? 'var(--gold)' : 'var(--slate)';
                btn.style.color = lives === n ? '' : 'var(--pearl)';
            });
            
            // Sudden Death button (0 lives)
            const sdBtn = document.getElementById('lives0Btn');
            sdBtn.style.background = lives === 0 ? 'var(--gold)' : 'var(--slate)';
            sdBtn.style.color = lives === 0 ? '' : 'var(--pearl)';
        }

        // Game Mode controls
        let selectedGameMode = 'human'; // 'human', 'cpu', or 'online'
        let selectedPlayerSide = 'dark';
        let spectateMode = false;

        function setGameMode(mode) {
            selectedGameMode = mode;
            
            // If online mode selected, open the online modal instead
            if (mode === 'online') {
                document.getElementById('newGameModal').classList.remove('show');
                openOnlineModal();
                return;
            }
            
            // Update button styles
            document.getElementById('humanBtn').style.background = mode === 'human' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('humanBtn').style.color = mode === 'human' ? '' : 'var(--pearl)';
            document.getElementById('cpuBtn').style.background = mode === 'cpu' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('cpuBtn').style.color = mode === 'cpu' ? '' : 'var(--pearl)';
            document.getElementById('onlineBtn').style.background = mode === 'online' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('onlineBtn').style.color = mode === 'online' ? '' : 'var(--pearl)';
            
            // Show side selection only for CPU mode
            document.getElementById('cpuSideSelect').style.display = mode === 'cpu' ? 'block' : 'none';
        }

        function setPlayerSide(side) {
            selectedPlayerSide = side;
            
            document.getElementById('playDarkBtn').style.background = side === 'dark' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('playDarkBtn').style.color = side === 'dark' ? '' : 'var(--pearl)';
            document.getElementById('playLightBtn').style.background = side === 'light' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('playLightBtn').style.color = side === 'light' ? '' : 'var(--pearl)';
        }

        function startGameWithTime() {
            // Set game mode based on selection
            if (selectedGameMode === 'cpu') {
                cpuMode = true;
                spectateMode = false;
                cpuPlayer = selectedPlayerSide === 'dark' ? 'light' : 'dark';
            } else {
                cpuMode = false;
                spectateMode = false;
                cpuPlayer = 'light';
            }
            
            document.getElementById('newGameModal').classList.remove('show');
            initGame();
            
            // Auto-flip board when playing as Light vs CPU
            if (cpuMode && selectedPlayerSide === 'light') {
                setBoardFlip(true);
            } else {
                setBoardFlip(false);
            }
            
            // If CPU plays first (player chose Light) or spectate mode, trigger CPU move
            if (cpuMode && (cpuPlayer === 'dark' || spectateMode)) {
                triggerCpuMoveIfNeeded();
            }
        }

        function closeWelcome() {
            document.getElementById('welcomeModal').classList.remove('show');
        }

        function closeVictoryModal() {
            document.getElementById('victoryModal').classList.remove('show');
        }

        // === RESIGN / DRAW ===
        let resigningPlayer = null;

        function confirmResign(player) {
            if (gameState.gameOver) return;
            
            resigningPlayer = player;
            document.getElementById('resignMessage').textContent = 
                `${capitalize(player)} player: What would you like to do?`;
            document.getElementById('resignModal').classList.add('show');
        }

        function executeResign() {
            if (!resigningPlayer) return;
            
            // In online mode, can only resign as local player
            if (onlineMode && resigningPlayer !== localPlayer) return;
            
            document.getElementById('resignModal').classList.remove('show');
            const winner = resigningPlayer === 'dark' ? 'light' : 'dark';
            
            // Notify opponent
            if (onlineMode) {
                sendOnlineMessage({
                    type: 'resign',
                    player: resigningPlayer
                });
            }
            
            endGame(winner, `${capitalize(winner)} wins by resignation!`);
            resigningPlayer = null;
        }

        function showDrawOffer() {
            if (!resigningPlayer) return;
            
            document.getElementById('resignModal').classList.remove('show');
            
            // In online mode, send draw offer to opponent
            if (onlineMode) {
                if (resigningPlayer !== localPlayer) return;
                sendOnlineMessage({ type: 'drawOffer' });
                // Show waiting message
                document.getElementById('drawOfferMessage').textContent = 'Waiting for opponent to respond to draw offer...';
                document.getElementById('drawOfferModal').classList.add('show');
                // Hide the accept/decline buttons - we're offering, not receiving
                document.querySelector('#drawOfferModal .modal-content').innerHTML = `
                    <h2>Draw Offered</h2>
                    <p style="margin: 20px 0; color: var(--silver);">Waiting for opponent to respond...</p>
                    <button class="btn" onclick="declineDraw()" style="background: var(--slate); color: var(--pearl);">Cancel</button>
                `;
                return;
            }
            
            const otherPlayer = resigningPlayer === 'dark' ? 'light' : 'dark';
            
            document.getElementById('drawOfferMessage').textContent = 
                `${capitalize(resigningPlayer)} offers a draw. ${capitalize(otherPlayer)}, do you accept?`;
            document.getElementById('drawOfferModal').classList.add('show');
        }

        function acceptDraw() {
            document.getElementById('drawOfferModal').classList.remove('show');
            
            // Notify opponent
            if (onlineMode) {
                sendOnlineMessage({ type: 'drawAccept' });
            }
            
            endGame('draw', 'Game drawn by agreement!');
            resigningPlayer = null;
        }

        function declineDraw() {
            document.getElementById('drawOfferModal').classList.remove('show');
            
            // Notify opponent
            if (onlineMode) {
                sendOnlineMessage({ type: 'drawDecline' });
            }
            
            resigningPlayer = null;
        }

        function cancelResign() {
            document.getElementById('resignModal').classList.remove('show');
            resigningPlayer = null;
        }

        function toggleRules() {
            const modal = document.getElementById('rulesModal');
            if (modal.classList.contains('show')) {
                // Closing - reset to language selection for next open
                modal.classList.remove('show');
                document.getElementById('rulesLangSelect').style.display = 'block';
                document.getElementById('rulesContent').style.display = 'none';
            } else {
                // Opening - show language selection
                document.getElementById('rulesLangSelect').style.display = 'block';
                document.getElementById('rulesContent').style.display = 'none';
                modal.classList.add('show');
            }
        }
        
        function showRulesWithLang(lang) {
            setLanguage(lang);
            document.getElementById('rulesLangSelect').style.display = 'none';
            document.getElementById('rulesContent').style.display = 'block';
        }
        
        const aboutTranslations = {
            en: {
                text: "I've been working on this game with support from friends and family since 2017. Most of it came together within a year, some of it took longer to draw out. I hope others find as much joy and connection in playing it as I have found in making it.",
                contact: 'If you have thoughts about the game, feel free to drop me a line!<br><a href="mailto:jfkuang@proton.me" style="color: var(--gold);">jfkuang@proton.me</a>'
            },
            zh: {
                text: "è‡ª2017å¹´ä»¥æ¥ï¼Œæˆ‘ä¸€ç›´åœ¨æœ‹å‹å’Œå®¶äººçš„æ”¯æŒä¸‹å¼€å‘è¿™æ¬¾æ¸¸æˆã€‚å¤§éƒ¨åˆ†å†…å®¹åœ¨ä¸€å¹´å†…å®Œæˆï¼Œæœ‰äº›åˆ™èŠ±äº†æ›´é•¿æ—¶é—´æ‰é€æ¸æˆå½¢ã€‚æˆ‘å¸Œæœ›å…¶ä»–äººåœ¨æ¸¸æˆä¸­ä¹Ÿèƒ½æ‰¾åˆ°æˆ‘åœ¨åˆ›ä½œè¿‡ç¨‹ä¸­æ‰€æ„Ÿå—åˆ°çš„å¿«ä¹ä¸Žè¿žç»“ã€‚",
                contact: 'å¦‚æžœæ‚¨å¯¹æ¸¸æˆæœ‰ä»»ä½•æƒ³æ³•ï¼Œæ¬¢è¿Žè”ç³»æˆ‘ï¼<br><a href="mailto:jfkuang@proton.me" style="color: var(--gold);">jfkuang@proton.me</a>'
            },
            es: {
                text: "He estado trabajando en este juego con el apoyo de amigos y familiares desde 2017. La mayor parte se desarrollÃ³ en un aÃ±o, algunas cosas tardaron mÃ¡s en tomar forma. Espero que otros encuentren tanta alegrÃ­a y conexiÃ³n al jugarlo como yo he encontrado al crearlo.",
                contact: 'Â¡Si tienes comentarios sobre el juego, no dudes en escribirme!<br><a href="mailto:jfkuang@proton.me" style="color: var(--gold);">jfkuang@proton.me</a>'
            }
        };
        
        function showAbout() {
            // Show language selection first
            document.getElementById('aboutLangSelect').style.display = 'block';
            document.getElementById('aboutContent').style.display = 'none';
            document.getElementById('aboutModal').classList.add('show');
        }
        
        function showAboutWithLang(lang) {
            const trans = aboutTranslations[lang] || aboutTranslations.en;
            document.getElementById('aboutText').innerHTML = trans.text;
            document.getElementById('aboutContact').innerHTML = trans.contact;
            document.getElementById('aboutLangSelect').style.display = 'none';
            document.getElementById('aboutContent').style.display = 'block';
        }
        
        function closeAbout() {
            document.getElementById('aboutModal').classList.remove('show');
            // Reset to language selection for next open
            document.getElementById('aboutLangSelect').style.display = 'block';
            document.getElementById('aboutContent').style.display = 'none';
        }

        // Rules tab switching
        document.querySelectorAll('.rules-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active from all tabs and contents
                document.querySelectorAll('.rules-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.rules-tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active to clicked tab and corresponding content
                tab.classList.add('active');
                const tabName = tab.dataset.tab;
                document.getElementById(`rules-${tabName}`).classList.add('active');
            });
        });

        // === TUTORIAL ===
        const tutorialTotalCapsules = 16;

        // Tutorial scenarios for interactive capsules
        const tutorialScenarios = {
            // Capsule 4: Glyphs
            4: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Simple setup to practice glyph selection (dark pieces on light squares: row+col even)
                    board[6][0] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'white' };
                    board[6][2] = { type: 'golem', player: 'dark', shape: 'Î§', color: 'blue' };
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'orange' };
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î›' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Î©' }
                ],
                darkResting: { type: 'color', value: 'orange' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['select-golem-1', 'select-golem-2']
            },
            // Capsule 5: Steps
            5: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // One dark piece to move, one light piece blocking one direction
                    board[4][4] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'white' };  // e4 - piece to move
                    board[3][4] = { type: 'golem', player: 'light', shape: 'Î§', color: 'blue' };  // e5 - blocker (blocks ortho step north)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î›' },
                    { type: 'color', value: 'white' },
                    { type: 'shape', value: 'Î©' },
                ],
                darkResting: { type: 'color', value: 'orange' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['ortho-step', 'diag-step']
            },
            // Capsule 6: Single Jump
            6: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Simple setup for a single forward jump (dark on light squares: row+col even)
                    // f3 = [5][5], d3 = [5][3], e4 = [4][4]
                    board[5][5] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'white' };  // f3 (5+5=10 even)
                    board[5][3] = { type: 'golem', player: 'dark', shape: 'Î§', color: 'blue' };   // d3 (5+3=8 even)
                    board[4][4] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'orange' }; // e4 - jumper (4+4=8 even)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î©' },
                    { type: 'color', value: 'orange' },
                    { type: 'shape', value: 'Î§' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['single-jump']
            },
            // Capsule 7: Multi-Piece Jump
            7: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Setup for jumping over multiple contiguous pieces (dark on light squares: row+col even)
                    // f1 = [7][5], e2 = [6][4], d3 = [5][3], c4 = [4][2]
                    // Diagonal line: jumper at f1 jumps over e2, d3 to land beyond c4
                    board[7][5] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'orange' }; // f1 - jumper (7+5=12 even)
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'white' };  // e2 (6+4=10 even)
                    board[5][3] = { type: 'golem', player: 'dark', shape: 'Î§', color: 'blue' };   // d3 (5+3=8 even)
                    board[4][2] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'blue' };   // c4 (4+2=6 even)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î©' },
                    { type: 'color', value: 'orange' },
                    { type: 'shape', value: 'Î§' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['multi-piece-jump']
            },
            // Capsule 8: Chain Jumps
            8: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // h1=[7][7] blue/peak jumper, all other pieces are shadows
                    // g2=[6][6], e2=[6][4], c2=[6][2], c4=[4][2], d5=[3][3]
                    board[7][7] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'blue' };   // h1 - the only golem
                    board[6][6] = { type: 'shadow', player: 'dark' };  // g2
                    board[6][4] = { type: 'shadow', player: 'dark' };  // e2
                    board[6][2] = { type: 'shadow', player: 'dark' };  // c2
                    board[4][2] = { type: 'shadow', player: 'dark' };  // c4
                    board[3][3] = { type: 'shadow', player: 'dark' };  // d5
                    return board;
                },
                darkHand: [
                    { type: 'mirror', value: 'â—‡' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Î›' }
                ],
                darkResting: { type: 'color', value: 'orange' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 0, masks: [] },  // No shadows left to place
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['chain-jump']
            },
            // Capsule 9: Winning
            9: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // a6 = [2][0], b7 = [1][1] shadow, f7 = [1][5]
                    board[2][0] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'orange' }; // a6 - can jump to win (2+0=2 even)
                    board[1][1] = { type: 'shadow', player: 'dark' };  // b7 - shadow to jump over (1+1=2 even)
                    board[1][5] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'white' };  // f7 - one step from victory (1+5=6 even)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î©' },
                    { type: 'color', value: 'orange' },
                    { type: 'shape', value: 'Î›' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 0, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['reach-goal']
            },
            // Capsule 10: Capturing
            10: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Light piece ready to be captured (light on dark: row+col odd, dark on light: row+col even)
                    board[4][3] = { type: 'golem', player: 'light', shape: 'Î©', color: 'orange' }; // Target (4+3=7 odd=dark square)
                    board[4][2] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'orange' }; // Support (4+2=6 even=light square)
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Î§', color: 'blue' }; // Capturer (6+4=10 even=light square)
                    board[7][3] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'white' }; // Extra (7+3=10 even=light square)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î§' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Î©' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['capture']
            },
            // Capsule 11: Double Capture with Immunity
            11: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Dark Î§/blue moves to capture two light pieces, but third is immune (shares blue)
                    // Dark piece at e2 [6][4] moves to e4 [4][4] to sandwich two pieces
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Î§', color: 'blue' };   // Capturer (6+4=10 even)
                    board[4][2] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'white' };  // Support left (4+2=6 even)
                    board[4][6] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'orange' }; // Support right (4+6=10 even)
                    board[2][4] = { type: 'golem', player: 'dark', shape: 'Î›', color: 'orange' }; // Support top (2+4=6 even)
                    // Light pieces to be captured (on dark squares: row+col odd)
                    board[4][3] = { type: 'golem', player: 'light', shape: 'Î©', color: 'orange' }; // Will be captured (4+3=7 odd)
                    board[4][5] = { type: 'golem', player: 'light', shape: 'Î›', color: 'white' };  // Will be captured (4+5=9 odd)
                    board[3][4] = { type: 'golem', player: 'light', shape: 'Î©', color: 'blue' };   // IMMUNE - shares blue (3+4=7 odd)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î§' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Î©' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['double-capture']
            },
            // Capsule 12: Safe Movement
            12: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Dark Î§/blue can move between two light pieces safely because it shares blue with one
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Î§', color: 'blue' };   // Mover (6+4=10 even)
                    // Light pieces that would sandwich but can't capture (one shares blue)
                    board[4][3] = { type: 'golem', player: 'light', shape: 'Î©', color: 'blue' };  // Shares blue - immune! (4+3=7 odd)
                    board[4][5] = { type: 'golem', player: 'light', shape: 'Î›', color: 'orange' }; // (4+5=9 odd)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î§' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Î©' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['safe-move']
            },
            // Capsule 13: Shadows
            13: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // d3 = [5][3] golem, e2 = [6][4] shadow, c2 = [6][2] shadow
                    board[5][3] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'orange' }; // d3 - the only moveable piece (5+3=8 even)
                    board[6][4] = { type: 'shadow', player: 'dark' };  // e2 (6+4=10 even)
                    board[6][2] = { type: 'shadow', player: 'dark' };  // c2 (6+2=8 even)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î©' },
                    { type: 'color', value: 'orange' },
                    { type: 'shape', value: 'Î§' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                lightHasPlacedShadow: true, // Allow dark to place shadows
                shadowPrimed: true, // Preset the shadow toggle to on
                currentPlayer: 'dark',
                objectives: ['shadow-place']
            },
            // Capsule 14: Reactivation
            14: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Shadow on board (light square for dark: row+col even), mask in supply
                    board[5][1] = { type: 'shadow', player: 'dark' }; // 5+1=6 even=light square
                    board[7][3] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'orange' }; // 7+3=10 even=light square
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î›' },
                    { type: 'color', value: 'white' },
                    { type: 'shape', value: 'Î©' }
                ],
                darkResting: { type: 'shape', value: 'Î›' }, // Matches mask shape
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 0, masks: [{ shape: 'Î›', color: 'white' }] }, // Mask matches Î› + white
                lightSupply: { shadows: 1, masks: [] },
                lightHasPlacedShadow: true,
                currentPlayer: 'dark',
                objectives: ['reactivate']
            },
            // Capsule 15: Reactivation Capture
            15: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Shadow at e4 [4][4], support at e2 [6][4], light target at e3 [5][4]
                    // When mask reactivates on shadow, it sandwiches and captures the light piece
                    board[4][4] = { type: 'shadow', player: 'dark' }; // e4 - shadow to reactivate on (4+4=8 even)
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Î©', color: 'orange' }; // e2 - support (6+4=10 even)
                    board[5][4] = { type: 'golem', player: 'light', shape: 'Î§', color: 'blue' }; // e3 - target (5+4=9 odd)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Î›' },
                    { type: 'color', value: 'white' },
                    { type: 'shape', value: 'Î©' }
                ],
                darkResting: { type: 'shape', value: 'Î›' }, // Matches mask shape
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 0, masks: [{ shape: 'Î›', color: 'white' }] }, // Mask matches Î› + white
                lightSupply: { shadows: 1, masks: [] },
                lightHasPlacedShadow: true,
                currentPlayer: 'dark',
                objectives: ['reactivate-capture']
            }
        };

        function createEmptyBoard() {
            return Array(8).fill(null).map(() => Array(8).fill(null));
        }

        function openTutorial() {
            // Show language selection first
            document.getElementById('tutorialLangSelect').style.display = 'block';
            document.getElementById('tutorialNav').style.display = 'none';
            document.getElementById('tutorialCapsules').style.display = 'none';
            document.getElementById('tutorialModal').classList.add('show');
        }
        
        function startTutorialWithLang(lang) {
            // Apply language
            setLanguage(lang);
            
            // Hide language selection, show tutorial content
            document.getElementById('tutorialLangSelect').style.display = 'none';
            document.getElementById('tutorialNav').style.display = 'flex';
            document.getElementById('tutorialCapsules').style.display = 'block';
            
            // Initialize tutorial
            tutorialCurrentCapsule = 1;
            tutorialMode = true;
            
            // Stop the clock
            if (gameState.clockInterval) {
                clearInterval(gameState.clockInterval);
            }
            
            // Save current game state
            tutorialSavedState = JSON.parse(JSON.stringify(gameState));
            // Can't stringify the interval, save it separately
            tutorialSavedState.clockInterval = gameState.clockInterval;
            
            updateTutorialDisplay();
        }

        function closeTutorial() {
            document.getElementById('tutorialModal').classList.remove('show');
            document.getElementById('tutorialConsole').classList.remove('show');
            document.querySelector('.game-area').classList.remove('tutorial-active');
            
            // Reset language selector visibility for next open
            document.getElementById('tutorialLangSelect').style.display = 'block';
            document.getElementById('tutorialNav').style.display = 'none';
            document.getElementById('tutorialCapsules').style.display = 'none';
            
            tutorialMode = false;
            
            // Restore saved game state
            if (tutorialSavedState) {
                const savedClockInterval = tutorialSavedState.clockInterval;
                gameState = tutorialSavedState;
                tutorialSavedState = null;
                
                // Restart clock if game was timed and not over
                if (!gameState.noTimeLimit && !gameState.gameOver) {
                    startClock();
                }
                
                renderBoard();
                renderPanels();
            }
        }

        function tutorialNext() {
            if (tutorialCurrentCapsule < tutorialTotalCapsules) {
                tutorialCurrentCapsule++;
                updateTutorialDisplay();
            }
        }

        function tutorialPrev() {
            if (tutorialCurrentCapsule > 1) {
                tutorialCurrentCapsule--;
                updateTutorialDisplay();
            }
        }

        function updateTutorialDisplay() {
            // Update progress in modal
            document.getElementById('tutorialProgress').textContent = 
                `${tutorialCurrentCapsule} / ${tutorialTotalCapsules}`;
            
            // Update nav buttons in modal
            document.getElementById('tutorialPrev').disabled = tutorialCurrentCapsule === 1;
            document.getElementById('tutorialNext').disabled = tutorialCurrentCapsule === tutorialTotalCapsules;
            
            // Show current capsule, hide others in modal
            const capsules = document.querySelectorAll('.tutorial-capsule');
            capsules.forEach(capsule => {
                const capsuleNum = parseInt(capsule.dataset.capsule);
                if (capsuleNum === tutorialCurrentCapsule) {
                    capsule.classList.add('active');
                } else {
                    capsule.classList.remove('active');
                }
            });

            // Check if this is an interactive capsule
            const currentCapsule = document.querySelector(`.tutorial-capsule[data-capsule="${tutorialCurrentCapsule}"]`);
            const isInteractive = currentCapsule && currentCapsule.dataset.interactive === 'true';
            const tutorialConsole = document.getElementById('tutorialConsole');
            const gameArea = document.querySelector('.game-area');
            
            if (isInteractive && tutorialScenarios[tutorialCurrentCapsule]) {
                // Hide modal, show console
                document.getElementById('tutorialModal').classList.remove('show');
                tutorialConsole.classList.add('show');
                gameArea.classList.add('tutorial-active');
                
                // Update console content
                const title = currentCapsule.querySelector('h2').textContent;
                const body = currentCapsule.querySelector('.tutorial-body').innerHTML;
                document.getElementById('tutorialConsoleTitle').textContent = title;
                document.getElementById('tutorialConsoleBody').innerHTML = body;
                document.getElementById('tutorialConsoleProgress').textContent = 
                    `${tutorialCurrentCapsule} / ${tutorialTotalCapsules}`;
                
                loadTutorialScenario(tutorialCurrentCapsule);
            } else {
                // Show modal, hide console
                document.getElementById('tutorialModal').classList.add('show');
                tutorialConsole.classList.remove('show');
                gameArea.classList.remove('tutorial-active');
            }
        }

        function loadTutorialScenario(capsuleNum) {
            const scenario = tutorialScenarios[capsuleNum];
            if (!scenario) return;

            // Create fresh board and apply setup
            const board = createEmptyBoard();
            scenario.setup(board);

            // Set game state for tutorial
            gameState.board = board;
            gameState.currentPlayer = scenario.currentPlayer || 'dark';
            gameState.darkHand = JSON.parse(JSON.stringify(scenario.darkHand));
            gameState.lightHand = JSON.parse(JSON.stringify(scenario.lightHand));
            gameState.darkResting = scenario.darkResting ? JSON.parse(JSON.stringify(scenario.darkResting)) : null;
            gameState.lightResting = scenario.lightResting ? JSON.parse(JSON.stringify(scenario.lightResting)) : null;
            gameState.darkSupply = JSON.parse(JSON.stringify(scenario.darkSupply));
            gameState.lightSupply = JSON.parse(JSON.stringify(scenario.lightSupply));
            gameState.lightHasPlacedShadow = scenario.lightHasPlacedShadow || false;
            gameState.selectedGlyph = null;
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.shadowPrimed = scenario.shadowPrimed || false;
            gameState.gameOver = false;
            gameState.winner = null;

            // Disable CPU and timers for tutorial
            cpuMode = false;
            spectateMode = false;
            gameState.noTimeLimit = true;

            // Initialize objectives for this scenario
            if (scenario.objectives) {
                tutorialObjectives = {};
                scenario.objectives.forEach(obj => tutorialObjectives[obj] = false);
                // Reset golem tracking for Glyphs tutorial
                tutorialSelectedGolems.clear();
                updateTutorialChecklist();
                checkAllObjectivesComplete();
            }

            renderGame();
        }

        function resetTutorialScenario() {
            // Reset objectives for this capsule
            const scenario = tutorialScenarios[tutorialCurrentCapsule];
            if (scenario && scenario.objectives) {
                tutorialObjectives = {};
                scenario.objectives.forEach(obj => tutorialObjectives[obj] = false);
                updateTutorialChecklist();
            }
            // Reset golem tracking for Glyphs tutorial
            tutorialSelectedGolems.clear();
            loadTutorialScenario(tutorialCurrentCapsule);
        }

        function checkTutorialMoveObjective(fromRow, fromCol, toRow, toCol) {
            if (tutorialCurrentCapsule !== 5) return; // Only for Steps capsule
            
            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;
            const absRowDiff = Math.abs(rowDiff);
            const absColDiff = Math.abs(colDiff);
            
            // Diagonal step: exactly 1 square diagonal
            if (absRowDiff === 1 && absColDiff === 1) {
                completeTutorialObjective('diag-step');
            }
            // Orthogonal step: exactly 2 squares in one direction
            else if ((absRowDiff === 2 && absColDiff === 0) || (absRowDiff === 0 && absColDiff === 2)) {
                completeTutorialObjective('ortho-step');
            }
        }

        function checkTutorialCaptureObjective(captureCount) {
            if (tutorialCurrentCapsule === 10) {
                completeTutorialObjective('capture');
            } else if (tutorialCurrentCapsule === 11 && captureCount >= 2) {
                completeTutorialObjective('double-capture');
            }
        }

        function checkTutorialShadowObjective() {
            if (tutorialCurrentCapsule === 13) {
                completeTutorialObjective('shadow-place');
            }
        }

        function checkTutorialSafeMoveObjective(toRow, toCol) {
            // Capsule 12: Check if dark moved between two enemy pieces without being captured
            if (tutorialCurrentCapsule === 12) {
                // Check if there are enemy pieces on opposite sides
                const board = gameState.board;
                const hasLeftEnemy = toCol > 0 && board[toRow][toCol - 1]?.player === 'light';
                const hasRightEnemy = toCol < 7 && board[toRow][toCol + 1]?.player === 'light';
                const hasTopEnemy = toRow > 0 && board[toRow - 1][toCol]?.player === 'light';
                const hasBottomEnemy = toRow < 7 && board[toRow + 1][toCol]?.player === 'light';
                
                // If sandwiched horizontally or vertically by enemies (but not captured), it's a safe move
                if ((hasLeftEnemy && hasRightEnemy) || (hasTopEnemy && hasBottomEnemy)) {
                    completeTutorialObjective('safe-move');
                }
            }
        }

        function checkTutorialJumpObjective(fromRow, fromCol, toRow, toCol, piecesJumped, emptySquares, squaresTraveled) {
            // Must be a diagonal jump (more than 1 square)
            if (squaresTraveled < 2) return;
            
            // Capsule 6: Single jump forward (over 1 piece, moving toward row 0)
            if (tutorialCurrentCapsule === 6) {
                // Single jump = 2 squares traveled, over 1 piece, moving forward (row decreases for dark)
                if (squaresTraveled === 2 && piecesJumped === 1 && toRow < fromRow) {
                    completeTutorialObjective('single-jump');
                }
            }
            // Capsule 7: Multi-piece jump - jumping over 2+ contiguous pieces in one hop
            else if (tutorialCurrentCapsule === 7) {
                // Setup: f1=[7][5] jumps over e2, d3, c4 to land at b5=[3][1]
                const fromF1 = (fromRow === 7 && fromCol === 5);
                const toB5 = (toRow === 3 && toCol === 1);
                
                if (fromF1 && toB5) {
                    completeTutorialObjective('multi-piece-jump');
                }
            }
            // Capsule 8: Chain jump - multiple hops with direction changes
            else if (tutorialCurrentCapsule === 8) {
                // Valid chain jump destinations from h1=[7][7]:
                // h1 to d1=[7][3], b3=[5][1], e6=[2][4]
                // Also from intermediate positions after first hop
                const fromH1 = (fromRow === 7 && fromCol === 7);
                
                const toD1 = (toRow === 7 && toCol === 3);
                const toB3 = (toRow === 5 && toCol === 1);
                const toE6 = (toRow === 2 && toCol === 4);
                
                // Any of these destinations from h1 counts as a chain jump
                if (fromH1 && (toD1 || toB3 || toE6)) {
                    completeTutorialObjective('chain-jump');
                }
                // Also pass if emptySquares > 0 or traveled far (generic chain detection)
                else if (emptySquares > 0 || squaresTraveled >= 4) {
                    completeTutorialObjective('chain-jump');
                }
            }
        }

        function checkGlyphTutorialGolemSelection(row, col) {
            // Track unique golems selected (no need to check for glyph)
            const key = `${row},${col}`;
            tutorialSelectedGolems.add(key);
            
            if (tutorialSelectedGolems.size >= 1) {
                completeTutorialObjective('select-golem-1');
            }
            if (tutorialSelectedGolems.size >= 2) {
                completeTutorialObjective('select-golem-2');
            }
        }

        function completeTutorialObjective(objectiveId) {
            if (tutorialObjectives[objectiveId] === false) {
                tutorialObjectives[objectiveId] = true;
                updateTutorialChecklist();
                checkAllObjectivesComplete();
            }
        }

        function updateTutorialChecklist() {
            const items = document.querySelectorAll('.tutorial-checklist li');
            items.forEach(item => {
                const obj = item.dataset.objective;
                if (tutorialObjectives[obj]) {
                    item.classList.add('completed');
                    item.textContent = item.textContent.replace('â˜', 'â˜‘');
                } else {
                    item.classList.remove('completed');
                    item.textContent = item.textContent.replace('â˜‘', 'â˜');
                }
            });
        }

        function checkAllObjectivesComplete() {
            const allComplete = Object.values(tutorialObjectives).every(v => v === true);
            
            // Update both possible continue buttons
            const modalBtn = document.getElementById('tutorialContinueBtn');
            const consoleBtn = document.getElementById('tutorialConsoleContinue');
            
            if (modalBtn) modalBtn.disabled = !allComplete;
            if (consoleBtn) consoleBtn.disabled = !allComplete;
            
            // Auto-continue after a delay when all objectives complete
            if (allComplete && Object.keys(tutorialObjectives).length > 0) {
                setTimeout(() => {
                    // Verify still complete (user might have reset)
                    const stillComplete = Object.values(tutorialObjectives).every(v => v === true);
                    if (stillComplete && tutorialMode) {
                        tutorialNext();
                    }
                }, 1500);
            }
        }

        function toggleHistoryPanel() {
            const header = document.getElementById('historyHeader');
            const body = document.getElementById('historyBody');
            header.classList.toggle('expanded');
            body.classList.toggle('expanded');
        }

        function toggleMenu() {
            const btn = document.getElementById('menuBtn');
            const dropdown = document.getElementById('menuDropdown');
            btn.classList.toggle('open');
            dropdown.classList.toggle('open');
        }

        function closeMenu() {
            const btn = document.getElementById('menuBtn');
            const dropdown = document.getElementById('menuDropdown');
            btn.classList.remove('open');
            dropdown.classList.remove('open');
        }

        // === ANALYSIS CONSOLE ===
        function showAnalysisUI() {
            analysisData.isAnalysisMode = true;
            analysisData.currentMoveIndex = analysisData.moves.length - 1;
            
            document.getElementById('analysisRibbon').classList.add('show');
            document.getElementById('moveHistoryPanel').classList.add('show');
            document.getElementById('board').classList.add('analysis-mode');
            
            // Clear filename since this is from a live game
            document.getElementById('analysisFilename').textContent = '';
            
            renderAnalysisRibbon();
            renderMoveHistory();
            goToMove(analysisData.currentMoveIndex);
        }
        
        function hideAnalysisUI() {
            analysisData.isAnalysisMode = false;
            lastGoToMoveIndex = null; // Reset so next analysis session works properly
            isNavigating = false;
            
            document.getElementById('analysisRibbon').classList.remove('show');
            document.getElementById('moveHistoryPanel').classList.remove('show');
            document.getElementById('board').classList.remove('analysis-mode');
            
            // Clear filename
            document.getElementById('analysisFilename').textContent = '';
        }
        
        function playFromHere() {
            // Current board state is already set from analysis navigation
            // Just need to reset game state flags and exit analysis mode
            
            // Clear the clock interval if any
            if (gameState.clockInterval) {
                clearInterval(gameState.clockInterval);
                gameState.clockInterval = null;
            }
            
            // Set up for timeless play
            gameState.gameOver = false;
            gameState.isPaused = false;
            gameState.noTimeLimit = true;
            gameState.darkTime = 0;
            gameState.lightTime = 0;
            gameState.lastMoveTime = Date.now();
            
            // Clear selections
            gameState.selectedGlyph = null;
            gameState.selectedPiece = null;
            gameState.selectedMask = null;
            gameState.shadowPrimed = false;
            
            // Reset history stack for new branch
            historyStack = [];
            
            // Reset analysis data for fresh recording from this point
            analysisData.initialState = serializeGameState();
            analysisData.moves = [];
            analysisData.currentMoveIndex = -1;
            
            // Hide analysis UI
            hideAnalysisUI();
            
            // Update clocks to show unlimited
            renderClocks();
            
            // Render the game
            renderGame();
        }
        
        let analysisRibbonDelegationAttached = false;
        
        function renderAnalysisRibbon() {
            const container = document.getElementById('ribbonMoves');
            
            // Build all HTML at once to minimize reflows
            let html = '';
            
            // Add "Start" marker
            html += `<button class="ribbon-move${analysisData.currentMoveIndex === -1 ? ' active' : ''}" data-move-index="-1">Start</button>`;
            
            analysisData.moves.forEach((move, index) => {
                const pieceColor = move.type === 'reactivation' ? move.mask.color : move.piece.color;
                const pieceShape = move.type === 'reactivation' ? move.mask.shape : move.piece.shape;
                const clockTime = move.player === 'dark' ? move.darkClock : move.lightClock;
                const isActive = index === analysisData.currentMoveIndex ? ' active' : '';
                
                html += `<button class="ribbon-move ${move.player}-move${isActive}" data-move-index="${index}">
                    <span class="ribbon-move-num">${index + 1}.</span>
                    <span class="piece-icon ${move.player}-piece">
                        <span style="color: ${getColorValue(pieceColor)}">${pieceShape}</span>
                    </span>
                    <span class="ribbon-coords">${getMoveCoords(move)}</span>
                    <span class="ribbon-glyph">[${getGlyphHTML(move.glyphUsed)}]</span>
                    ${formatCapturesCompact(move.captures)}
                    <span class="ribbon-time">${formatClockForAnalysis(clockTime)}</span>
                </button>`;
            });
            
            // Single DOM update
            container.innerHTML = html;
            
            // Attach event delegation ONCE, not on every render
            if (!analysisRibbonDelegationAttached) {
                container.addEventListener('click', function(e) {
                    const btn = e.target.closest('.ribbon-move');
                    if (btn && btn.dataset.moveIndex !== undefined) {
                        e.stopPropagation();
                        goToMove(parseInt(btn.dataset.moveIndex, 10));
                    }
                });
                analysisRibbonDelegationAttached = true;
            }
            
            // Scroll active move into view with requestAnimationFrame to avoid blocking
            requestAnimationFrame(() => {
                const activeMove = container.querySelector('.ribbon-move.active');
                if (activeMove) {
                    activeMove.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'nearest' });
                }
            });
        }
        
        let moveHistoryDelegationAttached = false;
        
        function renderMoveHistory() {
            const container = document.getElementById('historyList');
            
            // Build all HTML at once to minimize reflows
            let html = '';
            
            analysisData.moves.forEach((move, index) => {
                const pieceColor = move.type === 'reactivation' ? move.mask.color : move.piece.color;
                const pieceShape = move.type === 'reactivation' ? move.mask.shape : move.piece.shape;
                const clockTime = move.player === 'dark' ? move.darkClock : move.lightClock;
                const isActive = index === analysisData.currentMoveIndex ? ' active' : '';
                
                html += `<div class="history-move ${move.player}-move${isActive}" data-move-index="${index}">
                    <span class="move-number">${index + 1}.</span>
                    <span class="piece-icon ${move.player}-piece">
                        <span style="color: ${getColorValue(pieceColor)}">${pieceShape}</span>
                    </span>
                    <span class="move-notation">${formatMoveNotation(move)}</span>
                    <span class="glyph-indicator">[${getGlyphHTML(move.glyphUsed)}]</span>
                    ${formatCapturesForHistory(move)}
                    <span class="move-time">${formatClockForAnalysis(clockTime)}</span>
                </div>`;
            });
            
            // Single DOM update
            container.innerHTML = html;
            
            // Attach event delegation ONCE, not on every render
            if (!moveHistoryDelegationAttached) {
                container.addEventListener('click', function(e) {
                    const div = e.target.closest('.history-move');
                    if (div && div.dataset.moveIndex !== undefined) {
                        e.stopPropagation();
                        goToMove(parseInt(div.dataset.moveIndex, 10));
                    }
                });
                moveHistoryDelegationAttached = true;
            }
            
            // Scroll active move into view - use requestAnimationFrame and 'auto' behavior
            requestAnimationFrame(() => {
                const activeMove = container.querySelector('.history-move.active');
                if (activeMove) {
                    activeMove.scrollIntoView({ behavior: 'auto', block: 'nearest' });
                }
            });
        }
        
        function formatCapturesCompact(captures) {
            if (!captures || captures.length === 0) return '';
            
            // Separate shadows from golems
            const shadowCaptures = captures.filter(c => c.piece.type === 'shadow');
            const golemCaptures = captures.filter(c => c.piece.type !== 'shadow');
            
            let html = '<span class="capture-icons">Ã—';
            
            // Show captured golems
            golemCaptures.forEach(c => {
                html += `<span style="color: ${getColorValue(c.piece.color)}">${c.piece.shape}</span>`;
            });
            
            // Show shadow count if any
            if (shadowCaptures.length > 0) {
                html += `<span class="shadow-capture">â—Œ${shadowCaptures.length > 1 ? shadowCaptures.length : ''}</span>`;
            }
            
            html += '</span>';
            return html;
        }
        
        function formatCapturesForHistory(move) {
            if (!move.captures || move.captures.length === 0) return '';
            
            // Separate shadows from golems
            const shadowCaptures = move.captures.filter(c => c.piece.type === 'shadow');
            const golemCaptures = move.captures.filter(c => c.piece.type !== 'shadow');
            
            let html = '<span class="capture-display">Ã—';
            
            // Show captured golems with their piece icons
            golemCaptures.forEach(c => {
                const opponentPlayer = move.player === 'dark' ? 'light' : 'dark';
                html += `<span class="piece-icon ${opponentPlayer}-piece captured-piece">
                    <span style="color: ${getColorValue(c.piece.color)}">${c.piece.shape}</span>
                </span>`;
            });
            
            // Show shadow count if any
            if (shadowCaptures.length > 0) {
                const opponentPlayer = move.player === 'dark' ? 'light' : 'dark';
                html += `<span class="shadow-capture-icon ${opponentPlayer}-shadow-icon">â—Œ${shadowCaptures.length > 1 ? shadowCaptures.length : ''}</span>`;
            }
            
            html += '</span>';
            return html;
        }
        
        function getGlyphSymbol(glyph) {
            if (glyph.type === 'mirror') return 'â—‡';
            if (glyph.type === 'shape') return glyph.value;
            if (glyph.type === 'color') {
                const colorSymbols = { white: 'â—‹', orange: 'â—', blue: 'â—' };
                return colorSymbols[glyph.value] || glyph.value;
            }
            return '?';
        }
        
        function getGlyphHTML(glyph) {
            if (!glyph) return '?';
            if (glyph.type === 'mirror') {
                return '<span style="color: #c0c0c8;">â—‡</span>';
            }
            if (glyph.type === 'shape') {
                return `<span style="color: var(--pearl);">${glyph.value}</span>`;
            }
            if (glyph.type === 'color') {
                // Show a filled circle in the glyph's color
                return `<span style="color: ${getColorValue(glyph.value)};">â—</span>`;
            }
            return '?';
        }
        
        function formatClockForAnalysis(seconds) {
            if (seconds === undefined || seconds === null) return '--:--';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const tenths = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${tenths}`;
        }
        
        function getMoveCoords(move) {
            const colLabels = 'abcdefgh';
            if (move.type === 'reactivation') {
                const pos = `${colLabels[move.position.col]}${8 - move.position.row}`;
                return `@${pos}`;
            }
            const from = `${colLabels[move.from.col]}${8 - move.from.row}`;
            const to = `${colLabels[move.to.col]}${8 - move.to.row}`;
            return `${from}â†’${to}`;
        }
        
        function formatMoveNotation(move) {
            const colLabels = 'abcdefgh';
            
            if (move.type === 'reactivation') {
                const pos = `${colLabels[move.position.col]}${8 - move.position.row}`;
                return `â†‘@${pos}`;
            }
            
            const from = `${colLabels[move.from.col]}${8 - move.from.row}`;
            const to = `${colLabels[move.to.col]}${8 - move.to.row}`;
            let notation = `${from}â†’${to}`;
            
            // Add shadow placed indicator
            if (move.shadowPlaced) {
                notation += ' +â—Œ';
            }
            
            return notation;
        }
        
        let goToMoveTimeout = null;
        let lastGoToMoveIndex = null;
        let isNavigating = false;
        
        function goToMove(index) {
            // Clamp index
            index = Math.max(-1, Math.min(index, analysisData.moves.length - 1));
            
            // Skip if same index (but allow after arrow keys reset this)
            if (index === lastGoToMoveIndex) return;
            lastGoToMoveIndex = index;
            
            analysisData.currentMoveIndex = index;
            
            // If already navigating, just update the target index - the pending frame will use it
            if (isNavigating) {
                return;
            }
            
            isNavigating = true;
            
            // Debounce rapid clicks - cancel pending render and schedule new one
            if (goToMoveTimeout) {
                cancelAnimationFrame(goToMoveTimeout);
            }
            
            goToMoveTimeout = requestAnimationFrame(() => {
                // Use the latest index that was set
                const targetIndex = analysisData.currentMoveIndex;
                
                // Reconstruct game state at this point
                reconstructStateAtMove(targetIndex);
                
                // Update clock displays for analysis mode
                updateAnalysisClocks(targetIndex);
                
                // Update UI
                renderAnalysisRibbon();
                renderMoveHistory();
                renderGame();
                
                goToMoveTimeout = null;
                isNavigating = false;
            });
        }
        
        function updateAnalysisClocks(moveIndex) {
            const darkClock = document.getElementById('darkClock');
            const lightClock = document.getElementById('lightClock');
            
            // Check if the game had no time limit
            if (analysisData.initialState && analysisData.initialState.noTimeLimit) {
                darkClock.textContent = 'âˆž';
                lightClock.textContent = 'âˆž';
                darkClock.classList.remove('warning');
                lightClock.classList.remove('warning');
                return;
            }
            
            if (moveIndex < 0) {
                // At start position - show initial times
                darkClock.textContent = formatClockForAnalysis(analysisData.initialState?.darkTime);
                lightClock.textContent = formatClockForAnalysis(analysisData.initialState?.lightTime);
            } else {
                const move = analysisData.moves[moveIndex];
                if (move.darkClock !== undefined && move.lightClock !== undefined) {
                    darkClock.textContent = formatClockForAnalysis(move.darkClock);
                    lightClock.textContent = formatClockForAnalysis(move.lightClock);
                }
            }
            
            darkClock.classList.remove('warning');
            lightClock.classList.remove('warning');
        }
        
        function reconstructStateAtMove(targetIndex) {
            // Start from initial state
            const initial = analysisData.initialState;
            
            gameState.board = initial.board.map(row => row.map(cell => cell ? {...cell} : null));
            gameState.currentPlayer = initial.currentPlayer;
            gameState.darkHand = initial.darkHand.map(g => ({...g}));
            gameState.lightHand = initial.lightHand.map(g => ({...g}));
            gameState.darkResting = initial.darkResting ? {...initial.darkResting} : null;
            gameState.lightResting = initial.lightResting ? {...initial.lightResting} : null;
            gameState.darkSupply = {
                shadows: initial.darkSupply.shadows,
                masks: initial.darkSupply.masks.map(m => ({...m}))
            };
            gameState.lightSupply = {
                shadows: initial.lightSupply.shadows,
                masks: initial.lightSupply.masks.map(m => ({...m}))
            };
            gameState.lightHasPlacedShadow = initial.lightHasPlacedShadow;
            gameState.darkLives = initial.darkLives !== undefined ? initial.darkLives : 1;
            gameState.lightLives = initial.lightLives !== undefined ? initial.lightLives : 1;
            gameState.lastMove = null;
            
            // Replay moves up to target index
            for (let i = 0; i <= targetIndex; i++) {
                replayMove(analysisData.moves[i]);
            }
        }
        
        function replayMove(move) {
            const player = move.player;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            
            if (move.type === 'movement') {
                // Move piece
                const piece = gameState.board[move.from.row][move.from.col];
                gameState.board[move.to.row][move.to.col] = piece;
                gameState.board[move.from.row][move.from.col] = null;
                
                gameState.lastMove = { 
                    fromRow: move.from.row, 
                    fromCol: move.from.col, 
                    toRow: move.to.row, 
                    toCol: move.to.col 
                };
                
                // Handle captures
                if (move.captures) {
                    for (const capture of move.captures) {
                        const capturedPiece = gameState.board[capture.position.row][capture.position.col];
                        gameState.board[capture.position.row][capture.position.col] = null;
                        
                        if (capturedPiece && capturedPiece.type !== 'shadow') {
                            const capturedSupply = capturedPiece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                            capturedSupply.shadows++;
                            capturedSupply.masks.push({ shape: capturedPiece.shape, color: capturedPiece.color });
                        }
                    }
                    
                    // Handle shadow cascade
                    const cascadePlayers = new Set(move.captures.filter(c => c.shadowCascade).map(c => c.piece.player));
                    for (const cascadePlayer of cascadePlayers) {
                        const cascadeSupply = cascadePlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 8; c++) {
                                const p = gameState.board[r][c];
                                if (p?.type === 'shadow' && p.player === cascadePlayer) {
                                    gameState.board[r][c] = null;
                                    cascadeSupply.shadows++;
                                }
                            }
                        }
                    }
                }
                
                // Place shadow
                if (move.shadowPlaced) {
                    gameState.board[move.shadowPlaced.row][move.shadowPlaced.col] = { type: 'shadow', player };
                    supply.shadows--;
                    if (player === 'light') {
                        gameState.lightHasPlacedShadow = true;
                    }
                }
                
                // Handle breakthrough (scoring)
                if (move.breakthrough && move.dismantled) {
                    // Remove golem from destination (it was dismantled)
                    gameState.board[move.to.row][move.to.col] = null;
                    // Add mask + shadow to scorer's supply
                    supply.masks.push({ shape: move.dismantled.shape, color: move.dismantled.color });
                    supply.shadows++;
                    // Decrement opponent's lives
                    const opponent = player === 'dark' ? 'light' : 'dark';
                    if (opponent === 'dark') {
                        gameState.darkLives--;
                    } else {
                        gameState.lightLives--;
                    }
                }
                
            } else if (move.type === 'reactivation') {
                // Place golem from mask
                gameState.board[move.position.row][move.position.col] = {
                    type: 'golem',
                    player,
                    shape: move.mask.shape,
                    color: move.mask.color
                };
                
                // Remove mask from supply
                const maskIndex = supply.masks.findIndex(m => 
                    m.shape === move.mask.shape && m.color === move.mask.color
                );
                if (maskIndex >= 0) {
                    supply.masks.splice(maskIndex, 1);
                }
                
                gameState.lastMove = { 
                    fromRow: move.position.row, 
                    fromCol: move.position.col, 
                    toRow: move.position.row, 
                    toCol: move.position.col 
                };
                
                // Handle captures from reactivation
                if (move.captures) {
                    for (const capture of move.captures) {
                        gameState.board[capture.position.row][capture.position.col] = null;
                    }
                }
            }
            
            // Handle glyph exchange
            const glyphIndex = hand.findIndex(g => 
                g.type === move.glyphUsed.type && g.value === move.glyphUsed.value
            );
            if (glyphIndex >= 0) {
                const usedGlyph = hand.splice(glyphIndex, 1)[0];
                
                // Pick up resting
                const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
                if (resting) {
                    hand.push(resting);
                }
                
                // Set opponent's resting
                if (player === 'dark') {
                    gameState.lightResting = usedGlyph;
                    gameState.darkResting = null;
                    gameState.currentPlayer = 'light';
                } else {
                    gameState.darkResting = usedGlyph;
                    gameState.lightResting = null;
                    gameState.currentPlayer = 'dark';
                }
            }
        }
        
        // === EXPORT / IMPORT ===
        function exportGameJSON() {
            // Determine game result
            let result = 'unknown';
            let resultReason = '';
            if (gameState.gameOver) {
                const victoryMsg = document.getElementById('victoryMessage').textContent;
                if (victoryMsg.includes('Dark')) {
                    result = 'dark';
                } else if (victoryMsg.includes('Light')) {
                    result = 'light';
                } else if (victoryMsg.includes('Draw') || victoryMsg.includes('draw')) {
                    result = 'draw';
                }
                resultReason = victoryMsg;
            }
            
            // Build export object
            const exportData = {
                format: 'inara-game',
                version: '1.0',
                exportedAt: new Date().toISOString(),
                game: {
                    date: new Date().toISOString().split('T')[0],
                    timeControl: analysisData.initialState.noTimeLimit 
                        ? 'unlimited' 
                        : `${Math.floor(analysisData.initialState.darkTime / 60)}+${gameState.increment || 0}`,
                    result: result,
                    resultReason: resultReason,
                    totalMoves: analysisData.moves.length,
                    gameMode: spectateMode ? 'spectate' : (cpuMode ? 'cpu' : 'human'),
                    cpuPlayer: cpuMode ? (spectateMode ? 'both' : cpuPlayer) : null
                },
                initialState: analysisData.initialState,
                moves: analysisData.moves
            };
            
            // Create and trigger download
            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const dateStr = new Date().toISOString().slice(0, 10);
            const timeStr = new Date().toTimeString().slice(0, 5).replace(':', '');
            a.download = `inara-${dateStr}-${timeStr}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function importGameJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate format
                    if (data.format !== 'inara-game') {
                        alert('Invalid file format. Please select an Inara game file.');
                        return;
                    }
                    
                    if (!data.initialState || !data.moves) {
                        alert('Invalid game file. Missing required data.');
                        return;
                    }
                    
                    // Stop any running game
                    if (gameState?.clockInterval) {
                        clearInterval(gameState.clockInterval);
                    }
                    
                    // Load the game data
                    analysisData.initialState = data.initialState;
                    analysisData.moves = data.moves;
                    analysisData.currentMoveIndex = data.moves.length - 1;
                    analysisData.isAnalysisMode = true;
                    
                    // Set game as over so clocks don't run
                    gameState = createInitialState();
                    gameState.gameOver = true;
                    
                    // Reset history stack
                    historyStack = [];
                    
                    // Hide new game modal if open
                    document.getElementById('newGameModal').classList.remove('show');
                    
                    // Show analysis UI
                    document.getElementById('analysisRibbon').classList.add('show');
                    document.getElementById('moveHistoryPanel').classList.add('show');
                    document.getElementById('board').classList.add('analysis-mode');
                    
                    // Show the filename
                    document.getElementById('analysisFilename').textContent = `ðŸ“ ${file.name}`;
                    
                    // Reconstruct final position
                    reconstructStateAtMove(analysisData.currentMoveIndex);
                    updateAnalysisClocks(analysisData.currentMoveIndex);
                    
                    renderAnalysisRibbon();
                    renderMoveHistory();
                    renderGame();
                    
                    // Show game info
                    const info = data.game;
                    console.log(`Loaded: ${info.date} | ${info.timeControl} | ${info.totalMoves} moves | Result: ${info.result}`);
                    
                } catch (err) {
                    console.error('Import error:', err);
                    alert('Failed to load game file. The file may be corrupted.');
                }
            };
            
            reader.readAsText(file);
            
            // Reset input so same file can be loaded again
            event.target.value = '';
        }
        
        // Keyboard navigation for analysis
        document.addEventListener('keydown', (e) => {
            if (!analysisData.isAnalysisMode) return;
            
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                lastGoToMoveIndex = null; // Allow navigation even to same index after arrow keys
                goToMove(analysisData.currentMoveIndex - 1);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                lastGoToMoveIndex = null;
                goToMove(analysisData.currentMoveIndex + 1);
            } else if (e.key === 'Home') {
                e.preventDefault();
                lastGoToMoveIndex = null;
                goToMove(-1);
            } else if (e.key === 'End') {
                e.preventDefault();
                lastGoToMoveIndex = null;
                goToMove(analysisData.moves.length - 1);
            }
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('menuDropdown');
            const btn = document.getElementById('menuBtn');
            if (!menu.contains(e.target) && !btn.contains(e.target)) {
                closeMenu();
            }
        });

        // Close modals on background click
        document.getElementById('rulesModal').addEventListener('click', (e) => {
            if (e.target.id === 'rulesModal') toggleRules();
        });
        
        document.getElementById('aboutModal').addEventListener('click', (e) => {
            if (e.target.id === 'aboutModal') closeAbout();
        });

        document.getElementById('tutorialModal').addEventListener('click', (e) => {
            if (e.target.id === 'tutorialModal') closeTutorial();
        });

        document.getElementById('victoryModal').addEventListener('click', (e) => {
            if (e.target.id === 'victoryModal') {
                document.getElementById('victoryModal').classList.remove('show');
            }
        });

        document.getElementById('resignModal').addEventListener('click', (e) => {
            if (e.target.id === 'resignModal') {
                cancelResign();
            }
        });

        document.getElementById('drawOfferModal').addEventListener('click', (e) => {
            if (e.target.id === 'drawOfferModal') {
                declineDraw();
            }
        });

        document.getElementById('newGameModal').addEventListener('click', (e) => {
            if (e.target.id === 'newGameModal') {
                document.getElementById('newGameModal').classList.remove('show');
            }
        });

        // Try to lock screen orientation to portrait on mobile
        if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('portrait').catch(() => {
                // Orientation lock not supported or denied - that's okay
            });
        }
        
        // Handle page visibility changes - reconnect peer if needed
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && peer && !peer.destroyed && peer.disconnected) {
                console.log('Page visible again, reconnecting peer...');
                peer.reconnect();
            }
        });

        // Fix zoom issues on orientation change
        window.addEventListener('orientationchange', () => {
            // Reset any zoom by forcing viewport recalculation
            const viewport = document.querySelector('meta[name="viewport"]');
            viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
            
            // Force layout recalculation
            setTimeout(() => {
                window.scrollTo(0, 0);
                document.body.style.display = 'none';
                document.body.offsetHeight; // Force reflow
                document.body.style.display = '';
            }, 100);
        });

        // Initialize on load - render board, menu accessible
        // User can access menu, tutorial, rules before starting a game
        initGame();
        loadLanguagePreference();
        
        // Check for room code in URL and auto-join
        (function checkUrlForRoom() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');
            
            if (roomCode) {
                // Close welcome modal if open
                closeWelcome();
                
                // Set a default guest name for auto-join
                localPlayerName = 'GUEST';
                
                // Open online modal and auto-join
                const modal = document.getElementById('onlineModal');
                modal.classList.add('show');
                showOnlineJoining();
                
                // Clear the URL parameter so refresh doesn't re-join
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Initialize peer, then auto-join
                peer = new Peer();
                
                // Set a timeout for the whole process
                const joinTimeout = setTimeout(() => {
                    console.log('Auto-join timeout');
                    showOnlineError('Could not connect to game. The host may have left.');
                }, 20000); // 20 second timeout
                
                peer.on('open', () => {
                    console.log('Connected to PeerJS, auto-joining room:', roomCode);
                    
                    isHost = false;
                    localPlayer = null;
                    
                    conn = peer.connect('inara-' + roomCode, { reliable: true });
                    
                    conn.on('open', () => {
                        clearTimeout(joinTimeout);
                        console.log('Connected to host!');
                        setupConnectionHandlers();
                        sendOnlineMessage({ type: 'requestGameState', playerName: localPlayerName });
                    });
                    
                    conn.on('error', (err) => {
                        clearTimeout(joinTimeout);
                        console.error('Connection error:', err);
                        showOnlineError('Could not connect to game. Check the link and try again.');
                    });
                });
                
                peer.on('error', (err) => {
                    clearTimeout(joinTimeout);
                    console.error('PeerJS error:', err);
                    if (err.type === 'peer-unavailable') {
                        showOnlineError('Game not found. The host may have left or the link is invalid.');
                    } else {
                        showOnlineError('Could not connect to server. Please try again.');
                    }
                });
            }
        })();

        // === ONLINE MULTIPLAYER FUNCTIONS ===
        
        function generateRoomCode() {
            const adjectives = [
                'red', 'blue', 'green', 'gold', 'silver', 'bronze', 'iron', 'copper',
                'swift', 'bold', 'calm', 'dark', 'light', 'wild', 'wise', 'keen',
                'north', 'south', 'east', 'west', 'high', 'deep', 'old', 'new',
                'fire', 'ice', 'storm', 'sun', 'moon', 'star', 'wind', 'stone'
            ];
            const nouns = [
                'wolf', 'hawk', 'bear', 'lion', 'tiger', 'eagle', 'raven', 'fox',
                'peak', 'vale', 'grove', 'lake', 'river', 'ocean', 'forest', 'desert',
                'knight', 'queen', 'king', 'bishop', 'rook', 'pawn', 'tower', 'castle',
                'golem', 'shadow', 'glyph', 'moon', 'sand', 'mirror', 'mask', 'flame'
            ];
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            const num = Math.floor(Math.random() * 100);
            return `${adj}-${noun}-${num}`;
        }
        
        function openOnlineModal() {
            const modal = document.getElementById('onlineModal');
            modal.classList.add('show');
            
            // Reset state
            showOnlineStatus('Connecting to server...');
            
            // Initialize PeerJS
            initializePeer();
        }
        
        function closeOnlineModal() {
            document.getElementById('onlineModal').classList.remove('show');
            
            // Clean up peer connection if exists
            if (conn) {
                conn.close();
                conn = null;
            }
            if (peer) {
                peer.destroy();
                peer = null;
            }
            
            onlineMode = false;
            localPlayer = null;
            isHost = false;
            
            // Return to New Game modal
            showNewGameModal();
        }
        
        function showOnlineStatus(msg) {
            document.getElementById('onlineStatus').innerHTML = `<span style="color: var(--silver);">${msg}</span>`;
            document.getElementById('onlineStatus').style.display = 'block';
            document.getElementById('onlineOptions').style.display = 'none';
            document.getElementById('onlineWaiting').style.display = 'none';
            document.getElementById('onlineJoining').style.display = 'none';
            document.getElementById('onlineError').style.display = 'none';
        }
        
        function showOnlineOptions() {
            document.getElementById('onlineStatus').style.display = 'none';
            document.getElementById('onlineOptions').style.display = 'block';
            document.getElementById('onlineWaiting').style.display = 'none';
            document.getElementById('onlineJoining').style.display = 'none';
            document.getElementById('onlineError').style.display = 'none';
            
            // Reset side selection to default
            setHostSide('random');
        }
        
        function setHostSide(side) {
            selectedHostSide = side;
            
            document.getElementById('hostDarkBtn').style.background = side === 'dark' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('hostDarkBtn').style.color = side === 'dark' ? '' : 'var(--pearl)';
            document.getElementById('hostRandomBtn').style.background = side === 'random' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('hostRandomBtn').style.color = side === 'random' ? '' : 'var(--pearl)';
            document.getElementById('hostLightBtn').style.background = side === 'light' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('hostLightBtn').style.color = side === 'light' ? '' : 'var(--pearl)';
        }
        
        let selectedOnlineLives = 0; // Default sudden death for online
        
        function setOnlineLives(lives) {
            selectedOnlineLives = lives;
            
            [1, 2, 3].forEach(n => {
                const btn = document.getElementById(`onlineLives${n}Btn`);
                btn.style.background = lives === n ? 'var(--gold)' : 'var(--slate)';
                btn.style.color = lives === n ? '' : 'var(--pearl)';
            });
            
            // Sudden Death button (0 lives)
            const sdBtn = document.getElementById('onlineLives0Btn');
            sdBtn.style.background = lives === 0 ? 'var(--gold)' : 'var(--slate)';
            sdBtn.style.color = lives === 0 ? '' : 'var(--pearl)';
        }
        
        function showOnlineWaiting(code) {
            document.getElementById('onlineStatus').style.display = 'none';
            document.getElementById('onlineOptions').style.display = 'none';
            document.getElementById('onlineWaiting').style.display = 'block';
            document.getElementById('onlineJoining').style.display = 'none';
            document.getElementById('onlineError').style.display = 'none';
            document.getElementById('roomCode').textContent = code;
            
            // Generate shareable link
            const link = `${window.location.origin}${window.location.pathname}?room=${code}`;
            document.getElementById('roomLink').textContent = link;
        }
        
        function showOnlineJoining() {
            document.getElementById('onlineStatus').style.display = 'none';
            document.getElementById('onlineOptions').style.display = 'none';
            document.getElementById('onlineWaiting').style.display = 'none';
            document.getElementById('onlineJoining').style.display = 'block';
            document.getElementById('onlineError').style.display = 'none';
        }
        
        function showOnlineError(msg) {
            document.getElementById('onlineStatus').style.display = 'none';
            document.getElementById('onlineOptions').style.display = 'none';
            document.getElementById('onlineWaiting').style.display = 'none';
            document.getElementById('onlineJoining').style.display = 'none';
            document.getElementById('onlineError').style.display = 'block';
            document.getElementById('onlineErrorMsg').textContent = msg;
        }
        
        function copyRoomCode() {
            const code = document.getElementById('roomCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                const el = document.getElementById('roomCode');
                const original = el.textContent;
                el.textContent = 'Copied!';
                setTimeout(() => el.textContent = original, 1000);
            });
        }
        
        function copyRoomLink() {
            const link = document.getElementById('roomLink').textContent;
            navigator.clipboard.writeText(link).then(() => {
                const el = document.getElementById('roomLink');
                const original = el.textContent;
                el.textContent = 'Copied!';
                setTimeout(() => el.textContent = original, 1000);
            });
        }
        
        function initializePeer() {
            // Create peer with random ID
            peer = new Peer();
            
            peer.on('open', (id) => {
                console.log('Connected to PeerJS server with ID:', id);
                showOnlineOptions();
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                if (err.type === 'peer-unavailable') {
                    showOnlineError('Game not found. Check the code and try again.');
                } else if (err.type === 'network' || err.type === 'server-error') {
                    showOnlineError('Could not connect to server. Please try again.');
                } else {
                    showOnlineError('Connection error: ' + err.type);
                }
            });
            
            // Listen for incoming connections (for host)
            peer.on('connection', handleIncomingConnection);
        }
        
        function retryOnlineConnection() {
            if (peer) {
                peer.destroy();
                peer = null;
            }
            showOnlineStatus('Connecting to server...');
            initializePeer();
        }
        
        function createOnlineGame() {
            // Get player names
            const nameInput = document.getElementById('playerNameInput');
            const opponentInput = document.getElementById('opponentNameInput');
            localPlayerName = nameInput.value.trim().toUpperCase().slice(0, 5) || 'HOST';
            remotePlayerName = opponentInput.value.trim().toUpperCase().slice(0, 5) || 'GUEST';
            
            isHost = true;
            
            // Determine host's side
            if (selectedHostSide === 'random') {
                localPlayer = Math.random() < 0.5 ? 'dark' : 'light';
            } else {
                localPlayer = selectedHostSide;
            }
            
            const roomCode = generateRoomCode();
            
            // Destroy old peer and create new one with the room code as ID
            if (peer) {
                peer.destroy();
            }
            
            peer = new Peer('inara-' + roomCode);
            
            peer.on('open', () => {
                console.log('Room created:', roomCode);
                showOnlineWaiting(roomCode);
            });
            
            peer.on('disconnected', () => {
                console.log('Disconnected from signaling server, attempting to reconnect...');
                // Attempt to reconnect to the signaling server
                if (peer && !peer.destroyed) {
                    peer.reconnect();
                }
            });
            
            peer.on('error', (err) => {
                console.error('Error creating room:', err);
                if (err.type === 'unavailable-id') {
                    // Room code already taken, try another
                    createOnlineGame();
                } else if (err.type === 'disconnected' || err.type === 'network') {
                    // Network issue, try to reconnect
                    if (peer && !peer.destroyed) {
                        peer.reconnect();
                    }
                } else {
                    showOnlineError('Could not create game. Please try again.');
                }
            });
            
            peer.on('connection', handleIncomingConnection);
        }
        
        function handleIncomingConnection(connection) {
            console.log('Opponent connected!');
            conn = connection;
            setupConnectionHandlers();
            
            // Host starts the game and sends initial state
            startOnlineGame();
        }
        
        function joinOnlineGame() {
            const codeInput = document.getElementById('joinCodeInput');
            const code = codeInput.value.trim().toLowerCase();
            
            // Basic validation - should be like "word-word-number"
            if (!code || !code.includes('-')) {
                showOnlineError('Please enter a room code (e.g. blue-tiger-42)');
                return;
            }
            
            // Get player name
            const nameInput = document.getElementById('playerNameInput');
            localPlayerName = nameInput.value.trim().toUpperCase().slice(0, 5) || 'GUEST';
            
            isHost = false;
            localPlayer = null; // Will be assigned by host
            
            showOnlineJoining();
            
            // Ensure peer is ready before connecting
            if (!peer || peer.destroyed) {
                peer = new Peer();
                peer.on('open', () => {
                    connectToHost(code);
                });
                peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    if (err.type === 'peer-unavailable') {
                        showOnlineError('Game not found. Check the code and try again.');
                    } else {
                        showOnlineError('Could not connect to server. Please try again.');
                    }
                });
            } else if (!peer.open) {
                // Peer exists but not yet open, wait for it
                peer.on('open', () => {
                    connectToHost(code);
                });
            } else {
                // Peer is ready, connect immediately
                connectToHost(code);
            }
        }
        
        function connectToHost(code) {
            console.log('Attempting to connect to host:', code);
            
            // Set a timeout for connection
            const connectionTimeout = setTimeout(() => {
                if (!conn || !conn.open) {
                    console.log('Connection timeout');
                    showOnlineError('Could not connect to game. The host may have left.');
                    if (conn) {
                        conn.close();
                        conn = null;
                    }
                }
            }, 15000); // 15 second timeout
            
            // Connect to the host
            conn = peer.connect('inara-' + code, { reliable: true });
            
            conn.on('open', () => {
                clearTimeout(connectionTimeout);
                console.log('Connected to host!');
                setupConnectionHandlers();
                
                // Request game state from host, include our name
                sendOnlineMessage({ type: 'requestGameState', playerName: localPlayerName });
            });
            
            conn.on('error', (err) => {
                clearTimeout(connectionTimeout);
                console.error('Connection error:', err);
                showOnlineError('Could not connect to game. Check the code and try again.');
            });
        }
        
        function setupConnectionHandlers() {
            conn.on('data', (data) => {
                console.log('Received:', data.type);
                handleOnlineMessage(data);
            });
            
            conn.on('close', () => {
                console.log('Connection closed');
                if (onlineMode && !gameState.gameOver) {
                    alert('Opponent disconnected.');
                    onlineMode = false;
                }
            });
            
            conn.on('error', (err) => {
                console.error('Connection error:', err);
            });
        }
        
        function startOnlineGame() {
            // Close modal
            document.getElementById('onlineModal').classList.remove('show');
            
            // Set online mode
            onlineMode = true;
            cpuMode = false;
            spectateMode = false;
            
            if (isHost) {
                // Set lives from online selection
                selectedLives = selectedOnlineLives;
                
                // Force untimed for online games
                selectedTime = 0;
                
                // Host initializes the game
                initGame();
                
                // Send initial state to opponent with their side assignment
                const joinerSide = localPlayer === 'dark' ? 'light' : 'dark';
                sendOnlineMessage({
                    type: 'gameStart',
                    state: serializeGameState(),
                    yourSide: joinerSide,
                    hostName: localPlayerName,
                    joinerName: remotePlayerName,
                    hostSide: localPlayer
                });
                
                // Flip board if host is playing light
                setBoardFlip(localPlayer === 'light');
            }
        }
        
        function sendOnlineMessage(data) {
            if (conn && conn.open) {
                conn.send(data);
            }
        }
        
        function updatePlayerNames() {
            if (!onlineMode) return;
            
            // Determine which name goes to which side
            let darkName, lightName;
            
            if (localPlayer === 'dark') {
                darkName = localPlayerName;
                lightName = remotePlayerName || 'Light';
            } else {
                darkName = remotePlayerName || 'Dark';
                lightName = localPlayerName;
            }
            
            document.getElementById('darkPlayerName').textContent = darkName;
            document.getElementById('lightPlayerName').textContent = lightName;
        }
        
        function handleOnlineMessage(data) {
            switch (data.type) {
                case 'requestGameState':
                    // Joiner is asking for game state - send it
                    if (isHost && onlineMode) {
                        console.log('Sending game state to joiner');
                        const joinerSide = localPlayer === 'dark' ? 'light' : 'dark';
                        
                        sendOnlineMessage({
                            type: 'gameStart',
                            state: serializeGameState(),
                            yourSide: joinerSide,
                            hostName: localPlayerName,
                            joinerName: remotePlayerName, // Name host set for the joiner
                            hostSide: localPlayer
                        });
                        
                        // Update panel labels with names
                        updatePlayerNames();
                    }
                    break;
                    
                case 'gameStart':
                    // Received initial game state from host
                    document.getElementById('onlineModal').classList.remove('show');
                    onlineMode = true;
                    cpuMode = false;
                    spectateMode = false;
                    
                    // Set our side as assigned by host
                    localPlayer = data.yourSide;
                    
                    // Use names set by host
                    if (data.hostName) {
                        remotePlayerName = data.hostName;
                    }
                    if (data.joinerName) {
                        localPlayerName = data.joinerName; // Host set our name
                    }
                    
                    // Load the game state
                    loadOnlineGameState(data.state);
                    
                    // Update panel labels with names
                    updatePlayerNames();
                    
                    // Flip board if we're playing light
                    setBoardFlip(localPlayer === 'light');
                    break;
                    
                case 'move':
                    // Received opponent's move
                    applyOnlineMove(data.move);
                    break;
                    
                case 'resign':
                    // Opponent resigned
                    endGame(localPlayer, `${capitalize(data.player)} resigned. ${capitalize(localPlayer)} wins!`);
                    break;
                    
                case 'drawOffer':
                    // Opponent offered a draw
                    showDrawOfferFromOpponent();
                    break;
                    
                case 'drawAccept':
                    // Opponent accepted our draw offer
                    endGame('draw', 'Game drawn by agreement!');
                    break;
                    
                case 'drawDecline':
                    // Opponent declined our draw offer
                    // Just close the modal, game continues
                    break;
            }
        }
        
        function loadOnlineGameState(state) {
            // Initialize fresh game state
            gameState = createInitialState();
            
            // Copy the state from host
            gameState.board = state.board.map(row => row.map(cell => cell ? {...cell} : null));
            gameState.currentPlayer = state.currentPlayer;
            gameState.darkHand = state.darkHand.map(g => ({...g}));
            gameState.lightHand = state.lightHand.map(g => ({...g}));
            gameState.darkResting = state.darkResting ? {...state.darkResting} : null;
            gameState.lightResting = state.lightResting ? {...state.lightResting} : null;
            gameState.darkSupply = {
                shadows: state.darkSupply.shadows,
                masks: state.darkSupply.masks.map(m => ({...m}))
            };
            gameState.lightSupply = {
                shadows: state.lightSupply.shadows,
                masks: state.lightSupply.masks.map(m => ({...m}))
            };
            gameState.lightHasPlacedShadow = state.lightHasPlacedShadow;
            
            // Copy lives
            gameState.darkLives = state.darkLives || 1;
            gameState.lightLives = state.lightLives || 1;
            
            // Analysis data for replay
            analysisData = {
                initialState: serializeGameState(),
                moves: [],
                currentMoveIndex: -1,
                isAnalysisMode: false
            };
            
            historyStack = [];
            renderGame();
        }
        
        function applyOnlineMove(moveData) {
            // Reconstruct the move from the data
            if (moveData.type === 'movement') {
                // Select the glyph
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const glyphIndex = hand.findIndex(g => 
                    g.type === moveData.glyphUsed.type && g.value === moveData.glyphUsed.value
                );
                
                if (glyphIndex === -1) {
                    console.error('Could not find glyph for online move');
                    return;
                }
                
                gameState.selectedGlyph = { player: gameState.currentPlayer, index: glyphIndex };
                gameState.selectedPiece = { row: moveData.from.row, col: moveData.from.col };
                
                // Set shadow primed if needed
                gameState.shadowPrimed = moveData.shadowPlaced !== null;
                
                // Execute the move
                saveState();
                movePiece(moveData.from.row, moveData.from.col, moveData.to.row, moveData.to.col);
                
            } else if (moveData.type === 'reactivation') {
                // Select the glyph
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const glyphIndex = hand.findIndex(g => 
                    g.type === moveData.glyphUsed.type && g.value === moveData.glyphUsed.value
                );
                
                // Find the mask
                const supply = gameState.currentPlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                const maskIndex = supply.masks.findIndex(m => 
                    m.shape === moveData.mask.shape && m.color === moveData.mask.color
                );
                
                if (glyphIndex === -1 || maskIndex === -1) {
                    console.error('Could not find glyph or mask for online reactivation');
                    return;
                }
                
                gameState.selectedGlyph = { player: gameState.currentPlayer, index: glyphIndex };
                gameState.selectedMask = maskIndex;
                
                // Execute the reactivation
                executeReactivation(moveData.position.row, moveData.position.col, maskIndex);
            }
            
            // Clear selection state
            gameState.selectedGlyph = null;
            gameState.selectedPiece = null;
            gameState.selectedMask = null;
            gameState.shadowPrimed = false;
            
            renderGame();
        }
        
        function showDrawOfferFromOpponent() {
            const opponent = localPlayer === 'dark' ? 'light' : 'dark';
            document.getElementById('drawOfferMessage').textContent = 
                `${capitalize(opponent)} offers a draw. Do you accept?`;
            document.getElementById('drawOfferModal').classList.add('show');
        }
        
        // Check if it's the local player's turn in online mode
        function isLocalPlayerTurn() {
            if (!onlineMode) return true;
            return gameState.currentPlayer === localPlayer;
        }
        
        function updateOnlineIndicator() {
            const indicator = document.getElementById('onlineIndicator');
            const dot = document.getElementById('onlineIndicatorDot');
            const text = document.getElementById('onlineIndicatorText');
            
            if (!onlineMode) {
                indicator.style.display = 'none';
                return;
            }
            
            indicator.style.display = 'block';
            
            if (isLocalPlayerTurn()) {
                dot.style.background = '#4ade80'; // Green
                text.textContent = 'Your turn';
            } else {
                dot.style.background = '#fbbf24'; // Yellow
                text.textContent = 'Waiting...';
            }
        }
    </script>
</body>
</html>
