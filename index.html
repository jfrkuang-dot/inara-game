<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Inara - Play Online</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        /* Prevent zoom issues on orientation change */
        html {
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --obsidian: #0d0d0f;
            --onyx: #1a1a1f;
            --slate: #2d2d35;
            --silver: #9ca3af;
            --pearl: #f0ebe3;
            --gold: #a08060;
            --gold-glow: rgba(160, 128, 96, 0.4);
            --bronze: #8b6914;
            --light-square: #d4b896;
            --dark-square: #6b4423;
            --highlight: rgba(255, 255, 255, 0.5);
            --move-highlight: rgba(74, 222, 128, 0.5);
            --glyph-white: #f5f0e6;
            --glyph-orange: #d4735a;
            --glyph-blue: #5f9ea0;
            --accent: #ffffff;
            --accent-glow: rgba(255, 255, 255, 0.4);
            --glyph-tan: #d9c4a5;
            --glyph-charcoal: #3a332a;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--obsidian);
            color: var(--pearl);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Subtle texture overlay */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(201, 162, 39, 0.03) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(139, 105, 20, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 20px;
            animation: fadeDown 0.8s ease-out;
        }

        @keyframes fadeDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 600;
            color: var(--accent);
            letter-spacing: 0.2em;
            text-shadow: 0 0 40px var(--accent-glow);
        }

        /* Header Layout */
        .header-content {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* Menu Button */
        .menu-btn {
            position: absolute;
            left: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            transition: opacity 0.2s;
        }

        .menu-btn:hover {
            opacity: 0.7;
        }

        .flip-btn {
            position: absolute;
            right: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            font-size: 20px;
            color: var(--pearl);
            transition: opacity 0.2s;
        }

        .flip-btn:hover {
            opacity: 0.7;
        }

        .menu-btn span {
            display: block;
            width: 24px;
            height: 2px;
            background: var(--pearl);
            border-radius: 1px;
            transition: opacity 0.3s, transform 0.3s;
        }

        .menu-btn.open span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .menu-btn.open span:nth-child(2) {
            opacity: 0;
        }

        .menu-btn.open span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Dropdown Menu */
        .menu-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--onyx);
            border: 1px solid var(--slate);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, background 0.2s ease;
            z-index: 1000;
        }

        .menu-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(5px);
        }

        .menu-dropdown button {
            display: block;
            width: 100%;
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: var(--pearl);
            font-family: inherit;
            font-size: 0.95rem;
            text-align: left;
            cursor: pointer;
            transition: background 0.2s;
        }

        .menu-dropdown button:hover {
            background: var(--slate);
        }

        .menu-dropdown hr {
            border: none;
            border-top: 1px solid var(--slate);
            margin: 8px 0;
        }
        
        .lang-btn {
            padding: 6px 12px;
            background: var(--slate);
            border: 1px solid var(--silver);
            border-radius: 4px;
            color: var(--pearl);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .lang-btn:hover {
            background: var(--accent);
        }
        
        .lang-btn.active {
            background: var(--gold);
            color: var(--onyx);
            border-color: var(--gold);
        }
        
        .tutorial-lang-select {
            text-align: center;
            padding: 40px 20px;
        }

        /* Copyright Footer */
        .copyright {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            font-size: 0.8rem;
            color: var(--silver);
            opacity: 0.6;
            letter-spacing: 0.05em;
        }

        /* Game Layout */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 0;
            align-items: start;
            animation: fadeIn 1s ease-out 0.3s both;
        }

        /* Tutorial console - positioned left of board on desktop */
        .game-area.tutorial-active {
            grid-template-columns: 280px 1fr 380px;
        }

        .left-sidebar {
            order: 2;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            gap: 0;
            height: 568px; /* 560px board + 8px border */
        }

        /* Default order within left-sidebar: Light, Dark, History */
        #lightPanel { order: 1; }
        #darkPanel { order: 2; }
        #moveHistoryPanel { order: 3; }

        .left-sidebar.flipped #lightPanel {
            order: 2;
        }

        .left-sidebar.flipped #darkPanel {
            order: 1;
        }

        .left-sidebar.flipped #moveHistoryPanel {
            order: 4;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Player Panels */
        .player-panel {
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 1px solid var(--slate);
            border-radius: 12px;
            padding: 12px 16px;
            transition: opacity 0.4s ease, border-color 0.4s ease;
            opacity: 0.6;
            position: relative;
            overflow: hidden;
        }

        .player-panel::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, transparent, rgba(201, 162, 39, 0.02));
            pointer-events: none;
        }

        .player-panel.active {
            opacity: 1;
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow), inset 0 0 20px rgba(255, 255, 255, 0.03);
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Icon Buttons */
        .icon-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--slate);
            background: var(--obsidian);
            color: var(--silver);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease, background 0.2s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .icon-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .icon-btn.paused {
            background: var(--accent);
            color: var(--obsidian);
            border-color: var(--accent);
        }

        .icon-btn.resign-btn:hover {
            border-color: #ef4444;
            color: #ef4444;
        }

        .player-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent);
            letter-spacing: 0.05em;
        }

        .lives-display {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--pearl);
            background: var(--obsidian);
            padding: 3px 8px;
            border-radius: 6px;
            border: 1px solid var(--slate);
            display: none; /* Hidden by default for sudden death */
        }

        .lives-display.visible {
            display: inline-flex;
            align-items: center;
            gap: 3px;
        }

        .breakthrough-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: var(--onyx);
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 20px 32px;
            text-align: center;
            color: var(--pearl);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 0 30px rgba(201, 162, 39, 0.3);
        }

        .breakthrough-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .player-name-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-clock {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            font-size: 0.9rem;
            color: var(--silver);
            background: var(--obsidian);
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid var(--slate);
        }

        .player-panel.active .player-clock {
            color: var(--accent);
            border-color: var(--accent);
        }

        .player-clock.warning {
            color: #ef4444;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            to { opacity: 0.6; }
        }

        /* Shadow Button - positioned in glyphs row */
        .shadow-btn {
            width: 52px;
            height: 52px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.2s ease, background 0.2s ease;
            border: 2px dashed;
            font-size: 20px;
            font-weight: 600;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .shadow-btn.light-shadow-btn {
            background: linear-gradient(145deg, #d4c4a8 0%, #d8ccb8 100%);
            border-color: #908060;
            color: var(--obsidian);
        }

        .shadow-btn.dark-shadow-btn {
            background: linear-gradient(145deg, #5d4d3a 0%, var(--dark-square) 100%);
            border-color: #3d3024;
            color: var(--pearl);
        }

        .shadow-btn:hover:not(.locked):not(.disabled) {
            transform: scale(1.05);
        }

        .shadow-btn.primed {
            box-shadow: 0 0 12px var(--accent-glow);
            border-color: var(--accent);
            border-style: solid;
        }

        .shadow-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .shadow-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shadow-btn .shadow-count {
            line-height: 1;
        }

        /* Glyphs Row - Resting on left, Hand centered, Shadow on right */
        .glyphs-row {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            position: relative;
            min-height: 56px;
        }

        .resting-area {
            display: flex;
            position: absolute;
            left: 0;
            align-items: center;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .player-panel.active .resting-area {
            opacity: 1;
        }

        .hand-center {
            display: flex;
            gap: 10px;
            justify-content: center;
            grid-column: 2;
            padding-left: 70px; /* Space for resting glyph */
        }

        .shadow-area {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            opacity: 0.4;
            transition: opacity 0.2s ease;
            grid-column: 3;
        }

        .player-panel.active .shadow-area {
            opacity: 1;
        }

        .resting-arrow {
            color: var(--accent);
            font-size: 14px;
            opacity: 0.7;
            font-family: system-ui, sans-serif;
        }

        .resting-arrow::before {
            content: '›';
            font-size: 20px;
            font-weight: 300;
        }

        /* Desktop Resting Area - no longer used, resting glyphs now in player panels */
        .desktop-resting-area {
            display: none;
        }

        .glyph-hand {
            display: flex;
            gap: 8px;
        }

        .glyph {
            width: 52px;
            height: 52px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: var(--glyph-tan);
            border: 2px solid rgba(0, 0, 0, 0.2);
            transition: opacity 0.2s ease, background 0.2s ease;
            position: relative;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .glyph:hover:not(.resting):not(.disabled) {
            transform: translateY(-2px);
            border-color: var(--accent);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        .glyph.selected {
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow), 0 0 30px var(--accent-glow);
            transform: scale(1.08);
        }

        .glyph.selectable {
            border-color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow), 0 0 25px var(--accent-glow), inset 0 0 15px rgba(74, 222, 128, 0.3);
            animation: glyphPulse 1.5s ease-in-out infinite;
        }

        @keyframes glyphPulse {
            0%, 100% { 
                box-shadow: 0 0 12px var(--accent-glow), 0 0 25px var(--accent-glow), inset 0 0 15px rgba(74, 222, 128, 0.3);
            }
            50% { 
                box-shadow: 0 0 18px var(--accent-glow), 0 0 35px var(--accent-glow), inset 0 0 20px rgba(74, 222, 128, 0.5);
            }
        }

        .glyph.choice-required {
            border-color: rgb(147, 51, 234);
            box-shadow: 0 0 12px rgba(147, 51, 234, 0.6), 0 0 25px rgba(147, 51, 234, 0.4), inset 0 0 15px rgba(147, 51, 234, 0.3);
            animation: glyphChoicePulse 1.5s ease-in-out infinite;
        }

        @keyframes glyphChoicePulse {
            0%, 100% { 
                box-shadow: 0 0 12px rgba(147, 51, 234, 0.6), 0 0 25px rgba(147, 51, 234, 0.4), inset 0 0 15px rgba(147, 51, 234, 0.3);
            }
            50% { 
                box-shadow: 0 0 18px rgba(147, 51, 234, 0.8), 0 0 35px rgba(147, 51, 234, 0.6), inset 0 0 20px rgba(147, 51, 234, 0.5);
            }
        }

        .glyph.flash {
            animation: glyphFlash 0.15s ease-in-out 3;
        }

        @keyframes glyphFlash {
            0%, 100% { 
                box-shadow: 0 0 12px rgba(147, 51, 234, 0.6), 0 0 25px rgba(147, 51, 234, 0.4), inset 0 0 15px rgba(147, 51, 234, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 25px rgba(147, 51, 234, 1), 0 0 40px rgba(147, 51, 234, 0.7), inset 0 0 25px rgba(147, 51, 234, 0.6);
                transform: scale(1.1);
            }
        }

        /* Golem run complete flash */
        .piece.run-complete {
            animation: golemRunComplete 0.15s ease-in-out 2;
        }

        @keyframes golemRunComplete {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Capture flash animation */
        .piece.captured, .shadow-piece.captured {
            animation: captureFlash 0.2s ease-out forwards;
        }

        @keyframes captureFlash {
            0% { opacity: 1; filter: brightness(1); }
            40% { opacity: 1; filter: brightness(1.8); }
            100% { opacity: 0; filter: brightness(1); }
        }

        .glyph.resting {
            opacity: 0.7;
            cursor: default;
        }

        .glyph.disabled {
            opacity: 1;
            cursor: not-allowed;
        }

        /* Hand glyphs are bigger (about 38% bigger than resting) */
        .hand-center .glyph {
            width: 72px;
            height: 72px;
            border-radius: 12px;
        }

        .hand-center .glyph-shape {
            font-size: 34px;
        }

        .hand-center .glyph.color-glyph {
            /* Color glyphs in hand */
        }

        .hand-center .glyph.mirror {
            font-size: 34px;
        }

        .hand-center .mirror-shape {
            font-size: 34px;
        }

        .hand-center .mirror-color {
            width: 36px;
            height: 36px;
        }

        .glyph-shape {
            font-size: 24px;
            font-weight: 500;
            line-height: 1;
            color: var(--glyph-charcoal);
        }

        /* Color glyphs - solid fill */
        .glyph.color-glyph {
            border: 2px solid rgba(0, 0, 0, 0.3);
        }

        .glyph.mirror {
            background: linear-gradient(135deg, #5a5a62 0%, #3d3d45 50%, #5a5a62 100%);
            font-size: 24px;
        }

        /* Mirror content styling */
        .mirror-shape {
            font-size: 24px;
            font-weight: 500;
            color: #c0c0c8;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .mirror-color {
            width: 26px;
            height: 26px;
            border-radius: 4px;
            transform: rotate(45deg);
        }

        /* Masks Display */
        .masks-container {
            display: flex;
            gap: 3px;
            align-items: center;
        }

        .masks-scroller {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .masks-viewport {
            display: flex;
            gap: 3px;
            overflow: hidden;
            max-width: calc(108px + 8px); /* 3 masks * 32px + gaps + padding */
            padding: 4px;
            margin: -4px;
        }

        .masks-scroll-btn {
            background: none;
            border: none;
            color: var(--silver);
            font-size: 10px;
            cursor: pointer;
            padding: 2px 4px;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .masks-scroll-btn:hover {
            opacity: 1;
        }

        .masks-scroll-btn:disabled {
            opacity: 0.2;
            cursor: not-allowed;
        }

        .mask-piece {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s ease, background 0.2s ease;
        }

        .mask-piece.dark-mask {
            background: linear-gradient(135deg, #2a2a30 0%, #1a1a1f 100%);
            border: 2px solid #3a3a40;
            color: var(--accent);
        }

        .mask-piece.light-mask {
            background: linear-gradient(135deg, #d4c4a8 0%, #d8ccb8 100%);
            border: 2px solid #908060;
            color: var(--obsidian);
        }

        .mask-piece.dimmed {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .mask-piece.available {
            cursor: pointer;
            opacity: 1;
        }

        .mask-piece.available:hover {
            transform: scale(1.1);
            box-shadow: 0 0 8px var(--accent-glow);
        }

        .mask-piece.selected {
            box-shadow: 0 0 12px var(--accent-glow);
            border-color: var(--accent);
            transform: scale(1.1);
        }

        /* Glyph choice bubble */
        .glyph-choice-bubble {
            position: fixed;
            display: flex;
            gap: 6px;
            padding: 8px;
            background: var(--onyx);
            border: 2px solid var(--gold);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .glyph-choice-bubble::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--onyx);
            border: 2px solid var(--gold);
            transform: rotate(45deg);
        }

        .glyph-choice-bubble.above::after {
            bottom: -8px;
            left: 50%;
            margin-left: -6px;
            border-top: none;
            border-left: none;
        }

        .glyph-choice-bubble.below::after {
            top: -8px;
            left: 50%;
            margin-left: -6px;
            border-bottom: none;
            border-right: none;
        }

        .glyph-choice-bubble .glyph {
            width: 48px;
            height: 48px;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }

        .glyph-choice-bubble .glyph:hover {
            transform: scale(1.15);
            box-shadow: 0 0 12px var(--gold-glow);
        }

        /* Board Container */
        .board-container {
            order: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: min(560px, calc(100vw - 24px));
            aspect-ratio: 1;
            border: 4px solid var(--silver);
            border-radius: 4px;
            box-shadow: 
                0 0 60px rgba(255, 255, 255, 0.1),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            touch-action: manipulation;
            contain: layout style paint;
            transition: transform 0.3s ease;
        }

        .board.flipped {
            transform: rotate(180deg);
        }

        .board.flipped .square {
            transform: rotate(180deg);
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: box-shadow 0.15s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            contain: layout style;
        }

        .square .coord {
            position: absolute;
            font-size: 9px;
            font-weight: 500;
            opacity: 0.6;
            pointer-events: none;
        }

        .square .coord-file {
            bottom: 2px;
            right: 3px;
        }

        .square .coord-rank {
            top: 2px;
            left: 3px;
        }

        /* When flipped, coords need to stay in same visual position relative to board edges */
        /* After 180° board rotation + 180° square counter-rotation, top-left becomes bottom-right */
        .board.flipped .square .coord-file {
            bottom: 2px;
            right: 3px;
        }

        .board.flipped .square .coord-rank {
            top: 2px;
            left: 3px;
        }

        .square.light .coord {
            color: var(--light-square);
        }

        .square.dark .coord {
            color: var(--dark-square);
        }

        .square.light {
            background: var(--dark-square);
        }

        .square.dark {
            background: var(--light-square);
        }

        .square:hover {
            filter: brightness(1.1);
        }

        .square.selectable .piece {
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.8), 0 0 24px rgba(74, 222, 128, 0.5);
            outline: 2px solid rgba(74, 222, 128, 0.7);
            outline-offset: 2px;
        }

        .square.highlighted {
            box-shadow: inset 0 0 25px var(--move-highlight);
        }

        .square.highlighted::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(74, 222, 128, 0.6);
            border-radius: 50%;
        }

        .square.projected {
            box-shadow: inset 0 0 25px rgba(147, 51, 234, 0.5);
        }

        .square.projected::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(147, 51, 234, 0.6);
            border-radius: 50%;
        }

        .square.blocked-move {
            box-shadow: inset 0 0 25px rgba(239, 68, 68, 0.4);
        }

        .square.blocked-move::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(239, 68, 68, 0.5);
            border-radius: 50%;
        }



        .square.last-move-from {
            box-shadow: inset 0 0 0 3px rgba(250, 204, 21, 0.8);
        }

        .square.last-move-to .piece,
        .square.last-move-to .shadow-piece {
            box-shadow: 0 0 12px rgba(250, 204, 21, 0.7), 0 0 20px rgba(250, 204, 21, 0.4);
        }

        .square.reactivate-target {
            box-shadow: inset 0 0 20px rgba(147, 51, 234, 0.6);
        }

        /* Pieces */
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: grab;
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: clamp(16px, 3vw, 24px);
            font-weight: bold;
            z-index: 2;
        }

        .piece:active {
            cursor: grabbing;
        }

        .piece.dark-golem {
            background: linear-gradient(145deg, #5d4d3a 0%, var(--dark-square) 100%);
            border: 3px solid #3d3024;
            color: var(--pearl);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .piece.light-golem {
            background: linear-gradient(145deg, #d4c4a8 0%, #d8ccb8 100%);
            border: 3px solid #908060;
            color: var(--obsidian);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .piece.selected {
            transform: scale(1.15);
            box-shadow: 0 0 25px var(--accent-glow), 0 8px 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .piece.blocked {
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.6), 0 8px 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .piece-shape {
            font-size: clamp(20px, 4vw, 28px);
            font-weight: 500;
            line-height: 1;
        }

        .shadow-piece {
            width: 60%;
            height: 60%;
            border-radius: 50%;
            border: 2px dashed;
            opacity: 0.7;
        }

        .shadow-piece.dark-shadow {
            background: linear-gradient(145deg, #5d4d3a 0%, var(--dark-square) 100%);
            border-color: #3d3024;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .shadow-piece.light-shadow {
            background: linear-gradient(145deg, #d4c4a8 0%, #d8ccb8 100%);
            border-color: #908060;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Buttons (for modals) */
        .btn {
            background: linear-gradient(145deg, var(--pearl), #d4c4a8);
            color: var(--obsidian);
            border: none;
            padding: 12px 28px;
            font-size: 0.85rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: opacity 0.3s ease, transform 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 255, 255, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(145deg, var(--slate), var(--onyx));
            color: var(--pearl);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        /* Rules Button */
        /* Modal Base */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.3s ease-out;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 2px solid var(--gold);
            border-radius: 16px;
            padding: 32px;
            max-width: 700px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: slideUp 0.4s ease-out;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-content h2 {
            font-family: 'Philosopher', sans-serif;
            color: var(--gold);
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-content h3 {
            color: var(--gold);
            font-size: 1.2rem;
            margin: 24px 0 12px;
        }

        .modal-content p,
        .modal-content ul {
            line-height: 1.7;
            margin-bottom: 12px;
            color: var(--pearl);
        }

        .modal-content ul {
            padding-left: 24px;
        }

        .modal-content li {
            margin-bottom: 6px;
        }

        .close-modal {
            float: right;
            font-size: 28px;
            cursor: pointer;
            color: var(--silver);
            transition: color 0.2s;
            line-height: 1;
        }

        .close-modal:hover {
            color: var(--gold);
        }

        /* Rules Modal Tabs */
        .rules-modal-content {
            max-width: 600px;
        }

        .rules-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--slate);
            padding-bottom: 12px;
        }

        .rules-tab {
            background: transparent;
            border: 1px solid var(--slate);
            color: var(--silver);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .rules-tab:hover {
            border-color: var(--gold);
            color: var(--pearl);
        }

        .rules-tab.active {
            background: var(--gold);
            border-color: var(--gold);
            color: var(--obsidian);
            font-weight: 500;
        }

        .rules-tab-content {
            display: none;
        }

        .rules-tab-content.active {
            display: block;
        }

        .rules-tab-content h4 {
            color: var(--gold);
            font-size: 0.95rem;
            margin: 15px 0 8px 0;
            font-weight: 500;
        }

        .rules-tab-content ol {
            padding-left: 20px;
            margin: 10px 0;
        }

        .rules-tab-content ol li {
            margin-bottom: 8px;
        }

        .rules-tab-content ol ul {
            margin-top: 6px;
        }

        .rules-designer-note {
            margin-top: 30px;
            padding: 15px;
            background: var(--slate);
            border-radius: 8px;
            border-left: 3px solid var(--gold);
        }

        .rules-designer-note h4 {
            color: var(--gold);
            margin: 0 0 8px 0;
        }

        .rules-designer-note p {
            margin: 4px 0;
            font-style: italic;
        }

        /* Tutorial Modal - Non-interactive capsules */
        .tutorial-content {
            max-width: 500px;
            position: relative;
        }

        /* Tutorial Console - Interactive capsules */
        #tutorialConsole {
            order: 0;
            display: none;
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 15px;
            max-width: 280px;
            align-self: start;
        }

        #tutorialConsole.show {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        #tutorialConsole h3 {
            font-family: 'Philosopher', sans-serif;
            color: var(--gold);
            font-size: 1.2rem;
            margin-bottom: 10px;
            text-align: center;
        }

        #tutorialConsole .tutorial-body {
            color: var(--pearl);
            line-height: 1.6;
            font-size: 0.9rem;
        }

        #tutorialConsole .tutorial-body p {
            margin-bottom: 10px;
        }

        #tutorialConsole .tutorial-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--slate);
        }

        .tutorial-nav-btn {
            background: var(--slate);
            border: none;
            color: var(--pearl);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: background 0.2s, opacity 0.2s;
        }

        .tutorial-nav-btn:hover:not(:disabled) {
            background: var(--accent);
            color: var(--obsidian);
        }

        .tutorial-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .tutorial-progress {
            color: var(--silver);
            font-size: 0.9rem;
        }

        .tutorial-capsule {
            display: none;
        }

        .tutorial-capsule.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .tutorial-capsule h2 {
            font-family: 'Philosopher', sans-serif;
            color: var(--gold);
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
        }

        .tutorial-body {
            color: var(--pearl);
            line-height: 1.7;
            font-size: 0.95rem;
        }

        .tutorial-body p {
            margin-bottom: 12px;
        }

        .tutorial-body ul {
            padding-left: 24px;
            margin-bottom: 12px;
        }

        .tutorial-body li {
            margin-bottom: 6px;
        }

        .tutorial-prompt {
            background: var(--slate);
            border-left: 3px solid var(--gold);
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            color: var(--accent);
        }

        .tutorial-reset-btn {
            display: inline-block;
            padding: 6px 12px;
            background: var(--slate);
            border: none;
            color: var(--pearl);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        .tutorial-reset-btn:hover {
            background: var(--accent);
            color: var(--obsidian);
        }

        .tutorial-continue-btn {
            display: inline-block;
            padding: 6px 16px;
            background: var(--gold);
            border: none;
            color: var(--obsidian);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: background 0.2s, opacity 0.2s;
        }

        .tutorial-continue-btn:hover:not(:disabled) {
            background: var(--accent);
        }

        .tutorial-continue-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .tutorial-exit-btn {
            display: inline-block;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--silver);
            color: var(--silver);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s, border-color 0.2s, color 0.2s;
        }

        .tutorial-exit-btn:hover {
            border-color: #ef4444;
            color: #ef4444;
        }

        .tutorial-checklist {
            list-style: none;
            padding-left: 0;
            margin: 10px 0;
        }

        .tutorial-checklist li {
            padding: 4px 0;
            color: var(--silver);
            transition: color 0.3s;
        }

        .tutorial-checklist li.completed {
            color: var(--accent);
        }

        /* Victory Modal */
        .victory-content {
            text-align: center;
            max-width: 450px;
        }

        .victory-content h2 {
            font-size: 2.5rem;
            text-shadow: 0 0 30px var(--gold-glow);
        }

        .victory-content p {
            font-size: 1.3rem;
            margin: 20px 0 30px;
        }

        /* Time Control Slider */
        .time-display {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 2.5rem;
            color: var(--accent);
            margin-bottom: 15px;
            font-weight: 600;
        }

        .time-display.increment-display {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .time-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--slate);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.15s ease;
        }

        .time-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .time-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .time-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--silver);
            opacity: 0.7;
        }

        /* Analysis Console */
        .analysis-ribbon {
            display: none;
            background: var(--onyx);
            border: 1px solid var(--slate);
            border-radius: 8px;
            padding: 10px 15px;
            margin-bottom: 15px;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .analysis-ribbon.show {
            display: flex;
        }

        .analysis-filename {
            width: 100%;
            font-size: 11px;
            color: var(--silver);
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .analysis-filename:empty {
            display: none;
        }

        .ribbon-nav {
            display: flex;
            gap: 5px;
        }

        .ribbon-btn {
            background: var(--slate);
            border: none;
            color: var(--pearl);
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .ribbon-btn:hover {
            background: var(--accent);
            color: var(--obsidian);
        }

        .ribbon-moves {
            display: flex;
            gap: 4px;
            flex-wrap: nowrap;
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 4px 0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }

        .ribbon-move {
            background: var(--slate);
            border: none;
            color: var(--pearl);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: opacity 0.2s, background 0.2s;
            white-space: nowrap;
        }

        .ribbon-move:hover {
            background: var(--silver);
            color: var(--obsidian);
        }

        .ribbon-move.active {
            background: var(--accent);
            color: var(--obsidian);
        }

        .ribbon-move.dark-move {
            border-left: 3px solid #4a4a52;
        }

        .ribbon-move.light-move {
            border-left: 3px solid #d4c4a8;
        }

        .ribbon-move-num {
            font-weight: 600;
            opacity: 0.7;
        }

        .ribbon-coords {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 10px;
            opacity: 0.8;
        }

        .ribbon-glyph {
            font-size: 11px;
            opacity: 0.9;
        }

        .move-icon {
            font-size: 11px;
        }

        /* Move History Panel */
        .move-history-panel {
            display: none;
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 1px solid var(--slate);
            border-radius: 12px;
            padding: 12px 16px;
            margin-top: 15px;
            overflow: hidden;
        }

        .move-history-panel.show {
            display: block;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .history-header.expanded {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--slate);
        }

        .history-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--pearl);
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .history-toggle {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .history-header.expanded .history-toggle {
            transform: rotate(90deg);
        }

        .history-controls {
            display: none;
            gap: 10px;
            align-items: center;
        }

        .history-header.expanded .history-controls {
            display: flex;
        }

        .history-nav {
            display: flex;
            gap: 5px;
        }

        .history-actions {
            display: flex;
            gap: 5px;
        }

        .history-btn {
            background: var(--slate);
            border: none;
            color: var(--pearl);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .history-btn:hover {
            background: var(--accent);
            color: var(--obsidian);
        }

        .history-body {
            display: none;
        }

        .history-body.expanded {
            display: block;
        }

        .history-list {
            overflow-y: auto;
            max-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .play-from-here-btn {
            width: 100%;
            margin-top: 10px;
            padding: 10px;
            background: linear-gradient(145deg, var(--slate), var(--onyx));
            border: 1px solid var(--silver);
            border-radius: 6px;
            color: var(--pearl);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s, background 0.2s;
        }

        .play-from-here-btn:hover {
            background: linear-gradient(145deg, var(--pearl), #d4c4a8);
            color: var(--obsidian);
            border-color: var(--pearl);
        }

        .history-move {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            cursor: pointer;
            transition: opacity 0.2s, background 0.2s;
            font-size: 0.85rem;
        }

        .history-move:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .history-move.active {
            background: var(--accent);
            color: var(--obsidian);
        }

        .history-move.dark-move {
            border-left: 3px solid #4a4a52;
        }

        .history-move.light-move {
            border-left: 3px solid #d4c4a8;
        }

        .move-number {
            font-weight: 600;
            min-width: 24px;
            color: var(--silver);
        }

        .history-move.active .move-number {
            color: var(--obsidian);
        }

        .move-notation {
            flex: 1;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.8rem;
        }

        .piece-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            font-size: 10px;
            font-weight: bold;
        }

        .piece-icon.dark-piece {
            background: #3a3a42;
            color: var(--pearl);
        }

        .piece-icon.light-piece {
            background: #d4c4a8;
            color: #2a2a30;
        }

        .glyph-indicator {
            font-size: 11px;
            opacity: 0.7;
        }

        .move-time {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 10px;
            color: var(--silver);
            opacity: 0.7;
            margin-left: auto;
            padding-left: 8px;
        }

        .history-move.active .move-time {
            color: var(--obsidian);
            opacity: 0.8;
        }

        .ribbon-time {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 9px;
            opacity: 0.6;
            margin-left: 4px;
        }

        /* Capture display */
        .capture-icons {
            font-size: 10px;
            margin-left: 2px;
            opacity: 0.9;
            color: #ef4444;
        }

        .capture-display {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            margin-left: 4px;
            color: #ef4444;
            font-size: 11px;
        }

        .captured-piece {
            width: 16px;
            height: 16px;
            font-size: 9px;
            opacity: 0.8;
        }

        .shadow-capture {
            opacity: 0.8;
        }

        .shadow-capture-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 9px;
            border: 1px dashed;
            opacity: 0.8;
        }

        .shadow-capture-icon.dark-shadow-icon {
            background: rgba(90, 77, 58, 0.5);
            border-color: #3d3024;
        }

        .shadow-capture-icon.light-shadow-icon {
            background: rgba(212, 196, 168, 0.5);
            border-color: #908060;
        }

        /* Analysis mode board highlight */
        .board.analysis-mode {
            opacity: 0.95;
        }

        /* Save/Load Panel */
        .save-load-panel {
            display: none;
            background: linear-gradient(145deg, var(--onyx), var(--obsidian));
            border: 1px solid var(--slate);
            border-radius: 12px;
            padding: 12px 16px;
            margin-top: 10px;
            overflow: hidden;
        }

        .save-load-panel.show {
            display: block;
        }

        .save-load-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .save-load-header.expanded {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--slate);
        }

        .save-load-toggle {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .save-load-header.expanded .save-load-toggle {
            transform: rotate(90deg);
        }

        .save-load-body {
            display: none;
        }

        .save-load-body.expanded {
            display: block;
        }

        .save-load-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .save-load-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(145deg, var(--slate), var(--onyx));
            border: 1px solid var(--silver);
            border-radius: 6px;
            color: var(--pearl);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s, background 0.2s;
            text-align: left;
        }

        .save-load-btn:hover {
            background: linear-gradient(145deg, var(--pearl), #d4c4a8);
            color: var(--obsidian);
            border-color: var(--pearl);
        }

        /* Responsive */
        @media (max-width: 1100px) {
            .game-area {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                max-width: 560px;
                margin: 0 auto;
                gap: 10px;
            }

            /* Tutorial console above light panel on mobile */
            .game-area.tutorial-active {
                grid-template-columns: 1fr;
            }

            #tutorialConsole {
                order: 0;
                max-width: 100%;
                margin-bottom: 10px;
            }

            .left-sidebar {
                display: contents;
            }

            #lightPanel {
                order: 1;
            }

            .board-container {
                order: 2;
            }

            #darkPanel {
                order: 3;
            }

            /* Flipped board: swap panel positions */
            .game-area.flipped #lightPanel {
                order: 3;
            }

            .game-area.flipped #darkPanel {
                order: 1;
            }

            .player-panel {
                max-width: 100%;
            }

            /* Restore flex layout for glyphs-row on mobile */
            .glyphs-row {
                display: flex;
                justify-content: center;
            }

            /* Add padding for resting area on left */
            .hand-center {
                padding-left: 60px;
                grid-column: unset;
            }

            /* Hide desktop resting area on mobile/tablet */
            .desktop-resting-area {
                display: none;
            }

            .shadow-area {
                position: absolute;
                right: 0;
                grid-column: unset;
            }
            
            /* Move history panel on mobile */
            .move-history-panel {
                order: 4;
                max-height: 200px;
            }
            
            /* Analysis ribbon on mobile */
            .analysis-ribbon {
                padding: 8px 10px;
                gap: 6px;
            }
            
            .ribbon-moves {
                gap: 3px;
            }
            
            .ribbon-move {
                padding: 3px 6px;
                font-size: 11px;
            }
        }

        @media (max-width: 600px) {
            .container {
                padding: 6px;
            }

            header {
                margin-bottom: 10px;
            }

            h1 {
                font-size: 1.8rem;
                letter-spacing: 0.1em;
            }

            .subtitle {
                font-size: 0.65rem;
                letter-spacing: 0.15em;
            }

            .game-area {
                gap: 8px;
            }

            .player-panel {
                padding: 8px 10px;
                border-radius: 8px;
            }

            .player-header {
                margin-bottom: 6px;
            }

            .player-name {
                font-size: 0.95rem;
            }

            .player-clock {
                font-size: 0.85rem;
                padding: 3px 8px;
            }

            .icon-btn {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            .btn-stack .icon-btn {
                width: 20px;
                height: 16px;
                font-size: 9px;
            }

            .header-right {
                gap: 8px;
            }

            .shadow-btn {
                width: 28px;
                height: 28px;
                font-size: 12px;
            }

            .resting-arrow {
                font-size: 12px;
            }

            .glyphs-row {
                min-height: 48px;
            }

            .glyph-hand {
                gap: 6px;
            }

            .glyph {
                width: 44px;
                height: 44px;
                border-radius: 8px;
            }

            .hand-center .glyph {
                width: 56px;
                height: 56px;
            }

            .glyph-shape {
                font-size: 20px;
            }

            .hand-center .glyph-shape {
                font-size: 26px;
            }

            .hand-center .mirror-shape {
                font-size: 26px;
            }

            .hand-center .mirror-color {
                width: 28px;
                height: 28px;
            }

            .glyph.mirror {
                font-size: 20px;
            }

            .hand-center .glyph.mirror {
                font-size: 26px;
            }

            .mask-piece {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }

            .player-name-row {
                gap: 6px;
            }

            .board {
                width: min(100%, calc(100vw - 12px));
                border-width: 3px;
            }

            .piece-shape {
                font-size: 16px;
            }

            .shadow-piece {
                width: 50%;
                height: 50%;
            }

            .btn {
                padding: 10px 16px;
                font-size: 0.8rem;
            }

            .modal-content {
                padding: 20px;
                border-radius: 12px;
            }

            .modal-content h2 {
                font-size: 1.5rem;
            }

            .modal-content h3 {
                font-size: 1rem;
            }

            .modal-content p,
            .modal-content ul {
                font-size: 0.9rem;
            }
        }

        @media (max-width: 400px) {
            .container {
                padding: 4px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .player-panel {
                padding: 6px 8px;
            }

            .player-name {
                font-size: 0.85rem;
            }

            .player-clock {
                font-size: 0.8rem;
                padding: 2px 6px;
            }

            .header-right {
                gap: 6px;
            }

            .shadow-btn {
                width: 38px;
                height: 38px;
                font-size: 14px;
            }

            .icon-btn {
                width: 26px;
                height: 26px;
                font-size: 12px;
            }

            .glyphs-row {
                min-height: 48px;
            }

            .glyph {
                width: 38px;
                height: 38px;
            }

            .hand-center .glyph {
                width: 50px;
                height: 50px;
            }

            .glyph-shape {
                font-size: 18px;
            }

            .hand-center .glyph-shape {
                font-size: 24px;
            }

            .hand-center .mirror-shape {
                font-size: 24px;
            }

            .hand-center .mirror-color {
                width: 24px;
                height: 24px;
            }

            .glyph.mirror {
                font-size: 18px;
            }

            .hand-center .glyph.mirror {
                font-size: 24px;
            }

            .resting-arrow {
                font-size: 10px;
            }

            .mask-piece {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            .player-name-row {
                gap: 4px;
            }

            .piece-shape {
                font-size: 14px;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--obsidian);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--slate);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <button class="menu-btn" id="menuBtn" onclick="toggleMenu()">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1>INARA</h1>
                <div id="onlineIndicator" style="display: none; position: absolute; right: 50px; top: 50%; transform: translateY(-50%); 
                                                  font-size: 0.75rem; padding: 4px 10px; border-radius: 4px; background: var(--slate);">
                    <span id="onlineIndicatorDot" style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; 
                                                          background: #4ade80; margin-right: 6px;"></span>
                    <span id="onlineIndicatorText">Online</span>
                </div>
                <button class="flip-btn" onclick="toggleBoardFlip()" title="Flip board">⇅</button>
                <div class="menu-dropdown" id="menuDropdown">
                    <button onclick="showNewGameModal(); closeMenu();">New Game</button>
                    <button onclick="document.getElementById('menuImportInput').click(); closeMenu();">Review Game</button>
                    <input type="file" id="menuImportInput" accept=".json" style="display:none" onchange="importGameJSON(event)">
                    <button onclick="toggleRules(); closeMenu();">Rules</button>
                    <button onclick="openTutorial(); closeMenu();">Tutorial</button>
                    <button onclick="showAbout(); closeMenu();">About</button>
                </div>
            </div>
        </header>

        <!-- Analysis Ribbon -->
        <div class="analysis-ribbon" id="analysisRibbon">
            <div class="analysis-filename" id="analysisFilename"></div>
            <div class="ribbon-nav">
                <button class="ribbon-btn" onclick="goToMove(-1)" title="Start">⏮</button>
                <button class="ribbon-btn" onclick="goToMove(analysisData.currentMoveIndex - 1)" title="Previous">◀</button>
            </div>
            <div class="ribbon-moves" id="ribbonMoves"></div>
            <div class="ribbon-nav">
                <button class="ribbon-btn" onclick="goToMove(analysisData.currentMoveIndex + 1)" title="Next">▶</button>
                <button class="ribbon-btn" onclick="goToMove(analysisData.moves.length - 1)" title="End">⏭</button>
            </div>
        </div>

        <div class="game-area">
            <!-- Tutorial Console (Interactive Mode) - Left of board on desktop, above light panel on mobile -->
            <div id="tutorialConsole">
                <h3 id="tutorialConsoleTitle">Steps</h3>
                <div class="tutorial-body" id="tutorialConsoleBody">
                    <!-- Content injected by JS -->
                </div>
                <div class="tutorial-controls">
                    <button class="tutorial-exit-btn" onclick="exitTutorial()">Exit</button>
                    <button class="tutorial-reset-btn" onclick="resetTutorialScenario()">Reset</button>
                    <button class="tutorial-nav-btn" onclick="tutorialPrev()">◀ Back</button>
                    <span class="tutorial-progress" id="tutorialConsoleProgress">5 / 11</span>
                    <button class="tutorial-nav-btn" onclick="tutorialNext()">Next ▶</button>
                    <button class="tutorial-continue-btn" id="tutorialConsoleContinue" onclick="tutorialNext()" disabled>Continue</button>
                </div>
            </div>

            <!-- Left Side: Player Panels and Resting Glyphs -->
            <div class="left-sidebar">
                <!-- Light Player Panel -->
                <div class="player-panel" id="lightPanel">
                    <div class="player-header">
                        <div class="player-name-row">
                            <span class="lives-display" id="lightLives"><span style="color: #e74c3c;">♥</span> 1</span>
                            <span class="player-name" id="lightPlayerName">Light</span>
                            <div class="masks-container" id="lightMasksDisplay"></div>
                        </div>
                        <div class="header-right">
                            <button class="icon-btn" onclick="undoMove()" title="Undo">⟲</button>
                            <span class="player-clock" id="lightClock">10:00</span>
                            <button class="icon-btn resign-btn" onclick="confirmResign('light')" title="Resign">⚐</button>
                        </div>
                    </div>

                    <div class="glyphs-row">
                        <div class="resting-area">
                            <div class="glyph-hand" id="lightResting"></div>
                            <span class="resting-arrow"></span>
                        </div>
                        <div class="glyph-hand hand-center" id="lightHand"></div>
                        <div class="shadow-area">
                            <button class="shadow-btn light-shadow-btn" id="lightShadowBtn" onclick="toggleShadowPrimed('light')">
                                <span class="shadow-count" id="lightShadowCount">1</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Dark Player Panel -->
                <div class="player-panel active" id="darkPanel">
                    <div class="player-header">
                        <div class="player-name-row">
                            <span class="lives-display" id="darkLives"><span style="color: #e74c3c;">♥</span> 1</span>
                            <span class="player-name" id="darkPlayerName">Dark</span>
                            <div class="masks-container" id="darkMasksDisplay"></div>
                        </div>
                        <div class="header-right">
                            <button class="icon-btn" onclick="undoMove()" title="Undo">⟲</button>
                            <span class="player-clock" id="darkClock">10:00</span>
                            <button class="icon-btn resign-btn" onclick="confirmResign('dark')" title="Resign">⚐</button>
                        </div>
                    </div>

                    <div class="glyphs-row">
                        <div class="resting-area">
                            <div class="glyph-hand" id="darkResting"></div>
                            <span class="resting-arrow"></span>
                        </div>
                        <div class="glyph-hand hand-center" id="darkHand"></div>
                        <div class="shadow-area">
                            <button class="shadow-btn dark-shadow-btn" id="darkShadowBtn" onclick="toggleShadowPrimed('dark')">
                                <span class="shadow-count" id="darkShadowCount">1</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Move History Panel (Analysis Mode) -->
                <div class="move-history-panel" id="moveHistoryPanel">
                    <div class="history-header" id="historyHeader" onclick="toggleHistoryPanel()">
                        <span class="history-title"><span class="history-toggle">▶</span> Move History</span>
                        <div class="history-controls">
                            <div class="history-nav">
                                <button class="history-btn" onclick="event.stopPropagation(); goToMove(analysisData.currentMoveIndex - 1)" title="Previous">◀</button>
                                <button class="history-btn" onclick="event.stopPropagation(); goToMove(analysisData.currentMoveIndex + 1)" title="Next">▶</button>
                            </div>
                        </div>
                    </div>
                    <div class="history-body" id="historyBody">
                        <div class="history-list" id="historyList"></div>
                        <button class="play-from-here-btn" onclick="playFromHere()">▶ Play from here</button>
                    </div>
                </div>
                <div class="save-load-panel" id="saveLoadPanel">
                    <div class="save-load-header" id="saveLoadHeader" onclick="toggleSaveLoadPanel()">
                        <span class="history-title"><span class="save-load-toggle">▶</span> Save / Load</span>
                    </div>
                    <div class="save-load-body" id="saveLoadBody">
                        <div class="save-load-actions">
                            <button class="save-load-btn" onclick="exportGameJSON()">💾 Export Game</button>
                            <button class="save-load-btn" onclick="document.getElementById('importInput').click()">📂 Import Game</button>
                            <input type="file" id="importInput" accept=".json" style="display:none" onchange="importGameJSON(event)">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Board -->
            <div class="board-container">
                <div class="board" id="board"></div>
            </div>
        </div>

        <footer class="copyright">
            Game Design © 2025 James Kuang
        </footer>
    </div>

    <!-- Rules Modal -->
    <div class="modal" id="rulesModal">
        <div class="modal-content rules-modal-content">
            <span class="close-modal" onclick="toggleRules()">&times;</span>
            
            <!-- Rules Language Selection (shown first) -->
            <div id="rulesLangSelect" class="tutorial-lang-select">
                <h2 style="font-family: 'Philosopher', sans-serif; margin-bottom: 20px;">Rules</h2>
                <p style="color: var(--silver); margin-bottom: 20px;">Select Language</p>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 200px; margin: 0 auto;">
                    <button class="btn" onclick="showRulesWithLang('en')" style="width: 100%;">English</button>
                    <button class="btn" onclick="showRulesWithLang('zh')" style="width: 100%; background: var(--slate); color: var(--pearl);">中文</button>
                    <button class="btn" onclick="showRulesWithLang('es')" style="width: 100%; background: var(--slate); color: var(--pearl);">Español</button>
                </div>
            </div>
            
            <!-- Rules Content (hidden until language selected) -->
            <div id="rulesContent" style="display: none;">
                <h2>How to Play Inara</h2>

                <!-- Rules Tabs -->
                <div class="rules-tabs">
                    <button class="rules-tab active" data-tab="quick">Quick Reference</button>
                    <button class="rules-tab" data-tab="full">Full Rules</button>
                </div>

                <!-- Quick Reference Tab -->
                <div class="rules-tab-content active" id="rules-quick">
                    <h3>Objective</h3>
                    <p><strong>Sudden Death:</strong> Race your golems across the board and be the first to move one into a square on your opponent's home row to win!</p>
                    <p><strong>Extra Lives:</strong> Your opponent loses a life every time you make one of these runs. Bring their number of lives down to zero to win!</p>

                    <h3>On Your Turn</h3>
                    <ul>
                        <li>Select a glyph from your hand</li>
                        <li>Move a golem matching the glyph's shape or color</li>
                        <li>If using the Mirror glyph, match the resting glyph instead</li>
                        <li>The used glyph becomes your opponent's resting glyph</li>
                        <li>Pick up your resting glyph to your hand</li>
                    </ul>

                    <h3>Movement</h3>
                    <ul>
                        <li><strong>Step:</strong> Move 2 spaces orthogonally (N/S/E/W) if the middle square is empty, OR 1 space diagonally</li>
                        <li><strong>Jump:</strong> Jump diagonally over your own pieces to the next empty square</li>
                        <li>Chain multiple jumps in one turn!</li>
                    </ul>

                <h3>Capturing</h3>
                <ul>
                    <li>Surround an opponent's piece on opposite sides (horizontal or vertical)</li>
                    <li>Your moving piece must NOT match the target in shape or color</li>
                    <li>Captured golems return their mask and shadow to the owner's supply</li>
                </ul>

                <h3>Scoring (Extra Lives)</h3>
                <ul>
                    <li>Golems that complete a run can still make captures and leave shadows on that turn</li>
                    <li>Completing a run returns that golem to your supply as a mask and a shadow</li>
                </ul>

                <h3>Shadows</h3>
                <ul>
                    <li>After moving, you may leave a shadow on the vacated square (if available)</li>
                    <li>Dark cannot place shadows until Light has placed one first</li>
                    <li>Shadows can help capture and block movement</li>
                    <li>If ONE shadow is captured, ALL your shadows are removed!</li>
                </ul>

                <h3>Reactivation</h3>
                <ul>
                    <li>Instead of moving, place a mask from your supply onto one of your shadows</li>
                    <li>The mask must match BOTH the active glyph AND the resting glyph</li>
                    <li>If using Mirror, it copies the other glyph's requirement</li>
                </ul>

                <h3>Symbols</h3>
                <p><strong>Shapes:</strong> Ω Moon, Χ Sand, Λ Peak</p>
                <p><strong>Colors:</strong> White, Orange, Blue</p>
                <p><strong>Mirror:</strong> ◇ (copies the resting glyph)</p>
            </div>

            <!-- Full Rules Tab -->
            <div class="rules-tab-content" id="rules-full">
                <h3>Overview</h3>
                <p>Inara is a contest of skillful positioning and adaptation to ever shifting resources. There is no random chance once the game has started and no hidden information.</p>

                <h3>Materials</h3>
                <ul>
                    <li>A checkerboard (8×8) with light and dark squares</li>
                    <li>7 Glyph tokens: 3 shapes (Moon, Sand, Peak), 3 colors (White, Orange, Blue), and 1 Mirror</li>
                    <li>Two sets of 9 golems (Light and Dark), each with a shadow stone and marked mask showing one of nine unique shape/color combinations</li>
                </ul>

                <h3>Preparing the Game</h3>
                <ol>
                    <li>Give each player a set of golems. The player with dark golems moves first.</li>
                    <li>Place 8 of your golems randomly on alternating squares in your first two rows. Light golems go on dark squares; dark golems go on light squares.</li>
                    <li>Leave your 9th golem aside—dismantle it and put the mask and shadow into your supply.</li>
                    <li>Randomly distribute glyphs: Dark receives 3, Light receives 3. The remaining glyph becomes Dark's resting glyph.</li>
                </ol>

                <h3>Goal</h3>
                <p>Race your golems across the board and be the first to move one into your opponent's back row. Victory is yours if you succeed before they do!</p>

                <h3>Turn Summary</h3>
                <p>Players alternate turns. At the start of your turn, you have 3 glyphs in hand and 1 resting. You must take an action—you may not pass.</p>
                <ol>
                    <li><strong>Play a glyph</strong> from your hand as the active glyph, then either:
                        <ul>
                            <li>Move a golem matching the active glyph's shape or color (or if Mirror is active, match the resting glyph)</li>
                            <li>OR Reactivate a golem</li>
                        </ul>
                    </li>
                    <li><strong>Resolve captures</strong> resulting from movement or reactivation</li>
                    <li><strong>End your turn</strong> by picking up the resting glyph</li>
                    <li>Your used glyph becomes the new resting glyph for your opponent</li>
                </ol>

                <h3>How to Move</h3>
                <p>Each square can hold at most one golem or shadow.</p>
                <h4>Stepping</h4>
                <ul>
                    <li>Move orthogonally 2 spaces (N/S/E/W). This can be blocked by opponent pieces in the intermediate square.</li>
                    <li>OR move 1 space diagonally. This cannot be hindered by nearby pieces.</li>
                </ul>
                <h4>Jumping</h4>
                <ul>
                    <li>Jump diagonally over your own pieces (including shadows) to the next empty square</li>
                    <li>You may jump over one piece or multiple pieces arranged in a row</li>
                    <li>Chain several jumps together as a single move</li>
                    <li>You cannot jump back to your starting square in the same turn</li>
                </ul>

                <h3>Capturing Pieces</h3>
                <ul>
                    <li>After moving or reactivating, your golem captures any opponent pieces surrounded on two opposite sides (horizontal or vertical) by the moving golem and another of your pieces</li>
                    <li>The moving piece captures any opponent piece that does <strong>not</strong> match it in shape, color, or both. Pieces matching by shape or color are safe.</li>
                    <li>The stationary piece's shape/color does not matter—only the moving piece's attributes count</li>
                    <li>Captured pieces are dismantled and returned to their owner's supply</li>
                    <li>Moving into a square between two opponent pieces does <strong>not</strong> result in your capture</li>
                </ul>

                <h3>Shadows</h3>
                <ul>
                    <li>When your golem moves, you may leave a shadow on the vacated square (if you have one in supply)</li>
                    <li><strong>Dark may not place shadows until Light has placed one first</strong></li>
                    <li>Shadows cannot move but can block opponent steps</li>
                    <li>Your golems can jump over your own shadows</li>
                    <li>Shadows can be stationary pieces for capturing</li>
                    <li>Shadows can be captured by any opponent piece (no matching required)</li>
                    <li><strong>Shadow Capture Rule:</strong> If one of your shadows is captured, ALL your remaining shadows are immediately removed and returned to your supply</li>
                </ul>

                <h3>Reactivation</h3>
                <ul>
                    <li>Instead of moving, place a mask from your supply onto one of your shadows on the board</li>
                    <li>The mask must match <strong>both</strong> the active glyph AND the resting glyph</li>
                    <li>If Mirror is your active or resting glyph, you may reactivate any piece matching the other glyph</li>
                    <li>After reactivating, resolve any captures</li>
                </ul>

                <h3>Ending the Game</h3>
                <p><strong>Sudden Death:</strong> The game ends immediately when one player moves a golem into their opponent's first row. That player wins!</p>
                <p><strong>Extra Lives:</strong> Your opponent loses a life every time you complete a run to their back row. The golem that scores can still make captures and leave a shadow on that turn. Completing a run also returns that golem to your supply as a mask and a shadow. Bring their number of lives down to zero to win!</p>
                <p>If neither player can make a valid move, the player with more lives wins. If tied, the game is a draw.</p>

                <h3>Symbol Reference</h3>
                <p><strong>Shapes:</strong> Ω Moon, Χ Sand, Λ Peak</p>
                <p><strong>Colors:</strong> White, Orange, Blue</p>
                <p><strong>Mirror:</strong> ◇ (copies the resting glyph)</p>
            </div>
            </div>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="modal" id="tutorialModal">
        <div class="modal-content tutorial-content">
            <span class="close-modal" onclick="closeTutorial()">&times;</span>
            
            <!-- Tutorial Language Selection (shown first) -->
            <div id="tutorialLangSelect" class="tutorial-lang-select">
                <h2 style="font-family: 'Philosopher', sans-serif; margin-bottom: 20px;">Tutorial</h2>
                <p style="color: var(--silver); margin-bottom: 20px;">Select Language</p>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 200px; margin: 0 auto;">
                    <button class="btn" onclick="startTutorialWithLang('en')" style="width: 100%;">English</button>
                    <button class="btn" onclick="startTutorialWithLang('zh')" style="width: 100%; background: var(--slate); color: var(--pearl);">中文</button>
                    <button class="btn" onclick="startTutorialWithLang('es')" style="width: 100%; background: var(--slate); color: var(--pearl);">Español</button>
                </div>
            </div>
            
            <!-- Tutorial Navigation (hidden until language selected) -->
            <div class="tutorial-nav" id="tutorialNav" style="display: none;">
                <button class="tutorial-nav-btn" id="tutorialPrev" onclick="tutorialPrev()">◀ Back</button>
                <span class="tutorial-progress" id="tutorialProgress">1 / 11</span>
                <button class="tutorial-nav-btn" id="tutorialNext" onclick="tutorialNext()">Next ▶</button>
            </div>

            <!-- Tutorial Capsules (hidden until language selected) -->
            <div class="tutorial-capsules" id="tutorialCapsules" style="display: none;">
                
                <!-- Capsule 1: Objective -->
                <div class="tutorial-capsule" data-capsule="1">
                    <h2>Objective</h2>
                    <div class="tutorial-body">
                        <p>Inara is a turn-based two-player game of abstract strategy.</p>
                        <p><strong>Your goal:</strong> Complete runs on your opponent's side with your <em>golems</em> to win.</p>
                    </div>
                </div>

                <!-- Capsule 2: Components -->
                <div class="tutorial-capsule" data-capsule="2">
                    <h2>Components</h2>
                    <div class="tutorial-body">
                        <p>The game is played on an 8×8 checkered board with two players sitting across from each other.</p>
                        <p>There are <strong>7 glyphs</strong> (3 colors, 3 shapes, and a mirror), as well as <strong>9 golems</strong> for each player.</p>
                        <p>Each golem has 2 traits (a color and a shape) that match the glyphs:</p>
                        <ul>
                            <li><strong>Colors:</strong> Blue, Orange, White</li>
                            <li><strong>Shapes:</strong> Λ Peak, Χ Sand, Ω Moon</li>
                        </ul>
                    </div>
                </div>

                <!-- Capsule 3: Preparation -->
                <div class="tutorial-capsule" data-capsule="3">
                    <h2>Preparation</h2>
                    <div class="tutorial-body">
                        <p>Decide who will go first. You may play timed or untimed.</p>
                        <p>As <strong>Dark</strong>, you control the dark pieces as the starting player. Your <strong>Light</strong> opponent takes the light pieces.</p>
                        <p>Dark pieces move on light squares; light pieces move on dark squares.</p>
                        <p>Take the glyphs and give each player 3 randomly as their starting hands. The leftover glyph becomes the first player's <em>resting</em> glyph.</p>
                        <p>Each player has 9 golems. Randomly place 8 of them — one on each starting square in your first two rows. Your remaining golem is dismantled and kept in your supply as a mask.</p>
                    </div>
                </div>

                <!-- Capsule 4: Glyphs (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="4" data-interactive="true">
                    <h2>Glyphs</h2>
                    <div class="tutorial-body">
                        <p>Every turn, prime a glyph to perform one action.</p>
                        <p><strong>Actions:</strong> Step, Jump, or Reactivate</p>
                        <p>The golem performing that action must match the glyph by shape or color. The <strong>mirror glyph ◇</strong> lets you copy the resting glyph on your turn.</p>
                        <p>Once you have performed that action, the glyph you primed goes to your opponent as their resting glyph. You pick up your resting glyph into your hand.</p>
                        <p><strong>Warning:</strong> If a golem doesn't match any glyph in your hand, it cannot perform any actions that turn!</p>
                        <div class="tutorial-prompt">
                            <p>Select different glyphs and golems to see how they match:</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="select-golem-1">☐ Select a golem with a matching glyph</li>
                                <li data-objective="select-golem-2">☐ Select a different golem with a matching glyph</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 5: Steps (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="5" data-interactive="true">
                    <h2>Steps</h2>
                    <div class="tutorial-body">
                        <p><strong>Orthogonal Step:</strong> Move exactly 2 squares in a straight line (N/S/E/W). The middle square must be empty.</p>
                        <p><strong>Diagonal Step:</strong> Move exactly 1 square diagonally.</p>
                        <div class="tutorial-prompt">
                            <p>Try both types of steps:</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="ortho-step">☐ Make an orthogonal step (2 squares)</li>
                                <li data-objective="diag-step">☐ Make a diagonal step (1 square)</li>
                            </ul>
                            <button class="tutorial-reset-btn" onclick="resetTutorialScenario()">Reset</button>
                            <button class="tutorial-continue-btn" id="tutorialContinueBtn" onclick="tutorialNext()" disabled>Continue</button>
                        </div>
                    </div>
                </div>

                <!-- Capsule 6: Single Jump (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="6" data-interactive="true">
                    <h2>Jumps: Single Hop</h2>
                    <div class="tutorial-body">
                        <p>Jump <strong>diagonally</strong> over a friendly piece to land on the empty square just beyond it.</p>
                        <p>You cannot jump over enemies or empty squares.</p>
                        <div class="tutorial-prompt">
                            <p>Jump forward over one piece.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="single-jump">☐ Make a single-piece jump forward</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 7: Multi-Piece Jump (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="7" data-interactive="true">
                    <h2>Jumps: Multiple Pieces</h2>
                    <div class="tutorial-body">
                        <p>You can jump over <strong>multiple contiguous pieces</strong> in a single hop. Land on the first empty square beyond them all.</p>
                        <div class="tutorial-prompt">
                            <p>Jump over two or more pieces at once.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="multi-piece-jump">☐ Jump over multiple pieces in one hop</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 8: Chain Jumps (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="8" data-interactive="true">
                    <h2>Jumps: Chain Jumps</h2>
                    <div class="tutorial-body">
                        <p>After landing, you may <strong>continue jumping</strong> in any diagonal direction if another friendly piece is adjacent. All jumps happen in one turn!</p>
                        <div class="tutorial-prompt">
                            <p>Use your shadows as stepping stones. Make a chain jump with 2 or more hops!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="chain-jump">☐ Make a chain jump (2+ hops in one move)</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 9: Completing a Run (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="9" data-interactive="true">
                    <h2>Completing a Run</h2>
                    <div class="tutorial-body">
                        <p><strong>Dark</strong> completes a run by reaching row 1 (Light's back row).</p>
                        <p><strong>Light</strong> completes a run by reaching row 8 (Dark's back row).</p>
                        <p>In <strong>Sudden Death</strong>, the first player to complete a run wins immediately!</p>
                        <p>With <strong>multiple lives</strong>, the golem that completes the run first makes any captures at the destination square, then returns to your supply as a shadow and a mask.</p>
                        <div class="tutorial-prompt">
                            <p>Reach the top row to complete a run!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reach-goal">☐ Move a golem to row 1</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 10: Capturing (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="10" data-interactive="true">
                    <h2>Capturing</h2>
                    <div class="tutorial-body">
                        <p>Capture your opponent's pieces by surrounding them on two opposite sides between two of your pieces.</p>
                        <p>You must create this "sandwich" on your turn with the golem you moved or reactivated.</p>
                        <p>The golem you activated will only capture another golem if it does <strong>NOT</strong> match the target golem by shape or color.</p>
                        <div class="tutorial-prompt">
                            <p>Sandwich the light piece to capture it.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="capture">☐ Capture an enemy piece</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 11: Double Capture (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="11" data-interactive="true">
                    <h2>Capturing: Multiple & Immunity</h2>
                    <div class="tutorial-body">
                        <p>You can capture <strong>multiple pieces</strong> in one move if you sandwich them in different directions.</p>
                        <p>But remember: pieces that <strong>share a trait</strong> (shape or color) with your moving piece are <strong>immune</strong> to capture!</p>
                        <div class="tutorial-prompt">
                            <p>Capture two pieces at once. Notice the third piece is immune!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="double-capture">☐ Capture two pieces in one move</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 12: Safe Movement (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="12" data-interactive="true">
                    <h2>Capturing: Safe Movement</h2>
                    <div class="tutorial-body">
                        <p>You can safely move <strong>between</strong> enemy pieces if your piece shares a trait with at least one of them.</p>
                        <p>This immunity works both ways — you can't capture them, but they can't capture you either!</p>
                        <div class="tutorial-prompt">
                            <p>Move between the enemy pieces without being captured.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="safe-move">☐ Move safely between enemy pieces</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 13: Shadows (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="13" data-interactive="true">
                    <h2>Shadows</h2>
                    <div class="tutorial-body">
                        <p>After moving, you may leave a <strong>shadow</strong> on your vacated square by clicking the shadow button before moving.</p>
                        <p>Shadows act as stepping stones for diagonal jumps and block enemy movement paths.</p>
                        <p><strong>Note:</strong> Dark cannot place shadows until Light has placed one first.</p>
                        <p><strong>Warning:</strong> If ANY of your shadows is captured, ALL your shadows are removed!</p>
                        <div class="tutorial-prompt">
                            <p>The shadow toggle is already on. Move to leave a shadow behind!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="shadow-place">☐ Place a shadow</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 14: Reactivation (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="14" data-interactive="true">
                    <h2>Reactivation</h2>
                    <div class="tutorial-body">
                        <p>Instead of moving, you can <strong>reactivate</strong> a captured piece:</p>
                        <ul>
                            <li>You must have a mask in your supply and a shadow on the board</li>
                            <li>The mask must match <strong>BOTH</strong> your active glyph <strong>AND</strong> your resting glyph</li>
                            <li>If the mirror ◇ is your active or resting glyph, it copies the other glyph's requirement</li>
                            <li>Click the mask, then click a shadow to place the golem</li>
                        </ul>
                        <div class="tutorial-prompt">
                            <p>Select the right glyph and reactivate the mask onto the shadow.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate">☐ Reactivate a mask</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 15: Reactivation Capture (INTERACTIVE) -->
                <div class="tutorial-capsule" data-capsule="15" data-interactive="true">
                    <h2>Reactivation: Capture</h2>
                    <div class="tutorial-body">
                        <p>When you reactivate a golem, it can <strong>capture</strong> enemy pieces just like a regular move!</p>
                        <p>The reactivated golem captures any adjacent enemy pieces it sandwiches (that don't share a trait).</p>
                        <div class="tutorial-prompt">
                            <p>Reactivate your mask to capture the enemy piece.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate-capture">☐ Capture through reactivation</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Capsule 16: Ready to Play -->
                <div class="tutorial-capsule" data-capsule="16">
                    <h2>Ready to Play!</h2>
                    <div class="tutorial-body">
                        <p>You now know the essentials of Inara:</p>
                        <ul>
                            <li>Race to your opponent's back row to win</li>
                            <li>Use glyphs to select which pieces can move</li>
                            <li>Step, jump, and chain your way forward</li>
                            <li>Capture to defend, reactivate to recover</li>
                        </ul>
                        <p style="margin-top: 12px;"><strong>No Valid Moves:</strong> If none of your glyphs allow you to move or reactivate, the game ends and victory goes to the player with the most lives remaining. It may be a tie!</p>
                        <button class="btn" onclick="closeTutorial(); showNewGameModal();" style="margin-top: 15px; width: 100%;">Start Playing</button>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div class="modal" id="victoryModal">
        <div class="modal-content victory-content">
            <h2 id="victoryTitle">Victory!</h2>
            <p id="victoryMessage">Dark Wins!</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn" onclick="startNewGame()">Play Again</button>
                <button class="btn" onclick="closeVictoryModal()" style="background: var(--slate); color: var(--pearl);">Analyze Game</button>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div class="modal" id="aboutModal">
        <div class="modal-content" style="max-width: 360px; text-align: center;">
            <span class="close-modal" onclick="closeAbout()">&times;</span>
            
            <!-- About Language Selection (shown first) -->
            <div id="aboutLangSelect" class="tutorial-lang-select">
                <h2 style="font-size: 2rem; margin-bottom: 20px; font-family: 'Philosopher', sans-serif;">About</h2>
                <p style="color: var(--silver); margin-bottom: 20px;">Select Language</p>
                <div style="display: flex; flex-direction: column; gap: 10px; max-width: 200px; margin: 0 auto;">
                    <button class="btn" onclick="showAboutWithLang('en')" style="width: 100%;">English</button>
                    <button class="btn" onclick="showAboutWithLang('zh')" style="width: 100%; background: var(--slate); color: var(--pearl);">中文</button>
                    <button class="btn" onclick="showAboutWithLang('es')" style="width: 100%; background: var(--slate); color: var(--pearl);">Español</button>
                </div>
            </div>
            
            <!-- About Content (hidden until language selected) -->
            <div id="aboutContent" style="display: none;">
                <h2 style="font-size: 2rem; margin-bottom: 25px; font-family: 'Philosopher', sans-serif;">About</h2>
                <p id="aboutText" style="color: var(--pearl); line-height: 1.7; margin-bottom: 20px;">I've been working on this game with support from friends and family since 2017. Most of it came together within a year, some of it took longer to draw out. I hope others find as much joy and connection in playing it as I have found in making it.</p>
                <p style="color: var(--silver); font-style: italic; margin-bottom: 20px;">James Kuang<br>2025</p>
                <p id="aboutContact" style="color: var(--silver); font-size: 0.9rem;">If you have thoughts about the game, feel free to drop me a line!<br><a href="/cdn-cgi/l/email-protection#107a767b65717e775060627f647f7e3e7d75" style="color: var(--gold);"><span class="__cf_email__" data-cfemail="513b373a24303f361121233e253e3f7f3c34">[email&#160;protected]</span></a></p>
            </div>
        </div>
    </div>

    <!-- Resign Confirmation Modal -->
    <div class="modal" id="resignModal">
        <div class="modal-content" style="max-width: 340px; text-align: center;">
            <h2 style="font-size: 1.5rem; margin-bottom: 15px;">End Game?</h2>
            <p id="resignMessage" style="margin-bottom: 20px;">What would you like to do?</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn" onclick="executeResign()" style="background: #ef4444;">Resign</button>
                    <button class="btn" onclick="showDrawOffer()" style="background: #f59e0b;">Offer Draw</button>
                </div>
                <button class="btn" onclick="cancelResign()" style="background: var(--slate); color: var(--pearl);">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Draw Offer Modal -->
    <div class="modal" id="drawOfferModal">
        <div class="modal-content" style="max-width: 340px; text-align: center;">
            <h2 style="font-size: 1.5rem; margin-bottom: 15px;">Draw Offered</h2>
            <p id="drawOfferMessage" style="margin-bottom: 20px;">Dark offers a draw. Light, do you accept?</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn" onclick="acceptDraw()" style="background: #22c55e;">Accept</button>
                <button class="btn" onclick="declineDraw()" style="background: var(--slate); color: var(--pearl);">Decline</button>
            </div>
        </div>
    </div>

    <!-- Disconnect Modal -->
    <div class="modal" id="disconnectModal">
        <div class="modal-content" style="max-width: 380px; text-align: center;">
            <h2 style="font-size: 1.5rem; margin-bottom: 15px;">Opponent Disconnected</h2>
            <p style="color: var(--silver); margin-bottom: 20px;">Your game has been saved. You can resume it from Online → New Game.</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="btn" onclick="resumeFromDisconnect()" style="background: var(--gold);">Resume Game</button>
                <button class="btn" onclick="exportAndCloseDisconnect()" style="background: var(--slate); color: var(--pearl);">Export Game</button>
                <button class="btn" onclick="closeDisconnectModal()" style="background: var(--slate); color: var(--pearl);">Return to Menu</button>
            </div>
        </div>
    </div>

    <!-- Welcome Screen Modal -->
    <div class="modal show" id="welcomeModal">
        <div class="modal-content" style="max-width: 360px; text-align: center;">
            <h2 style="font-size: 2.5rem; margin-bottom: 25px; font-family: 'Philosopher', sans-serif;">INARA</h2>
            
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button class="btn" onclick="closeWelcome(); showNewGameModal();" style="padding: 14px; font-size: 1.1rem;">New Game</button>
                <button class="btn" onclick="closeWelcome(); openTutorial();" style="padding: 14px; font-size: 1.1rem; background: var(--slate); color: var(--pearl);">Tutorial</button>
                <button class="btn" onclick="closeWelcome(); toggleRules();" style="padding: 14px; font-size: 1.1rem; background: var(--slate); color: var(--pearl);">Rules</button>
                <button class="btn" onclick="closeWelcome(); document.getElementById('welcomeImportInput').click();" style="padding: 14px; font-size: 1.1rem; background: var(--slate); color: var(--pearl);">Review Game</button>
                <input type="file" id="welcomeImportInput" accept=".json" style="display:none" onchange="importGameJSON(event)">
                <button class="btn" onclick="closeWelcome(); showAbout();" style="padding: 14px; font-size: 1.1rem; background: var(--slate); color: var(--pearl);">About</button>
            </div>
        </div>
    </div>

    <!-- New Game Setup Modal -->
    <div class="modal" id="newGameModal">
        <div class="modal-content" style="max-width: 360px; text-align: center;">
            <h2 style="font-size: 1.5rem; margin-bottom: 20px;">New Game</h2>
            
            <button class="btn" onclick="startGameWithTime()" style="width: 100%; margin-bottom: 20px;">Start Game</button>
            
            <!-- CPU Opponent Toggle -->
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">Opponent</label>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn" id="humanBtn" onclick="setGameMode('human')" style="flex: 1; background: var(--gold);">Local</button>
                    <button class="btn" id="onlineBtn" onclick="setGameMode('online')" style="flex: 1; background: var(--slate); color: var(--pearl);">Online</button>
                    <button class="btn" id="cpuBtn" onclick="setGameMode('cpu')" style="flex: 1; background: var(--slate); color: var(--pearl);">CPU</button>
                </div>
            </div>
            
            <!-- CPU Side Selection (hidden when vs Human or Spectate) -->
            <div id="cpuSideSelect" style="margin-bottom: 20px; display: none;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">You Play As</label>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn" id="playDarkBtn" onclick="setPlayerSide('dark')" style="flex: 1; background: var(--gold);">Dark<br><small style="opacity: 0.7; font-size: 0.75em;">(1st Move)</small></button>
                    <button class="btn" id="playLightBtn" onclick="setPlayerSide('light')" style="flex: 1; background: var(--slate); color: var(--pearl);">Light<br><small style="opacity: 0.7; font-size: 0.75em; white-space: nowrap;">(1st Shadow)</small></button>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">Lives</label>
                <div style="display: flex; gap: 8px; justify-content: center; margin-bottom: 10px;">
                    <button class="btn lives-btn" id="lives1Btn" onclick="setLives(1)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 10px;">
                        <span style="color: #e74c3c;">♥♥</span>
                    </button>
                    <button class="btn lives-btn" id="lives2Btn" onclick="setLives(2)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 10px;">
                        <span style="color: #e74c3c;">♥♥♥</span>
                    </button>
                    <button class="btn lives-btn" id="lives3Btn" onclick="setLives(3)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 10px;">
                        <span style="color: #e74c3c;">♥♥♥♥</span>
                    </button>
                </div>
                <button class="btn lives-btn" id="lives0Btn" onclick="setLives(0)" style="width: 100%; background: var(--gold);">Sudden Death</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">Time per Player</label>
                <div class="time-display" id="timeDisplay">10:00</div>
                <input type="range" class="time-slider" id="timeSlider" min="0" max="30" value="10" oninput="updateTimeDisplay()">
                <div class="time-labels">
                    <span>No limit</span>
                    <span>30 min</span>
                </div>
            </div>
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 10px; color: var(--silver);">Increment per Move</label>
                <div class="time-display increment-display" id="incrementDisplay">+0s</div>
                <input type="range" class="time-slider" id="incrementSlider" min="0" max="30" value="0" oninput="updateIncrementDisplay()">
                <div class="time-labels">
                    <span>None</span>
                    <span>+30s</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Online Game Modal -->
    <div class="modal" id="onlineModal">
        <div class="modal-content" style="max-width: 380px; text-align: center;">
            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 20px; position: relative;">
                <button onclick="closeOnlineModal()" style="position: absolute; left: 0; background: none; border: none; color: var(--silver); font-size: 1.2rem; cursor: pointer; padding: 5px;">←</button>
                <h2 style="font-size: 1.5rem;">Play Online</h2>
            </div>
            
            <!-- Connection Status -->
            <div id="onlineStatus" style="margin-bottom: 20px; padding: 10px; border-radius: 8px; background: var(--slate);">
                <span style="color: var(--silver);">Connecting to server...</span>
            </div>
            
            <!-- Create/Join Options -->
            <div id="onlineOptions" style="display: none;">
                <!-- Saved Game Banner (hidden by default) -->
                <div id="onlineBackupBanner" style="display: none; margin-bottom: 15px; padding: 12px; background: var(--slate); border-radius: 8px; border: 1px solid var(--gold);">
                    <p style="color: var(--gold); margin-bottom: 10px; font-size: 0.9rem;">📁 You have a saved game</p>
                    <button class="btn" onclick="resumeFromBackup()" style="width: 100%; background: var(--gold); font-size: 0.9rem;">Resume Saved Game</button>
                    <button class="btn" onclick="discardBackup()" style="width: 100%; margin-top: 8px; background: transparent; color: var(--silver); font-size: 0.8rem; padding: 6px;">Discard</button>
                </div>
                
                <button class="btn" onclick="createOnlineGame()" style="width: 100%; margin-bottom: 20px;">
                    Create Game
                </button>
                
                <!-- Player Names Input -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; color: var(--silver);">Player Names</label>
                    <input type="text" id="playerNameInput" placeholder="(You)" maxlength="5"
                        style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--slate); 
                               background: var(--onyx); color: var(--pearl); font-size: 1rem; text-align: center;
                               text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 10px;">
                    <input type="text" id="opponentNameInput" placeholder="(Them)" maxlength="5"
                        style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--slate); 
                               background: var(--onyx); color: var(--pearl); font-size: 1rem; text-align: center;
                               text-transform: uppercase; letter-spacing: 0.1em;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                        <button class="btn" id="hostDarkBtn" onclick="setHostSide('dark')" style="flex: 1; background: var(--slate); color: var(--pearl); font-size: 0.85rem; padding: 10px;">
                            Dark<br><small style="opacity: 0.7;">1st<br>move</small>
                        </button>
                        <button class="btn" id="hostRandomBtn" onclick="setHostSide('random')" style="flex: 1; background: var(--gold); font-size: 0.85rem; padding: 10px;">
                            Random
                        </button>
                        <button class="btn" id="hostLightBtn" onclick="setHostSide('light')" style="flex: 1; background: var(--slate); color: var(--pearl); font-size: 0.85rem; padding: 10px;">
                            Light<br><small style="opacity: 0.7;">1st<br>shadow</small>
                        </button>
                    </div>
                    
                    <!-- Lives selector for online -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; color: var(--silver); font-size: 0.9rem;">Lives</label>
                        <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                            <button class="btn online-lives-btn" id="onlineLives1Btn" onclick="setOnlineLives(1)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 8px; font-size: 0.85rem;">
                                <span style="color: #e74c3c;">♥♥</span>
                            </button>
                            <button class="btn online-lives-btn" id="onlineLives2Btn" onclick="setOnlineLives(2)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 8px; font-size: 0.85rem;">
                                <span style="color: #e74c3c;">♥♥♥</span>
                            </button>
                            <button class="btn online-lives-btn" id="onlineLives3Btn" onclick="setOnlineLives(3)" style="flex: 1; background: var(--slate); color: var(--pearl); padding: 8px; font-size: 0.85rem;">
                                <span style="color: #e74c3c;">♥♥♥♥</span>
                            </button>
                        </div>
                        <button class="btn online-lives-btn" id="onlineLives0Btn" onclick="setOnlineLives(0)" style="width: 100%; background: var(--gold); font-size: 0.85rem;">Sudden Death</button>
                    </div>
                    
                    <!-- Move Timer for online -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: flex; align-items: center; justify-content: center; gap: 6px; margin-bottom: 8px; color: var(--silver); font-size: 0.9rem;">
                            Move Timer
                            <span class="move-timer-help" onclick="showMoveTimerHelp()" style="cursor: pointer; width: 16px; height: 16px; border-radius: 50%; background: var(--slate); color: var(--silver); font-size: 0.7rem; display: inline-flex; align-items: center; justify-content: center;">?</span>
                        </label>
                        <div class="time-display" id="moveTimerDisplay" style="font-size: 1.1rem; margin-bottom: 8px;">∞</div>
                        <input type="range" class="time-slider" id="moveTimerSlider" min="0" max="11" value="0" oninput="updateMoveTimerDisplay()">
                        <div class="time-labels">
                            <span>∞</span>
                            <span>60s</span>
                        </div>
                    </div>
                    
                    <button class="btn" onclick="document.getElementById('onlineLoadInput').click();" style="width: 100%; background: var(--slate); color: var(--pearl);">
                        Load Game
                    </button>
                    <input type="file" id="onlineLoadInput" accept=".json" style="display:none" onchange="loadOnlineGameFromFile(event)">
                </div>
                
                <div style="border-top: 1px solid var(--slate); padding-top: 20px;">
                    <label style="display: block; margin-bottom: 10px; color: var(--silver);">Join a Game</label>
                    <input type="text" id="joinCodeInput" placeholder="e.g. blue-tiger-42" 
                        style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--slate); 
                               background: var(--onyx); color: var(--pearl); font-size: 1rem; text-align: center;
                               margin-bottom: 10px;">
                    <button class="btn" onclick="joinOnlineGame()" style="width: 100%; background: var(--slate); color: var(--pearl);">
                        Join Game
                    </button>
                </div>
            </div>
            
            <!-- Waiting for opponent -->
            <div id="onlineWaiting" style="display: none;">
                <p style="color: var(--silver); margin-bottom: 15px;">Share this link with your opponent:</p>
                <div id="roomLink" style="font-size: 0.9rem; color: var(--gold); 
                                          margin-bottom: 10px; padding: 15px; background: var(--slate); border-radius: 8px;
                                          cursor: pointer; word-break: break-all;" onclick="copyRoomLink()">
                    ---
                </div>
                <p style="color: var(--silver); font-size: 0.85rem; margin-bottom: 5px;">Click to copy</p>
                <p style="color: var(--silver); font-size: 0.75rem; margin-bottom: 20px;">Room code: <span id="roomCode">----</span></p>
                <p style="color: var(--silver);">Waiting for opponent to join...</p>
                <div class="waiting-spinner" style="margin: 20px auto; width: 30px; height: 30px; border: 3px solid var(--slate); 
                                                     border-top-color: var(--gold); border-radius: 50%; animation: spin 1s linear infinite;"></div>
            </div>
            
            <!-- Joining -->
            <div id="onlineJoining" style="display: none;">
                <p style="color: var(--silver);">Connecting to game...</p>
                <div class="waiting-spinner" style="margin: 20px auto; width: 30px; height: 30px; border: 3px solid var(--slate); 
                                                     border-top-color: var(--gold); border-radius: 50%; animation: spin 1s linear infinite;"></div>
            </div>
            
            <!-- Error state -->
            <div id="onlineError" style="display: none;">
                <p id="onlineErrorMsg" style="color: #e74c3c; margin-bottom: 15px;">Connection failed</p>
                <button class="btn" onclick="retryOnlineConnection()" style="background: var(--slate); color: var(--pearl);">Try Again</button>
            </div>
            
            <button class="btn" onclick="closeOnlineModal()" style="width: 100%; margin-top: 20px; background: var(--slate); color: var(--pearl);">Cancel</button>
        </div>
    </div>

    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #joinCodeInput::placeholder {
            color: var(--silver);
            opacity: 0.5;
        }
    </style>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        // === CONSTANTS ===
        const SHAPES = ['Ω', 'Χ', 'Λ']; // Moon, Sand, Peak
        const SHAPE_NAMES = { 'Ω': 'Moon', 'Χ': 'Sand', 'Λ': 'Peak' };
        const COLORS = ['white', 'orange', 'blue'];
        const MIRROR = '◇';
        
        // === LANGUAGE / TRANSLATION SYSTEM ===
        let currentLanguage = 'en';
        let originalRulesQuick = null;
        let originalRulesFull = null;
        let originalTutorialCapsules = null;
        
        const translations = {
            zh: {
                quick: `
                <h3>目标</h3>
                <p><strong>突然死亡：</strong>将你的魔像推进到对方的底线，先到者获胜！</p>
                <p><strong>额外生命：</strong>每次成功突破都会让对手失去一条生命。将对手的生命值降为零即可获胜！</p>

                <h3>回合行动</h3>
                <ul>
                    <li>从手牌中选择一个符文</li>
                    <li>移动一个与符文形状或颜色匹配的魔像</li>
                    <li>使用镜像符文时，改为匹配休息符文</li>
                    <li>使用过的符文成为对手的休息符文</li>
                    <li>将你的休息符文收回手中</li>
                </ul>

                <h3>移动方式</h3>
                <ul>
                    <li><strong>步行：</strong>如果中间格为空，可沿正交方向移动2格，或沿对角线移动1格</li>
                    <li><strong>跳跃：</strong>沿对角线跳过己方棋子到达下一个空格</li>
                    <li>可以在一回合内连续跳跃！</li>
                </ul>

                <h3>捕获</h3>
                <ul>
                    <li>从两侧（水平或垂直）包围对方棋子</li>
                    <li>你移动的棋子不能与目标棋子的形状或颜色匹配</li>
                    <li>被捕获的魔像将其面具和影子返还给所有者的补给</li>
                </ul>

                <h3>得分（额外生命模式）</h3>
                <ul>
                    <li>完成突破的魔像仍可在该回合进行捕获和放置影子</li>
                    <li>完成突破后，该魔像作为面具和影子返回你的补给</li>
                </ul>

                <h3>影子</h3>
                <ul>
                    <li>移动后，你可以在离开的格子上放置一个影子（如果有的话）</li>
                    <li>在光方放置影子之前，暗方不能放置影子</li>
                    <li>影子可以帮助捕获和阻挡移动</li>
                    <li>如果一个影子被捕获，你所有的影子都会被移除！</li>
                </ul>

                <h3>重新激活</h3>
                <ul>
                    <li>作为移动的替代，将补给中的面具放置在你的一个影子上</li>
                    <li>面具必须同时匹配激活符文和休息符文</li>
                    <li>使用镜像时，它会复制另一个符文的要求</li>
                </ul>

                <h3>符号参考</h3>
                <p><strong>形状：</strong>Ω 月亮, Χ 沙, Λ 山峰</p>
                <p><strong>颜色：</strong>白色, 橙色, 蓝色</p>
                <p><strong>镜像：</strong>◇（复制休息符文）</p>
                `,
                full: `
                <h3>概述</h3>
                <p>换影棋是一场技巧定位和适应不断变化资源的较量。游戏开始后没有随机因素，也没有隐藏信息。</p>

                <h3>游戏材料</h3>
                <ul>
                    <li>一个8×8的棋盘，有明暗相间的格子</li>
                    <li>7个符文标记：3种形状（月亮、沙、山峰）、3种颜色（白、橙、蓝）和1个镜像</li>
                    <li>两组各9个魔像（光方和暗方），每个都有一个影子石和标记面具，显示九种独特的形状/颜色组合之一</li>
                </ul>

                <h3>游戏准备</h3>
                <ol>
                    <li>给每位玩家一组魔像。拥有暗色魔像的玩家先行。</li>
                    <li>在你的前两排交替格子上随机放置8个魔像。光方魔像放在暗格上；暗方魔像放在亮格上。</li>
                    <li>将第9个魔像放在一旁——拆解它，将面具和影子放入你的补给。</li>
                    <li>随机分配符文：暗方获得3个，光方获得3个。剩余的符文成为暗方的休息符文。</li>
                </ol>

                <h3>目标</h3>
                <p>将你的魔像推进到棋盘对面，成为第一个将魔像移入对手底线的玩家。先到者获胜！</p>

                <h3>回合摘要</h3>
                <p>玩家轮流行动。回合开始时，你手中有3个符文和1个休息符文。你必须采取行动——不能跳过回合。</p>
                <ol>
                    <li><strong>打出一个符文</strong>作为激活符文，然后：
                        <ul>
                            <li>移动一个与激活符文的形状或颜色匹配的魔像（如果镜像是激活符文，则匹配休息符文）</li>
                            <li>或者重新激活一个魔像</li>
                        </ul>
                    </li>
                    <li><strong>解决</strong>由移动或重新激活产生的捕获</li>
                    <li>通过拿起休息符文<strong>结束回合</strong></li>
                    <li>你使用的符文成为对手的新休息符文</li>
                </ol>

                <h3>如何移动</h3>
                <p>每个格子最多只能容纳一个魔像或影子。</p>
                <h4>步行</h4>
                <ul>
                    <li>沿正交方向移动2格（东/南/西/北）。这可能被中间格的对方棋子阻挡。</li>
                    <li>或者沿对角线移动1格。这不会被附近的棋子阻碍。</li>
                </ul>
                <h4>跳跃</h4>
                <ul>
                    <li>沿对角线跳过己方棋子（包括影子）到达下一个空格</li>
                    <li>你可以跳过一个或多个连续排列的棋子</li>
                    <li>可以将多次跳跃连接成一次移动</li>
                    <li>同一回合内不能跳回起始格</li>
                </ul>

                <h3>捕获棋子</h3>
                <ul>
                    <li>移动或重新激活后，你的魔像会捕获任何被移动的魔像和你的另一个棋子从两侧（水平或垂直）包围的对方棋子</li>
                    <li>移动的棋子会捕获任何与它在形状、颜色或两者上<strong>不</strong>匹配的对方棋子。形状或颜色匹配的棋子是安全的。</li>
                    <li>静止棋子的形状/颜色无关紧要——只有移动棋子的属性才重要</li>
                    <li>被捕获的棋子被拆解并返还给其所有者的补给</li>
                    <li>移入两个对方棋子之间<strong>不会</strong>导致你被捕获</li>
                </ul>

                <h3>影子</h3>
                <ul>
                    <li>当你的魔像移动时，你可以在离开的格子上放置一个影子（如果补给中有的话）</li>
                    <li><strong>在光方放置影子之前，暗方不能放置影子</strong></li>
                    <li>影子不能移动，但可以阻挡对方的步行</li>
                    <li>你的魔像可以跳过自己的影子</li>
                    <li>影子可以作为捕获的静止棋子</li>
                    <li>影子可以被任何对方棋子捕获（不需要匹配）</li>
                    <li><strong>影子捕获规则：</strong>如果你的一个影子被捕获，你所有剩余的影子立即被移除并返回补给</li>
                </ul>

                <h3>重新激活</h3>
                <ul>
                    <li>作为移动的替代，将补给中的面具放置在棋盘上你的一个影子上</li>
                    <li>面具必须同时匹配激活符文<strong>和</strong>休息符文</li>
                    <li>如果镜像是你的激活或休息符文，你可以重新激活任何匹配另一个符文的棋子</li>
                    <li>重新激活后，解决任何捕获</li>
                </ul>

                <h3>结束游戏</h3>
                <p><strong>突然死亡：</strong>当一名玩家将魔像移入对手的底线时，游戏立即结束。该玩家获胜！</p>
                <p><strong>额外生命：</strong>每次你完成突破到对手底线，对手都会失去一条生命。得分的魔像仍可在该回合进行捕获和放置影子。完成突破后，该魔像作为面具和影子返回你的补给。将对手的生命值降为零即可获胜！</p>
                <p>如果一名玩家无法采取任何有效行动（没有符文允许移动或重新激活），游戏以<strong>平局</strong>结束。</p>

                <h3>符号参考</h3>
                <p><strong>形状：</strong>Ω 月亮, Χ 沙, Λ 山峰</p>
                <p><strong>颜色：</strong>白色, 橙色, 蓝色</p>
                <p><strong>镜像：</strong>◇（复制休息符文）</p>
                `,
                tutorial: [
                    // Capsule 1: Objective
                    `<h2>目标</h2>
                    <div class="tutorial-body">
                        <p>换影棋是一款回合制双人抽象策略游戏。</p>
                        <p><strong>你的目标：</strong>用你的<em>魔像</em>在对手的底线完成突破以获胜。</p>
                    </div>`,
                    
                    // Capsule 2: Components
                    `<h2>组件</h2>
                    <div class="tutorial-body">
                        <p>游戏在一个8×8的棋盘上进行，两名玩家面对面坐着。</p>
                        <p>有<strong>7个符文</strong>（3种颜色、3种形状和一个镜像），以及每位玩家<strong>9个魔像</strong>。</p>
                        <p>每个魔像有2个与符文匹配的特征（一种颜色和一种形状）：</p>
                        <ul>
                            <li><strong>颜色：</strong>蓝色、橙色、白色</li>
                            <li><strong>形状：</strong>Λ 山峰, Χ 沙, Ω 月亮</li>
                        </ul>
                    </div>`,
                    
                    // Capsule 3: Preparation
                    `<h2>准备</h2>
                    <div class="tutorial-body">
                        <p>决定谁先行。你可以选择计时或不计时。</p>
                        <p>作为<strong>暗方</strong>，你作为先手玩家控制暗色棋子。你的<strong>光方</strong>对手使用浅色棋子。</p>
                        <p>暗色棋子在亮格上移动；浅色棋子在暗格上移动。</p>
                        <p>拿起符文，随机给每位玩家3个作为起始手牌。剩余的符文成为先手玩家的<em>休息</em>符文。</p>
                        <p>每位玩家有9个魔像。随机将8个放置在你前两排的起始格上。剩余的魔像被拆解，面具保存在你的补给中。</p>
                    </div>`,
                    
                    // Capsule 4: Glyphs (INTERACTIVE)
                    `<h2>符文</h2>
                    <div class="tutorial-body">
                        <p>每回合，激活一个符文来执行一个行动。</p>
                        <p><strong>行动：</strong>步行、跳跃或重新激活</p>
                        <p>执行该行动的魔像必须与符文的形状或颜色匹配。<strong>镜像符文 ◇</strong>让你复制当前回合的休息符文。</p>
                        <p>执行完行动后，你激活的符文成为对手的休息符文。你将休息符文收回手中。</p>
                        <p><strong>警告：</strong>如果魔像不匹配你手中的任何符文，它在该回合无法执行任何行动！</p>
                        <div class="tutorial-prompt">
                            <p>选择不同的符文和魔像来看它们如何匹配：</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="select-golem-1">☐ 选择一个与符文匹配的魔像</li>
                                <li data-objective="select-golem-2">☐ 选择另一个与符文匹配的魔像</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 5: Steps (INTERACTIVE)
                    `<h2>步行</h2>
                    <div class="tutorial-body">
                        <p><strong>正交步行：</strong>沿直线（东/南/西/北）移动正好2格。中间格必须为空。</p>
                        <p><strong>对角步行：</strong>沿对角线移动正好1格。</p>
                        <div class="tutorial-prompt">
                            <p>尝试两种步行方式：</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="ortho-step">☐ 正交步行（2格）</li>
                                <li data-objective="diag-step">☐ 对角步行（1格）</li>
                            </ul>
                            <button class="tutorial-reset-btn" onclick="resetTutorialScenario()">重置</button>
                            <button class="tutorial-continue-btn" id="tutorialContinueBtn" onclick="tutorialNext()" disabled>继续</button>
                        </div>
                    </div>`,
                    
                    // Capsule 6: Single Jump (INTERACTIVE)
                    `<h2>跳跃：单跳</h2>
                    <div class="tutorial-body">
                        <p><strong>对角</strong>跳过一个友方棋子，落在它后面的空格上。</p>
                        <p>你不能跳过敌人或空格。</p>
                        <div class="tutorial-prompt">
                            <p>向前跳过一个棋子。</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="single-jump">☐ 向前做一次单棋子跳跃</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 7: Multi-Piece Jump (INTERACTIVE)
                    `<h2>跳跃：多棋子</h2>
                    <div class="tutorial-body">
                        <p>你可以在一次跳跃中跳过<strong>多个连续的棋子</strong>。落在它们之后的第一个空格上。</p>
                        <div class="tutorial-prompt">
                            <p>一次跳过两个或更多棋子。</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="multi-piece-jump">☐ 一次跳跃跳过多个棋子</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 8: Chain Jumps (INTERACTIVE)
                    `<h2>跳跃：连续跳跃</h2>
                    <div class="tutorial-body">
                        <p>落地后，如果另一个友方棋子相邻，你可以<strong>继续</strong>向任何对角方向跳跃。所有跳跃在一回合内完成！</p>
                        <div class="tutorial-prompt">
                            <p>用你的影子作为踏脚石。进行2次或更多跳跃的连续跳跃！</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="chain-jump">☐ 进行连续跳跃（一次移动中2+次跳跃）</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 9: Completing a Run (INTERACTIVE)
                    `<h2>完成突破</h2>
                    <div class="tutorial-body">
                        <p><strong>暗方</strong>通过到达第1行（光方底线）完成突破。</p>
                        <p><strong>光方</strong>通过到达第8行（暗方底线）完成突破。</p>
                        <p>在<strong>突然死亡</strong>模式中，第一个完成突破的玩家立即获胜！</p>
                        <p>在<strong>多生命</strong>模式中，完成突破的魔像首先在目标格进行捕获，然后作为影子和面具返回你的补给。</p>
                        <div class="tutorial-prompt">
                            <p>到达顶行完成突破！</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reach-goal">☐ 将魔像移到第1行</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 10: Capturing (INTERACTIVE)
                    `<h2>捕获</h2>
                    <div class="tutorial-body">
                        <p>通过用两个己方棋子从两侧包围对方棋子来捕获它们。</p>
                        <p>你必须在回合中用你移动或重新激活的魔像创造这个"夹击"。</p>
                        <p>你激活的魔像只有在与目标魔像的形状或颜色<strong>不</strong>匹配时才会捕获它。</p>
                        <div class="tutorial-prompt">
                            <p>夹击浅色棋子来捕获它。</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="capture">☐ 捕获一个敌方棋子</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 11: Double Capture (INTERACTIVE)
                    `<h2>捕获：多重与免疫</h2>
                    <div class="tutorial-body">
                        <p>如果你在不同方向夹击多个棋子，可以在一次移动中捕获<strong>多个棋子</strong>。</p>
                        <p>但记住：与你移动的棋子<strong>共享特征</strong>（形状或颜色）的棋子<strong>免疫</strong>捕获！</p>
                        <div class="tutorial-prompt">
                            <p>一次捕获两个棋子。注意第三个棋子是免疫的！</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="double-capture">☐ 一次移动捕获两个棋子</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 12: Safe Movement (INTERACTIVE)
                    `<h2>捕获：安全移动</h2>
                    <div class="tutorial-body">
                        <p>如果你的棋子与敌方棋子至少共享一个特征，你可以安全地移动到敌方棋子<strong>之间</strong>。</p>
                        <p>这种免疫是双向的——你不能捕获它们，但它们也不能捕获你！</p>
                        <div class="tutorial-prompt">
                            <p>在敌方棋子之间移动而不被捕获。</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="safe-move">☐ 在敌方棋子之间安全移动</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 13: Shadows (INTERACTIVE)
                    `<h2>影子</h2>
                    <div class="tutorial-body">
                        <p>移动后，你可以通过在移动前点击影子按钮，在离开的格子上留下一个<strong>影子</strong>。</p>
                        <p>影子可作为对角跳跃的踏脚石，并阻挡敌人的移动路径。</p>
                        <p><strong>注意：</strong>在光方放置影子之前，暗方不能放置影子。</p>
                        <p><strong>警告：</strong>如果你的任何影子被捕获，你所有的影子都会被移除！</p>
                        <div class="tutorial-prompt">
                            <p>影子开关已打开。移动以在身后留下影子！</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="shadow-place">☐ 放置一个影子</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 14: Reactivation (INTERACTIVE)
                    `<h2>重新激活</h2>
                    <div class="tutorial-body">
                        <p>作为移动的替代，你可以<strong>重新激活</strong>一个被捕获的棋子：</p>
                        <ul>
                            <li>你必须在补给中有面具，并且棋盘上有影子</li>
                            <li>面具必须同时匹配你的激活符文<strong>和</strong>休息符文</li>
                            <li>如果镜像 ◇ 是你的激活或休息符文，它会复制另一个符文的要求</li>
                            <li>点击面具，然后点击影子来放置魔像</li>
                        </ul>
                        <div class="tutorial-prompt">
                            <p>选择正确的符文，将面具重新激活到影子上。</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate">☐ 重新激活一个面具</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 15: Reactivation Capture (INTERACTIVE)
                    `<h2>重新激活：捕获</h2>
                    <div class="tutorial-body">
                        <p>当你重新激活一个魔像时，它可以像普通移动一样<strong>捕获</strong>敌方棋子！</p>
                        <p>重新激活的魔像会捕获任何它夹击的相邻敌方棋子（不共享特征的）。</p>
                        <div class="tutorial-prompt">
                            <p>重新激活你的面具来捕获敌方棋子。</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate-capture">☐ 通过重新激活捕获</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 16: Ready to Play
                    `<h2>准备开始！</h2>
                    <div class="tutorial-body">
                        <p>你现在已经了解了Inara的基本要素：</p>
                        <ul>
                            <li>竞速到达对手底线获胜</li>
                            <li>使用符文选择哪些棋子可以移动</li>
                            <li>步行、跳跃，并连续向前推进</li>
                            <li>捕获以防守，重新激活以恢复</li>
                        </ul>
                        <p style="margin-top: 12px;"><strong>平局：</strong>如果双方都无法进行有效移动，拥有更多生命的玩家获胜。如果生命相同，则为平局。</p>
                        <button class="btn" onclick="closeTutorial(); showNewGameModal();" style="margin-top: 15px; width: 100%;">开始游戏</button>
                    </div>`
                ]
            },
            es: {
                quick: `
                <h3>Objetivo</h3>
                <p><strong>Muerte Súbita:</strong> ¡Lleva tus golems a través del tablero y sé el primero en mover uno a una casilla en la fila de inicio de tu oponente para ganar!</p>
                <p><strong>Vidas Extra:</strong> ¡Tu oponente pierde una vida cada vez que completas una de estas carreras. Reduce sus vidas a cero para ganar!</p>

                <h3>En Tu Turno</h3>
                <ul>
                    <li>Selecciona un glifo de tu mano</li>
                    <li>Mueve un golem que coincida con la forma o color del glifo</li>
                    <li>Si usas el glifo Espejo, coincide con el glifo en reposo</li>
                    <li>El glifo usado se convierte en el glifo en reposo de tu oponente</li>
                    <li>Recoge tu glifo en reposo a tu mano</li>
                </ul>

                <h3>Movimiento</h3>
                <ul>
                    <li><strong>Paso:</strong> Mueve 2 espacios ortogonalmente (N/S/E/O) si la casilla del medio está vacía, O 1 espacio en diagonal</li>
                    <li><strong>Salto:</strong> Salta diagonalmente sobre tus propias piezas hasta la siguiente casilla vacía</li>
                    <li>¡Encadena múltiples saltos en un turno!</li>
                </ul>

                <h3>Captura</h3>
                <ul>
                    <li>Rodea una pieza del oponente en lados opuestos (horizontal o vertical)</li>
                    <li>Tu pieza en movimiento NO debe coincidir con el objetivo en forma o color</li>
                    <li>Los golems capturados devuelven su máscara y sombra al suministro del propietario</li>
                </ul>

                <h3>Puntuación (Vidas Extra)</h3>
                <ul>
                    <li>Los golems que completan una carrera aún pueden hacer capturas y dejar sombras en ese turno</li>
                    <li>Completar una carrera devuelve ese golem a tu suministro como máscara y sombra</li>
                </ul>

                <h3>Sombras</h3>
                <ul>
                    <li>Después de mover, puedes dejar una sombra en la casilla desocupada (si está disponible)</li>
                    <li>Oscuro no puede colocar sombras hasta que Claro haya colocado una primero</li>
                    <li>Las sombras pueden ayudar a capturar y bloquear movimiento</li>
                    <li>¡Si UNA sombra es capturada, TODAS tus sombras son removidas!</li>
                </ul>

                <h3>Reactivación</h3>
                <ul>
                    <li>En lugar de mover, coloca una máscara de tu suministro sobre una de tus sombras</li>
                    <li>La máscara debe coincidir TANTO con el glifo activo COMO con el glifo en reposo</li>
                    <li>Si usas Espejo, copia el requisito del otro glifo</li>
                </ul>

                <h3>Símbolos</h3>
                <p><strong>Formas:</strong> Ω Luna, Χ Arena, Λ Pico</p>
                <p><strong>Colores:</strong> Blanco, Naranja, Azul</p>
                <p><strong>Espejo:</strong> ◇ (copia el glifo en reposo)</p>
                `,
                full: `
                <h3>Descripción</h3>
                <p>Inara es una contienda de posicionamiento hábil y adaptación a recursos en constante cambio. No hay azar una vez que el juego ha comenzado y no hay información oculta.</p>

                <h3>Materiales</h3>
                <ul>
                    <li>Un tablero de ajedrez (8×8) con casillas claras y oscuras</li>
                    <li>7 fichas de Glifo: 3 formas (Luna, Arena, Pico), 3 colores (Blanco, Naranja, Azul) y 1 Espejo</li>
                    <li>Dos conjuntos de 9 golems (Claro y Oscuro), cada uno con una piedra de sombra y máscara marcada mostrando una de nueve combinaciones únicas de forma/color</li>
                </ul>

                <h3>Preparación del Juego</h3>
                <ol>
                    <li>Dale a cada jugador un conjunto de golems. El jugador con golems oscuros mueve primero.</li>
                    <li>Coloca 8 de tus golems aleatoriamente en casillas alternadas en tus dos primeras filas. Los golems claros van en casillas oscuras; los golems oscuros van en casillas claras.</li>
                    <li>Deja tu 9º golem aparte—desmóntalo y pon la máscara y sombra en tu suministro.</li>
                    <li>Distribuye los glifos aleatoriamente: Oscuro recibe 3, Claro recibe 3. El glifo restante se convierte en el glifo en reposo de Oscuro.</li>
                </ol>

                <h3>Objetivo</h3>
                <p>¡Lleva tus golems a través del tablero y sé el primero en mover uno a la fila trasera de tu oponente. La victoria es tuya si lo logras antes que ellos!</p>

                <h3>Resumen del Turno</h3>
                <p>Los jugadores alternan turnos. Al inicio de tu turno, tienes 3 glifos en mano y 1 en reposo. Debes tomar una acción—no puedes pasar.</p>
                <ol>
                    <li><strong>Juega un glifo</strong> de tu mano como el glifo activo, luego:
                        <ul>
                            <li>Mueve un golem que coincida con la forma o color del glifo activo (o si Espejo está activo, coincide con el glifo en reposo)</li>
                            <li>O Reactiva un golem</li>
                        </ul>
                    </li>
                    <li><strong>Resuelve capturas</strong> resultantes del movimiento o reactivación</li>
                    <li><strong>Termina tu turno</strong> recogiendo el glifo en reposo</li>
                    <li>Tu glifo usado se convierte en el nuevo glifo en reposo para tu oponente</li>
                </ol>

                <h3>Cómo Mover</h3>
                <p>Cada casilla puede contener como máximo un golem o sombra.</p>
                <h4>Paso</h4>
                <ul>
                    <li>Mueve ortogonalmente 2 espacios (N/S/E/O). Esto puede ser bloqueado por piezas oponentes en la casilla intermedia.</li>
                    <li>O mueve 1 espacio diagonalmente. Esto no puede ser obstaculizado por piezas cercanas.</li>
                </ul>
                <h4>Salto</h4>
                <ul>
                    <li>Salta diagonalmente sobre tus propias piezas (incluyendo sombras) hasta la siguiente casilla vacía</li>
                    <li>Puedes saltar sobre una pieza o múltiples piezas alineadas en fila</li>
                    <li>Encadena varios saltos juntos como un solo movimiento</li>
                    <li>No puedes saltar de vuelta a tu casilla inicial en el mismo turno</li>
                </ul>

                <h3>Capturar Piezas</h3>
                <ul>
                    <li>Después de mover o reactivar, tu golem captura cualquier pieza oponente rodeada en dos lados opuestos (horizontal o vertical) por el golem en movimiento y otra de tus piezas</li>
                    <li>La pieza en movimiento captura cualquier pieza oponente que <strong>no</strong> coincida con ella en forma, color o ambos. Las piezas que coinciden por forma o color están a salvo.</li>
                    <li>La forma/color de la pieza estacionaria no importa—solo cuentan los atributos de la pieza en movimiento</li>
                    <li>Las piezas capturadas son desmontadas y devueltas al suministro de su propietario</li>
                    <li>Mover a una casilla entre dos piezas oponentes <strong>no</strong> resulta en tu captura</li>
                </ul>

                <h3>Sombras</h3>
                <ul>
                    <li>Cuando tu golem se mueve, puedes dejar una sombra en la casilla desocupada (si tienes una en suministro)</li>
                    <li><strong>Oscuro no puede colocar sombras hasta que Claro haya colocado una primero</strong></li>
                    <li>Las sombras no pueden moverse pero pueden bloquear pasos del oponente</li>
                    <li>Tus golems pueden saltar sobre tus propias sombras</li>
                    <li>Las sombras pueden ser piezas estacionarias para capturar</li>
                    <li>Las sombras pueden ser capturadas por cualquier pieza oponente (no se requiere coincidencia)</li>
                    <li><strong>Regla de Captura de Sombras:</strong> Si una de tus sombras es capturada, TODAS tus sombras restantes son inmediatamente removidas y devueltas a tu suministro</li>
                </ul>

                <h3>Reactivación</h3>
                <ul>
                    <li>En lugar de mover, coloca una máscara de tu suministro sobre una de tus sombras en el tablero</li>
                    <li>La máscara debe coincidir <strong>tanto</strong> con el glifo activo COMO con el glifo en reposo</li>
                    <li>Si Espejo es tu glifo activo o en reposo, puedes reactivar cualquier pieza que coincida con el otro glifo</li>
                    <li>Después de reactivar, resuelve cualquier captura</li>
                </ul>

                <h3>Fin del Juego</h3>
                <p><strong>Muerte Súbita:</strong> ¡El juego termina inmediatamente cuando un jugador mueve un golem a la primera fila de su oponente. Ese jugador gana!</p>
                <p><strong>Vidas Extra:</strong> Tu oponente pierde una vida cada vez que completas una carrera a su fila trasera. El golem que anota aún puede hacer capturas y dejar una sombra en ese turno. Completar una carrera también devuelve ese golem a tu suministro como máscara y sombra. ¡Reduce sus vidas a cero para ganar!</p>
                <p>Si ningún jugador puede realizar un movimiento válido, el jugador con más vidas gana. Si están empatados, el juego termina en <strong>empate</strong>.</p>

                <h3>Referencia de Símbolos</h3>
                <p><strong>Formas:</strong> Ω Luna, Χ Arena, Λ Pico</p>
                <p><strong>Colores:</strong> Blanco, Naranja, Azul</p>
                <p><strong>Espejo:</strong> ◇ (copia el glifo en reposo)</p>
                `,
                tutorial: [
                    // Capsule 1: Objective
                    `<h2>Objetivo</h2>
                    <div class="tutorial-body">
                        <p>Inara es un juego de estrategia abstracta por turnos para dos jugadores.</p>
                        <p><strong>Tu objetivo:</strong> Completa carreras en el lado de tu oponente con tus <em>golems</em> para ganar.</p>
                    </div>`,
                    
                    // Capsule 2: Components
                    `<h2>Componentes</h2>
                    <div class="tutorial-body">
                        <p>El juego se juega en un tablero de ajedrez 8×8 con dos jugadores sentados uno frente al otro.</p>
                        <p>Hay <strong>7 glifos</strong> (3 colores, 3 formas y un espejo), así como <strong>9 golems</strong> para cada jugador.</p>
                        <p>Cada golem tiene 2 rasgos (un color y una forma) que coinciden con los glifos:</p>
                        <ul>
                            <li><strong>Colores:</strong> Azul, Naranja, Blanco</li>
                            <li><strong>Formas:</strong> Λ Pico, Χ Arena, Ω Luna</li>
                        </ul>
                    </div>`,
                    
                    // Capsule 3: Preparation
                    `<h2>Preparación</h2>
                    <div class="tutorial-body">
                        <p>Decide quién irá primero. Puedes jugar con o sin tiempo.</p>
                        <p>Como <strong>Oscuro</strong>, controlas las piezas oscuras como jugador inicial. Tu oponente <strong>Claro</strong> toma las piezas claras.</p>
                        <p>Las piezas oscuras se mueven en casillas claras; las piezas claras se mueven en casillas oscuras.</p>
                        <p>Toma los glifos y dale a cada jugador 3 aleatoriamente como sus manos iniciales. El glifo sobrante se convierte en el glifo <em>en reposo</em> del primer jugador.</p>
                        <p>Cada jugador tiene 9 golems. Coloca aleatoriamente 8 de ellos — uno en cada casilla inicial en tus dos primeras filas. Tu golem restante se desmonta y se guarda en tu suministro como máscara.</p>
                    </div>`,
                    
                    // Capsule 4: Glyphs (INTERACTIVE)
                    `<h2>Glifos</h2>
                    <div class="tutorial-body">
                        <p>Cada turno, activa un glifo para realizar una acción.</p>
                        <p><strong>Acciones:</strong> Paso, Salto o Reactivar</p>
                        <p>El golem que realiza esa acción debe coincidir con el glifo por forma o color. El <strong>glifo espejo ◇</strong> te permite copiar el glifo en reposo en tu turno.</p>
                        <p>Una vez que hayas realizado esa acción, el glifo que activaste va a tu oponente como su glifo en reposo. Recoges tu glifo en reposo a tu mano.</p>
                        <p><strong>Advertencia:</strong> ¡Si un golem no coincide con ningún glifo en tu mano, no puede realizar ninguna acción ese turno!</p>
                        <div class="tutorial-prompt">
                            <p>Selecciona diferentes glifos y golems para ver cómo coinciden:</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="select-golem-1">☐ Selecciona un golem con un glifo coincidente</li>
                                <li data-objective="select-golem-2">☐ Selecciona un golem diferente con un glifo coincidente</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 5: Steps (INTERACTIVE)
                    `<h2>Pasos</h2>
                    <div class="tutorial-body">
                        <p><strong>Paso Ortogonal:</strong> Mueve exactamente 2 casillas en línea recta (N/S/E/O). La casilla del medio debe estar vacía.</p>
                        <p><strong>Paso Diagonal:</strong> Mueve exactamente 1 casilla diagonalmente.</p>
                        <div class="tutorial-prompt">
                            <p>Prueba ambos tipos de pasos:</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="ortho-step">☐ Haz un paso ortogonal (2 casillas)</li>
                                <li data-objective="diag-step">☐ Haz un paso diagonal (1 casilla)</li>
                            </ul>
                            <button class="tutorial-reset-btn" onclick="resetTutorialScenario()">Reiniciar</button>
                            <button class="tutorial-continue-btn" id="tutorialContinueBtn" onclick="tutorialNext()" disabled>Continuar</button>
                        </div>
                    </div>`,
                    
                    // Capsule 6: Single Jump (INTERACTIVE)
                    `<h2>Saltos: Salto Simple</h2>
                    <div class="tutorial-body">
                        <p>Salta <strong>diagonalmente</strong> sobre una pieza aliada para aterrizar en la casilla vacía justo detrás de ella.</p>
                        <p>No puedes saltar sobre enemigos o casillas vacías.</p>
                        <div class="tutorial-prompt">
                            <p>Salta hacia adelante sobre una pieza.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="single-jump">☐ Haz un salto simple hacia adelante</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 7: Multi-Piece Jump (INTERACTIVE)
                    `<h2>Saltos: Múltiples Piezas</h2>
                    <div class="tutorial-body">
                        <p>Puedes saltar sobre <strong>múltiples piezas contiguas</strong> en un solo salto. Aterriza en la primera casilla vacía más allá de todas ellas.</p>
                        <div class="tutorial-prompt">
                            <p>Salta sobre dos o más piezas a la vez.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="multi-piece-jump">☐ Salta sobre múltiples piezas en un salto</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 8: Chain Jumps (INTERACTIVE)
                    `<h2>Saltos: Saltos Encadenados</h2>
                    <div class="tutorial-body">
                        <p>Después de aterrizar, puedes <strong>continuar saltando</strong> en cualquier dirección diagonal si otra pieza aliada está adyacente. ¡Todos los saltos ocurren en un turno!</p>
                        <div class="tutorial-prompt">
                            <p>Usa tus sombras como escalones. ¡Haz un salto encadenado con 2 o más saltos!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="chain-jump">☐ Haz un salto encadenado (2+ saltos en un movimiento)</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 9: Completing a Run (INTERACTIVE)
                    `<h2>Completar una Carrera</h2>
                    <div class="tutorial-body">
                        <p><strong>Oscuro</strong> completa una carrera llegando a la fila 1 (fila trasera de Claro).</p>
                        <p><strong>Claro</strong> completa una carrera llegando a la fila 8 (fila trasera de Oscuro).</p>
                        <p>En <strong>Muerte Súbita</strong>, ¡el primer jugador en completar una carrera gana inmediatamente!</p>
                        <p>Con <strong>múltiples vidas</strong>, el golem que completa la carrera primero realiza cualquier captura en la casilla de destino, luego regresa a tu suministro como sombra y máscara.</p>
                        <div class="tutorial-prompt">
                            <p>¡Alcanza la fila superior para completar una carrera!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reach-goal">☐ Mueve un golem a la fila 1</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 10: Capturing (INTERACTIVE)
                    `<h2>Captura</h2>
                    <div class="tutorial-body">
                        <p>Captura las piezas de tu oponente rodeándolas en dos lados opuestos entre dos de tus piezas.</p>
                        <p>Debes crear este "sándwich" en tu turno con el golem que moviste o reactivaste.</p>
                        <p>El golem que activaste solo capturará otro golem si <strong>NO</strong> coincide con el golem objetivo por forma o color.</p>
                        <div class="tutorial-prompt">
                            <p>Encierra la pieza clara para capturarla.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="capture">☐ Captura una pieza enemiga</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 11: Double Capture (INTERACTIVE)
                    `<h2>Captura: Múltiple e Inmunidad</h2>
                    <div class="tutorial-body">
                        <p>Puedes capturar <strong>múltiples piezas</strong> en un movimiento si las encierras en diferentes direcciones.</p>
                        <p>¡Pero recuerda: las piezas que <strong>comparten un rasgo</strong> (forma o color) con tu pieza en movimiento son <strong>inmunes</strong> a la captura!</p>
                        <div class="tutorial-prompt">
                            <p>Captura dos piezas a la vez. ¡Nota que la tercera pieza es inmune!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="double-capture">☐ Captura dos piezas en un movimiento</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 12: Safe Movement (INTERACTIVE)
                    `<h2>Captura: Movimiento Seguro</h2>
                    <div class="tutorial-body">
                        <p>Puedes mover con seguridad <strong>entre</strong> piezas enemigas si tu pieza comparte un rasgo con al menos una de ellas.</p>
                        <p>¡Esta inmunidad funciona en ambas direcciones — no puedes capturarlas, pero ellas tampoco pueden capturarte!</p>
                        <div class="tutorial-prompt">
                            <p>Mueve entre las piezas enemigas sin ser capturado.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="safe-move">☐ Mueve con seguridad entre piezas enemigas</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 13: Shadows (INTERACTIVE)
                    `<h2>Sombras</h2>
                    <div class="tutorial-body">
                        <p>Después de mover, puedes dejar una <strong>sombra</strong> en tu casilla desocupada haciendo clic en el botón de sombra antes de mover.</p>
                        <p>Las sombras actúan como escalones para saltos diagonales y bloquean las rutas de movimiento enemigas.</p>
                        <p><strong>Nota:</strong> Oscuro no puede colocar sombras hasta que Claro haya colocado una primero.</p>
                        <p><strong>Advertencia:</strong> ¡Si CUALQUIERA de tus sombras es capturada, TODAS tus sombras son removidas!</p>
                        <div class="tutorial-prompt">
                            <p>El interruptor de sombra ya está activado. ¡Mueve para dejar una sombra atrás!</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="shadow-place">☐ Coloca una sombra</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 14: Reactivation (INTERACTIVE)
                    `<h2>Reactivación</h2>
                    <div class="tutorial-body">
                        <p>En lugar de mover, puedes <strong>reactivar</strong> una pieza capturada:</p>
                        <ul>
                            <li>Debes tener una máscara en tu suministro y una sombra en el tablero</li>
                            <li>La máscara debe coincidir <strong>TANTO</strong> con tu glifo activo <strong>COMO</strong> con tu glifo en reposo</li>
                            <li>Si el espejo ◇ es tu glifo activo o en reposo, copia el requisito del otro glifo</li>
                            <li>Haz clic en la máscara, luego en una sombra para colocar el golem</li>
                        </ul>
                        <div class="tutorial-prompt">
                            <p>Selecciona el glifo correcto y reactiva la máscara sobre la sombra.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate">☐ Reactiva una máscara</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 15: Reactivation Capture (INTERACTIVE)
                    `<h2>Reactivación: Captura</h2>
                    <div class="tutorial-body">
                        <p>¡Cuando reactivas un golem, puede <strong>capturar</strong> piezas enemigas igual que un movimiento regular!</p>
                        <p>El golem reactivado captura cualquier pieza enemiga adyacente que encierre (que no comparta un rasgo).</p>
                        <div class="tutorial-prompt">
                            <p>Reactiva tu máscara para capturar la pieza enemiga.</p>
                            <ul class="tutorial-checklist">
                                <li data-objective="reactivate-capture">☐ Captura mediante reactivación</li>
                            </ul>
                        </div>
                    </div>`,
                    
                    // Capsule 16: Ready to Play
                    `<h2>¡Listo para Jugar!</h2>
                    <div class="tutorial-body">
                        <p>Ahora conoces lo esencial de Inara:</p>
                        <ul>
                            <li>Corre hacia la fila trasera de tu oponente para ganar</li>
                            <li>Usa glifos para seleccionar qué piezas pueden moverse</li>
                            <li>Da pasos, salta y encadena tu camino hacia adelante</li>
                            <li>Captura para defender, reactiva para recuperar</li>
                        </ul>
                        <p style="margin-top: 12px;"><strong>Empate:</strong> Si ningún jugador puede moverse, el que tenga más vidas gana. Si están igualados, es empate.</p>
                        <button class="btn" onclick="closeTutorial(); showNewGameModal();" style="margin-top: 15px; width: 100%;">Comenzar a Jugar</button>
                    </div>`
                ]
            }
        };
        
        function setLanguage(lang) {
            currentLanguage = lang;
            
            // Update language button states
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
            
            // Store original English content on first call
            if (!originalRulesQuick) {
                originalRulesQuick = document.getElementById('rules-quick').innerHTML;
                originalRulesFull = document.getElementById('rules-full').innerHTML;
                originalTutorialCapsules = [];
                document.querySelectorAll('.tutorial-capsule').forEach(capsule => {
                    originalTutorialCapsules.push(capsule.innerHTML);
                });
            }
            
            // Apply translations or restore English
            if (lang === 'en' || !translations[lang]) {
                document.getElementById('rules-quick').innerHTML = originalRulesQuick;
                document.getElementById('rules-full').innerHTML = originalRulesFull;
                document.querySelectorAll('.tutorial-capsule').forEach((capsule, i) => {
                    capsule.innerHTML = originalTutorialCapsules[i];
                });
            } else {
                document.getElementById('rules-quick').innerHTML = translations[lang].quick;
                document.getElementById('rules-full').innerHTML = translations[lang].full;
                document.querySelectorAll('.tutorial-capsule').forEach((capsule, i) => {
                    if (translations[lang].tutorial[i]) {
                        capsule.innerHTML = translations[lang].tutorial[i];
                    }
                });
            }
            
            // Save preference
            localStorage.setItem('inaraLanguage', lang);
        }
        
        // Load saved language preference on startup
        function loadLanguagePreference() {
            const saved = localStorage.getItem('inaraLanguage');
            if (saved && saved !== 'en') {
                setLanguage(saved);
            }
        }

        // === DOM ELEMENT CACHE ===
        const domCache = {};
        function getEl(id) {
            if (!domCache[id]) {
                domCache[id] = document.getElementById(id);
            }
            return domCache[id];
        }

        // === GAME STATE ===
        let gameState = null;
        let cpuMode = false;  // true = playing against CPU
        let cpuPlayer = 'light';  // which side CPU plays
        let historyStack = [];
        let tutorialMode = false;  // true = in tutorial mode
        let tutorialCurrentCapsule = 1;
        let tutorialSavedState = null;
        let tutorialObjectives = {};
        let tutorialSelectedGolems = new Set(); // Track unique golems selected in Glyphs tutorial
        
        // === ONLINE MULTIPLAYER STATE ===
        let onlineMode = false;
        let localPlayer = null;  // 'dark' or 'light'
        let peer = null;
        let conn = null;
        let isHost = false;
        let selectedHostSide = 'random'; // 'dark', 'light', or 'random'
        let localPlayerName = '';
        let remotePlayerName = '';
        
        // === ANALYSIS DATA ===
        let analysisData = {
            initialState: null,
            moves: [],
            currentMoveIndex: -1, // -1 means showing initial state
            isAnalysisMode: false
        };

        // === GAME SETTINGS ===
        let selectedTime = 0; // Default timeless
        let selectedIncrement = 0; // Default no increment
        let selectedLives = 0; // Default 0 extra lives (sudden death)

        function createInitialState() {
            return {
                board: Array(8).fill(null).map(() => Array(8).fill(null)),
                currentPlayer: 'dark',
                selectedGlyph: null,
                selectedPiece: null,
                selectedMask: null,
                darkHand: [],
                lightHand: [],
                darkResting: null,
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                gameOver: false,
                lightHasPlacedShadow: false,
                shadowPrimed: false,
                darkTime: selectedTime,
                lightTime: selectedTime,
                increment: selectedIncrement,
                noTimeLimit: selectedTime === 0,
                clockInterval: null,
                lastMoveTime: null,
                lastMove: null,
                isPaused: false,
                darkLives: selectedLives + 1,
                lightLives: selectedLives + 1,
                // Move timer for online (0 = no limit)
                moveTimer: 0,
                moveTimeRemaining: 0
            };
        }

        // === INITIALIZATION ===
        function initGame() {
            if (gameState?.clockInterval) {
                clearInterval(gameState.clockInterval);
            }

            gameState = createInitialState();
            historyStack = [];
            
            // Reset board rendering state
            previousBoardState = null;
            boardInitialized = false;
            
            // Reset analysis data
            analysisData = {
                initialState: null,
                moves: [],
                currentMoveIndex: -1,
                isAnalysisMode: false
            };
            
            // Hide analysis UI if visible
            hideAnalysisUI();

            // Reset pause buttons
            const pauseBtns = document.querySelectorAll('.pause-btn');
            pauseBtns.forEach(btn => {
                btn.textContent = '⏸';
                btn.classList.remove('paused');
                btn.title = 'Pause';
            });

            setupBoard();
            distributeGlyphs();
            
            // Save initial state for analysis (after board and glyphs are set up)
            analysisData.initialState = serializeGameState();
            
            gameState.lastMoveTime = Date.now();
            startClock();
            renderGame();
        }
        
        function serializeGameState() {
            // Deep clone the relevant game state for analysis
            return {
                board: gameState.board.map(row => row.map(cell => cell ? {...cell} : null)),
                currentPlayer: gameState.currentPlayer,
                darkHand: gameState.darkHand.map(g => ({...g})),
                lightHand: gameState.lightHand.map(g => ({...g})),
                darkResting: gameState.darkResting ? {...gameState.darkResting} : null,
                lightResting: gameState.lightResting ? {...gameState.lightResting} : null,
                darkSupply: {
                    shadows: gameState.darkSupply.shadows,
                    masks: gameState.darkSupply.masks.map(m => ({...m}))
                },
                lightSupply: {
                    shadows: gameState.lightSupply.shadows,
                    masks: gameState.lightSupply.masks.map(m => ({...m}))
                },
                lightHasPlacedShadow: gameState.lightHasPlacedShadow,
                lastMove: gameState.lastMove ? {...gameState.lastMove} : null,
                darkTime: gameState.darkTime,
                lightTime: gameState.lightTime,
                noTimeLimit: gameState.noTimeLimit,
                darkLives: gameState.darkLives,
                lightLives: gameState.lightLives,
                moveTimer: gameState.moveTimer || 0
            };
        }
        
        function recordMove(moveData) {
            analysisData.moves.push({
                turnNumber: analysisData.moves.length + 1,
                timestamp: Date.now(),
                darkClock: gameState.darkTime,
                lightClock: gameState.lightTime,
                ...moveData
            });
        }

        function setupBoard() {
            const combinations = [];
            for (const shape of SHAPES) {
                for (const color of COLORS) {
                    combinations.push({ shape, color });
                }
            }

            const darkPieces = shuffle([...combinations]);
            const lightPieces = shuffle([...combinations]);

            // Light golems on rows 0-1 (top of board)
            let lightIndex = 0;
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 8; col++) {
                    if ((row + col) % 2 === 1 && lightIndex < 8) {
                        gameState.board[row][col] = {
                            type: 'golem',
                            player: 'light',
                            ...lightPieces[lightIndex++]
                        };
                    }
                }
            }
            gameState.lightSupply.masks.push(lightPieces[8]);

            // Dark golems on rows 6-7 (bottom of board)
            let darkIndex = 0;
            for (let row = 6; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if ((row + col) % 2 === 0 && darkIndex < 8) {
                        gameState.board[row][col] = {
                            type: 'golem',
                            player: 'dark',
                            ...darkPieces[darkIndex++]
                        };
                    }
                }
            }
            gameState.darkSupply.masks.push(darkPieces[8]);
        }

        function distributeGlyphs() {
            const allGlyphs = [];
            SHAPES.forEach(shape => allGlyphs.push({ type: 'shape', value: shape }));
            COLORS.forEach(color => allGlyphs.push({ type: 'color', value: color }));
            allGlyphs.push({ type: 'mirror', value: MIRROR });

            const shuffled = shuffle(allGlyphs);
            gameState.darkHand = shuffled.slice(0, 3);
            gameState.lightHand = shuffled.slice(3, 6);
            gameState.darkResting = shuffled[6];
            gameState.lightResting = null;
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // === CLOCK ===
        let lastRenderedClockDisplay = { dark: '', light: '' };
        
        function startClock() {
            if (gameState.clockInterval) clearInterval(gameState.clockInterval);
            if (!gameState.noTimeLimit) {
                // Update every 100ms for accuracy, but only render when display changes
                gameState.clockInterval = setInterval(updateClock, 100);
            }
            lastRenderedClockDisplay = { dark: '', light: '' }; // Force initial render
            renderClocks();
        }

        function updateClock() {
            if (gameState.gameOver || gameState.isPaused || gameState.noTimeLimit) {
                return;
            }

            const now = Date.now();
            const elapsed = (now - gameState.lastMoveTime) / 1000;

            if (gameState.currentPlayer === 'dark') {
                gameState.darkTime = Math.max(0, gameState.darkTime - elapsed);
                if (gameState.darkTime === 0) {
                    endGame('light', 'Dark ran out of time!');
                }
            } else {
                gameState.lightTime = Math.max(0, gameState.lightTime - elapsed);
                if (gameState.lightTime === 0) {
                    endGame('dark', 'Light ran out of time!');
                }
            }

            gameState.lastMoveTime = now;
            
            // Only render if displayed value has changed
            const darkDisplay = formatTime(gameState.darkTime);
            const lightDisplay = formatTime(gameState.lightTime);
            if (darkDisplay !== lastRenderedClockDisplay.dark || lightDisplay !== lastRenderedClockDisplay.light) {
                renderClocks();
            }
        }

        function renderClocks() {
            const darkClock = getEl('darkClock');
            const lightClock = getEl('lightClock');

            if (gameState.noTimeLimit) {
                darkClock.textContent = '∞';
                lightClock.textContent = '∞';
                darkClock.classList.remove('warning');
                lightClock.classList.remove('warning');
                lastRenderedClockDisplay.dark = '∞';
                lastRenderedClockDisplay.light = '∞';
            } else {
                const darkDisplay = formatTime(gameState.darkTime);
                const lightDisplay = formatTime(gameState.lightTime);
                darkClock.textContent = darkDisplay;
                lightClock.textContent = lightDisplay;
                darkClock.classList.toggle('warning', gameState.darkTime < 30);
                lightClock.classList.toggle('warning', gameState.lightTime < 30);
                lastRenderedClockDisplay.dark = darkDisplay;
                lastRenderedClockDisplay.light = lightDisplay;
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms}`;
        }
        
        // === MOVE TIMER (for online games) ===
        let moveTimerInterval = null;
        let moveTimerLastUpdate = null;
        
        function startMoveTimer() {
            if (moveTimerInterval) clearInterval(moveTimerInterval);
            if (!gameState.moveTimer || gameState.moveTimer === 0) return;
            
            // Only run timer if it's our turn
            if (!isLocalPlayerTurn()) return;
            
            gameState.moveTimeRemaining = gameState.moveTimer;
            moveTimerLastUpdate = Date.now();
            moveTimerInterval = setInterval(updateMoveTimer, 100);
            renderMoveTimer();
        }
        
        function stopMoveTimer() {
            if (moveTimerInterval) {
                clearInterval(moveTimerInterval);
                moveTimerInterval = null;
            }
        }
        
        function resetMoveTimer() {
            stopMoveTimer();
            if (!gameState.moveTimer || gameState.moveTimer === 0) return;
            
            gameState.moveTimeRemaining = gameState.moveTimer;
            renderMoveTimer();
            
            // Only start if it's our turn
            if (isLocalPlayerTurn()) {
                moveTimerLastUpdate = Date.now();
                moveTimerInterval = setInterval(updateMoveTimer, 100);
            }
        }
        
        function updateMoveTimer() {
            if (gameState.gameOver || gameState.isPaused) return;
            if (!isLocalPlayerTurn()) {
                stopMoveTimer();
                return;
            }
            
            const now = Date.now();
            const elapsed = (now - moveTimerLastUpdate) / 1000;
            moveTimerLastUpdate = now;
            
            gameState.moveTimeRemaining = Math.max(0, gameState.moveTimeRemaining - elapsed);
            renderMoveTimer();
            
            if (gameState.moveTimeRemaining <= 0) {
                stopMoveTimer();
                // Time's up - local player loses
                const winner = localPlayer === 'dark' ? 'light' : 'dark';
                const loserName = localPlayer === 'dark' ? 'Dark' : 'Light';
                
                // Notify opponent
                if (onlineMode && conn && conn.open) {
                    sendOnlineMessage({ type: 'timeout', loser: localPlayer });
                }
                
                endGame(winner, `${loserName} ran out of time!`);
            }
        }
        
        function renderMoveTimer() {
            // Use existing clock display for the current player
            if (!gameState.moveTimer || gameState.moveTimer === 0) return;
            
            const darkClock = getEl('darkClock');
            const lightClock = getEl('lightClock');
            
            const timeStr = Math.ceil(gameState.moveTimeRemaining) + 's';
            
            if (gameState.currentPlayer === 'dark') {
                darkClock.textContent = timeStr;
                darkClock.classList.toggle('warning', gameState.moveTimeRemaining < 5);
                lightClock.textContent = gameState.moveTimer + 's';
                lightClock.classList.remove('warning');
            } else {
                lightClock.textContent = timeStr;
                lightClock.classList.toggle('warning', gameState.moveTimeRemaining < 5);
                darkClock.textContent = gameState.moveTimer + 's';
                darkClock.classList.remove('warning');
            }
        }

        function togglePause() {
            if (gameState.gameOver) return;
            
            gameState.isPaused = !gameState.isPaused;
            
            const pauseBtns = document.querySelectorAll('.pause-btn');
            pauseBtns.forEach(btn => {
                if (gameState.isPaused) {
                    btn.textContent = '▶';
                    btn.classList.add('paused');
                    btn.title = 'Resume';
                } else {
                    btn.textContent = '⏸';
                    btn.classList.remove('paused');
                    btn.title = 'Pause';
                }
            });
            
            if (!gameState.isPaused) {
                gameState.lastMoveTime = Date.now();
            }
        }

        // === RENDERING ===
        function renderGame() {
            // Hide any open glyph choice bubble when state changes
            hideGlyphChoiceBubble();
            
            renderBoard();
            renderGlyphs();
            renderSupply();
            renderPanels();
            
            // Update online indicator if in online mode
            if (onlineMode) {
                updateOnlineIndicator();
            }
        }

        // Board state tracking moved to renderBoard delta system
        
        // Track previous board state for delta rendering
        let previousBoardState = null;
        let boardInitialized = false;
        
        function initializeBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'dark' : 'light'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.id = `sq-${row}-${col}`;
                    
                    // Coordinates will be added/updated by updateCoordinates()
                    
                    boardEl.appendChild(square);
                }
            }
            
            // Add coordinates based on flip state
            updateCoordinates();
            
            // Attach event delegation ONCE
            boardEl.addEventListener('click', function(e) {
                // In analysis mode, tapping the board advances to next move
                if (analysisData.isAnalysisMode) {
                    goToMove(analysisData.currentMoveIndex + 1);
                    return;
                }
                
                const square = e.target.closest('.square');
                if (square && square.dataset.row !== undefined && square.dataset.col !== undefined) {
                    handleSquareClick(parseInt(square.dataset.row, 10), parseInt(square.dataset.col, 10));
                }
            });
            
            boardInitialized = true;
        }
        
        function renderBoard() {
            if (!boardInitialized) {
                initializeBoard();
            }
            
            // Cache getValidMoves result to avoid duplicate calls
            let cachedMoves = null;
            const getMoves = () => {
                if (cachedMoves === null && gameState.selectedPiece) {
                    cachedMoves = getValidMoves(gameState.selectedPiece.row, gameState.selectedPiece.col);
                }
                return cachedMoves || [];
            };
            
            const validMoves = (gameState.selectedPiece && gameState.selectedGlyph) ? getMoves() : [];

            // Get projected moves when piece selected but no glyph yet
            let projectedMoves = [];
            let blockedMoves = [];
            if (gameState.selectedPiece && !gameState.selectedGlyph) {
                const piece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const matchingGlyphs = hand.filter(glyph => glyphMatchesPiece(glyph, piece));
                
                const moves = getMoves();
                
                if (matchingGlyphs.length === 0) {
                    blockedMoves = moves;
                } else {
                    projectedMoves = moves;
                }
            }

            // Get reactivation targets
            let reactivationTargets = [];
            if (gameState.selectedMask !== null && gameState.selectedGlyph && !gameState.selectedPiece) {
                const player = gameState.currentPlayer;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = gameState.board[r][c];
                        if (p?.type === 'shadow' && p.player === player) {
                            reactivationTargets.push({ row: r, col: c });
                        }
                    }
                }
            } else if (gameState.selectedGlyph && !gameState.selectedPiece && gameState.selectedMask === null) {
                reactivationTargets = getReactivationTargets();
            }

            // Get selectable pieces
            const selectablePieces = [];
            if (gameState.selectedGlyph && !gameState.selectedPiece && gameState.selectedMask === null) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (canSelectPiece(r, c)) {
                            selectablePieces.push({ row: r, col: c });
                        }
                    }
                }
            }

            // Convert arrays to Sets for O(1) lookup instead of O(n) .some()
            const toKey = (r, c) => (r << 3) | c; // Fast key: row*8 + col using bit shift
            const validSet = new Set(validMoves.map(m => toKey(m.row, m.col)));
            const projectedSet = new Set(projectedMoves.map(m => toKey(m.row, m.col)));
            const blockedSet = new Set(blockedMoves.map(m => toKey(m.row, m.col)));
            const reactivateSet = new Set(reactivationTargets.map(t => toKey(t.row, t.col)));
            const selectableSet = new Set(selectablePieces.map(p => toKey(p.row, p.col)));

            // Build current state snapshot for comparison
            const currentState = [];
            for (let row = 0; row < 8; row++) {
                currentState[row] = [];
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    const key = toKey(row, col);
                    currentState[row][col] = {
                        piece: piece ? `${piece.type}-${piece.player}-${piece.shape || ''}-${piece.color || ''}` : null,
                        isValid: validSet.has(key),
                        isProjected: projectedSet.has(key),
                        isBlocked: blockedSet.has(key),
                        isReactivate: reactivateSet.has(key),
                        isSelectable: selectableSet.has(key),
                        isLastFrom: gameState.lastMove?.fromRow === row && gameState.lastMove?.fromCol === col,
                        isLastTo: gameState.lastMove?.toRow === row && gameState.lastMove?.toCol === col,
                        isSelected: gameState.selectedPiece?.row === row && gameState.selectedPiece?.col === col
                    };
                }
            }

            // Update only changed cells
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const curr = currentState[row][col];
                    const prev = previousBoardState?.[row]?.[col];
                    
                    // Skip if nothing changed
                    if (prev && 
                        prev.piece === curr.piece &&
                        prev.isValid === curr.isValid &&
                        prev.isProjected === curr.isProjected &&
                        prev.isBlocked === curr.isBlocked &&
                        prev.isReactivate === curr.isReactivate &&
                        prev.isSelectable === curr.isSelectable &&
                        prev.isLastFrom === curr.isLastFrom &&
                        prev.isLastTo === curr.isLastTo &&
                        prev.isSelected === curr.isSelected) {
                        continue;
                    }
                    
                    const square = document.getElementById(`sq-${row}-${col}`);
                    if (!square) continue;
                    
                    // Update highlight classes
                    square.classList.toggle('highlighted', curr.isValid);
                    square.classList.toggle('projected', curr.isProjected);
                    square.classList.toggle('blocked-move', curr.isBlocked);
                    square.classList.toggle('reactivate-target', curr.isReactivate);
                    square.classList.toggle('selectable', curr.isSelectable);
                    square.classList.toggle('last-move-from', curr.isLastFrom);
                    square.classList.toggle('last-move-to', curr.isLastTo);
                    
                    // Update piece only if changed
                    if (!prev || prev.piece !== curr.piece || prev.isSelected !== curr.isSelected) {
                        // Remove old piece (keep coordinates)
                        const oldPiece = square.querySelector('.piece, .shadow-piece');
                        if (oldPiece) oldPiece.remove();
                        
                        // Add new piece
                        const piece = gameState.board[row][col];
                        if (piece) {
                            square.appendChild(createPieceElement(piece, row, col));
                        }
                    }
                }
            }
            
            previousBoardState = currentState;
        }

        function createPieceElement(piece, row, col) {
            const el = document.createElement('div');

            if (piece.type === 'shadow') {
                el.className = `shadow-piece ${piece.player}-shadow`;
            } else {
                el.className = `piece ${piece.player}-golem`;
                
                const shapeEl = document.createElement('div');
                shapeEl.className = 'piece-shape';
                shapeEl.textContent = piece.shape;
                shapeEl.style.color = getColorValue(piece.color);
                el.appendChild(shapeEl);

                if (gameState.selectedPiece?.row === row && gameState.selectedPiece?.col === col) {
                    const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                    const hasMatchingGlyph = hand.some(glyph => glyphMatchesPiece(glyph, piece));
                    
                    if (hasMatchingGlyph) {
                        el.classList.add('selected');
                    } else {
                        el.classList.add('blocked');
                    }
                }
            }

            return el;
        }

        function getColorValue(color) {
            const map = {
                'white': 'var(--glyph-white)',
                'orange': 'var(--glyph-orange)',
                'blue': 'var(--glyph-blue)'
            };
            return map[color] || '#fff';
        }

        function flashCompletedRun() {
            if (!gameState.lastMove) return;
            
            const { toRow, toCol } = gameState.lastMove;
            const square = document.getElementById(`sq-${toRow}-${toCol}`);
            if (!square) return;
            
            const piece = square.querySelector('.piece');
            if (!piece) return;
            
            // Add flash class
            piece.classList.add('run-complete');
            
            // Remove class after animation completes
            piece.addEventListener('animationend', () => {
                piece.classList.remove('run-complete');
            }, { once: true });
        }

        function animateCapture(row, col) {
            const square = document.getElementById(`sq-${row}-${col}`);
            if (!square) return;
            
            const piece = square.querySelector('.piece, .shadow-piece');
            if (!piece) return;
            
            // Clone the piece and position it absolutely over the original
            const clone = piece.cloneNode(true);
            const rect = piece.getBoundingClientRect();
            
            clone.style.position = 'fixed';
            clone.style.left = rect.left + 'px';
            clone.style.top = rect.top + 'px';
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.margin = '0';
            clone.style.pointerEvents = 'none';
            clone.style.zIndex = '1000';
            clone.classList.add('captured');
            
            document.body.appendChild(clone);
            
            // Remove clone after animation completes
            clone.addEventListener('animationend', () => {
                clone.remove();
            }, { once: true });
            
            // Fallback removal in case animationend doesn't fire
            setTimeout(() => clone.remove(), 300);
        }

        function renderGlyphs() {
            renderPlayerGlyphs('dark');
            renderPlayerGlyphs('light');
        }

        function renderPlayerGlyphs(player) {
            const handEl = getEl(`${player}Hand`);
            const restingEl = getEl(`${player}Resting`);
            const restingDesktopEl = getEl(`${player}RestingDesktop`);
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;

            handEl.innerHTML = '';
            restingEl.innerHTML = '';
            if (restingDesktopEl) restingDesktopEl.innerHTML = '';

            hand.forEach((glyph, index) => {
                handEl.appendChild(createGlyphElement(glyph, player, index, false));
            });

            if (resting) {
                restingEl.appendChild(createGlyphElement(resting, player, -1, true));
                if (restingDesktopEl) {
                    restingDesktopEl.appendChild(createGlyphElement(resting, player, -1, true));
                }
            }
        }

        function createGlyphElement(glyph, player, index, isResting) {
            const el = document.createElement('div');
            el.className = 'glyph';

            if (glyph.type === 'mirror') {
                el.classList.add('mirror');
                
                // Get the resting glyph to determine mirror appearance
                const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
                
                if (resting && !isResting) {
                    if (resting.type === 'color') {
                        // Show diamond filled with incoming color
                        const colorEl = document.createElement('div');
                        colorEl.className = 'mirror-color';
                        colorEl.style.background = getColorValue(resting.value);
                        el.appendChild(colorEl);
                    } else if (resting.type === 'shape') {
                        // Show silvery shape
                        const shapeEl = document.createElement('div');
                        shapeEl.className = 'mirror-shape';
                        shapeEl.textContent = resting.value;
                        el.appendChild(shapeEl);
                    } else {
                        // Resting is also a mirror - show default diamond
                        el.textContent = glyph.value;
                    }
                } else {
                    // No resting or is the resting glyph - show default
                    el.textContent = glyph.value;
                }
            } else if (glyph.type === 'shape') {
                const shapeEl = document.createElement('div');
                shapeEl.className = 'glyph-shape';
                shapeEl.textContent = glyph.value;
                el.appendChild(shapeEl);
            } else {
                // Color glyph - solid fill
                el.classList.add('color-glyph');
                el.style.background = getColorValue(glyph.value);
            }

            if (isResting) {
                el.classList.add('resting');
            } else if (player !== gameState.currentPlayer) {
                el.classList.add('disabled');
            } else {
                el.addEventListener('click', () => selectGlyph(player, index));
                if (gameState.selectedGlyph?.player === player && gameState.selectedGlyph?.index === index) {
                    el.classList.add('selected');
                }
                // Highlight valid glyphs in purple when a piece is selected but no glyph yet (choice required)
                if (gameState.selectedPiece && !gameState.selectedGlyph) {
                    const piece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                    if (piece && glyphMatchesPiece(glyph, piece)) {
                        el.classList.add('choice-required');
                    }
                    // Non-matching glyphs stay normal (clickable but not highlighted)
                }
                // Highlight valid glyphs when a mask is selected but no glyph yet
                if (gameState.selectedMask !== null && !gameState.selectedGlyph) {
                    const supply = gameState.currentPlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                    const mask = supply.masks[gameState.selectedMask];
                    const resting = gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
                    if (mask && resting && maskMatchesBothGlyphs(mask, glyph, resting)) {
                        el.classList.add('choice-required');
                    }
                }
            }

            return el;
        }

        function renderSupply() {
            renderShadowButton('dark');
            renderShadowButton('light');
            renderMasksDisplay('dark');
            renderMasksDisplay('light');
        }

        function renderShadowButton(player) {
            const btn = document.getElementById(`${player}ShadowBtn`);
            const countEl = document.getElementById(`${player}ShadowCount`);
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;

            countEl.textContent = supply.shadows;

            // Check if shadows are locked (Dark can't place until Light has)
            const isLocked = player === 'dark' && !gameState.lightHasPlacedShadow;
            const isCurrentPlayer = player === gameState.currentPlayer;
            const hasShadows = supply.shadows > 0;

            btn.classList.remove('locked', 'disabled', 'primed');

            if (isLocked) {
                btn.classList.add('locked');
            } else if (!isCurrentPlayer || !hasShadows) {
                btn.classList.add('disabled');
            } else if (gameState.shadowPrimed) {
                btn.classList.add('primed');
            }
        }

        function toggleShadowPrimed(player) {
            if (gameState.gameOver || gameState.isPaused) return;
            if (player !== gameState.currentPlayer) return;
            
            // In online mode, only allow on local player's turn
            if (onlineMode && !isLocalPlayerTurn()) return;

            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            if (supply.shadows === 0) return;

            // Check if locked
            if (player === 'dark' && !gameState.lightHasPlacedShadow) return;

            gameState.shadowPrimed = !gameState.shadowPrimed;
            renderSupply();
        }

        // Track scroll position per player
        const maskScrollPosition = { dark: 0, light: 0 };

        function renderMasksDisplay(player) {
            const container = document.getElementById(`${player}MasksDisplay`);
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            container.innerHTML = '';

            if (supply.masks.length === 0) return;

            // Check if player has any shadows on the board
            let hasShadows = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = gameState.board[r][c];
                    if (piece?.type === 'shadow' && piece.player === player) {
                        hasShadows = true;
                        break;
                    }
                }
                if (hasShadows) break;
            }

            // Find which masks are valid for reactivation
            const maskData = supply.masks.map((mask, index) => {
                const validGlyphIndices = [];
                if (player === gameState.currentPlayer && resting && hasShadows) {
                    hand.forEach((glyph, glyphIndex) => {
                        if (maskMatchesBothGlyphs(mask, glyph, resting)) {
                            validGlyphIndices.push(glyphIndex);
                        }
                    });
                }
                return { mask, index, validGlyphIndices, canReactivate: validGlyphIndices.length > 0 };
            });

            // Auto-scroll to first valid mask if any
            const firstValidIndex = maskData.findIndex(m => m.canReactivate);
            if (firstValidIndex !== -1 && player === gameState.currentPlayer) {
                // Scroll so the valid mask is visible (ideally first in view)
                maskScrollPosition[player] = Math.max(0, Math.min(firstValidIndex, supply.masks.length - 3));
            }

            // Clamp scroll position
            const maxScroll = Math.max(0, supply.masks.length - 3);
            maskScrollPosition[player] = Math.max(0, Math.min(maskScrollPosition[player], maxScroll));

            const needsScroll = supply.masks.length > 3;
            const scrollPos = maskScrollPosition[player];

            // Build scroller UI
            const scroller = document.createElement('div');
            scroller.className = 'masks-scroller';

            // Left arrow
            if (needsScroll) {
                const leftBtn = document.createElement('button');
                leftBtn.className = 'masks-scroll-btn';
                leftBtn.textContent = '◀';
                leftBtn.disabled = scrollPos === 0;
                leftBtn.onclick = (e) => {
                    e.stopPropagation();
                    maskScrollPosition[player] = Math.max(0, scrollPos - 1);
                    renderMasksDisplay(player);
                };
                scroller.appendChild(leftBtn);
            }

            // Viewport showing up to 3 masks
            const viewport = document.createElement('div');
            viewport.className = 'masks-viewport';

            const visibleMasks = maskData.slice(scrollPos, scrollPos + 3);
            visibleMasks.forEach(({ mask, index, validGlyphIndices, canReactivate }) => {
                const el = document.createElement('div');
                el.className = `mask-piece ${player}-mask`;
                el.textContent = mask.shape;
                el.style.color = getColorValue(mask.color);

                if (canReactivate) {
                    el.classList.add('available');
                    el.addEventListener('click', () => selectMaskForReactivation(index, validGlyphIndices));
                    
                    if (gameState.selectedMask === index) {
                        el.classList.add('selected');
                    }
                } else {
                    el.classList.add('dimmed');
                }

                viewport.appendChild(el);
            });

            scroller.appendChild(viewport);

            // Right arrow
            if (needsScroll) {
                const rightBtn = document.createElement('button');
                rightBtn.className = 'masks-scroll-btn';
                rightBtn.textContent = '▶';
                rightBtn.disabled = scrollPos >= maxScroll;
                rightBtn.onclick = (e) => {
                    e.stopPropagation();
                    maskScrollPosition[player] = Math.min(maxScroll, scrollPos + 1);
                    renderMasksDisplay(player);
                };
                scroller.appendChild(rightBtn);
            }

            container.appendChild(scroller);
        }

        function renderPanels() {
            getEl('darkPanel').classList.toggle('active', gameState.currentPlayer === 'dark');
            getEl('lightPanel').classList.toggle('active', gameState.currentPlayer === 'light');
            
            // Update lives display - only show when using extra lives (lives > 1, not sudden death)
            const showLives = gameState.darkLives > 1 || gameState.lightLives > 1;
            
            const darkLivesEl = getEl('darkLives');
            const lightLivesEl = getEl('lightLives');
            
            darkLivesEl.classList.toggle('visible', showLives);
            lightLivesEl.classList.toggle('visible', showLives);
            
            if (showLives) {
                // Use textContent for the number to prevent XSS
                darkLivesEl.innerHTML = '<span style="color: #e74c3c;">♥</span> ';
                darkLivesEl.appendChild(document.createTextNode(String(Math.floor(gameState.darkLives))));
                lightLivesEl.innerHTML = '<span style="color: #e74c3c;">♥</span> ';
                lightLivesEl.appendChild(document.createTextNode(String(Math.floor(gameState.lightLives))));
            }
        }

        // === GAME LOGIC ===
        function selectGlyph(player, index) {
            if (gameState.gameOver || gameState.isPaused || player !== gameState.currentPlayer) return;
            
            // In online mode, only allow moves on local player's turn
            if (onlineMode && !isLocalPlayerTurn()) return;

            // If a mask is selected, check if this glyph is valid for reactivation
            if (gameState.selectedMask !== null) {
                const supply = gameState.currentPlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                const mask = supply.masks[gameState.selectedMask];
                const resting = gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const glyph = hand[index];
                
                if (mask && resting && maskMatchesBothGlyphs(mask, glyph, resting)) {
                    // Valid glyph for this mask - select it (keep mask selected)
                    gameState.selectedGlyph = { player, index };
                    
                    // Tutorial objective
                    if (tutorialMode) completeTutorialObjective('select-glyph');
                    
                    renderGame();
                    return;
                }
                // Invalid glyph for this mask - ignore
                return;
            }

            // Normal glyph selection (no mask selected)
            // Toggle off if clicking same glyph
            if (gameState.selectedGlyph?.player === player && gameState.selectedGlyph?.index === index) {
                gameState.selectedGlyph = null;
                gameState.selectedPiece = null;
            } else {
                // Select this glyph
                gameState.selectedGlyph = { player, index };
                
                // Tutorial objective
                if (tutorialMode) completeTutorialObjective('select-glyph');
                
                // If a piece was selected, check if it still matches
                if (gameState.selectedPiece) {
                    const piece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                    const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                    const glyph = hand[index];
                    
                    if (!glyphMatchesPiece(glyph, piece)) {
                        // Piece doesn't match new glyph, deselect piece
                        gameState.selectedPiece = null;
                    }
                    // If piece matches, the squares will now show as green (valid moves)
                    // and player can click to complete the move
                }
            }

            renderGame();
        }

        function selectMaskForReactivation(maskIndex, validGlyphIndices) {
            if (gameState.gameOver || gameState.isPaused) return;
            
            // In online mode, only allow on local player's turn
            if (onlineMode && !isLocalPlayerTurn()) return;

            // Toggle off if clicking same mask
            if (gameState.selectedMask === maskIndex) {
                gameState.selectedMask = null;
                gameState.selectedGlyph = null;
                renderGame();
                return;
            }

            // Clear piece selection, we're doing reactivation
            gameState.selectedPiece = null;
            gameState.selectedMask = maskIndex;

            // If only one glyph works, auto-select it
            if (validGlyphIndices.length === 1) {
                gameState.selectedGlyph = { player: gameState.currentPlayer, index: validGlyphIndices[0] };
            } else {
                // Multiple glyphs work - clear glyph selection, user must choose
                gameState.selectedGlyph = null;
            }

            renderGame();
        }

        // Check if a glyph can move a specific piece
        function glyphMatchesPiece(glyph, piece) {
            if (glyph.type === 'mirror') {
                const resting = gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
                if (!resting) return false;
                return matchesGlyph(piece, resting);
            }
            return matchesGlyph(piece, glyph);
        }

        function flashChoiceRequiredGlyphs() {
            const glyphs = document.querySelectorAll('.glyph.choice-required');
            glyphs.forEach(glyph => {
                glyph.classList.remove('flash');
                // Force reflow to restart animation
                void glyph.offsetWidth;
                glyph.classList.add('flash');
            });
        }

        // Glyph choice bubble for desktop
        let activeChoiceBubble = null;

        function showGlyphChoiceBubble(row, col, targetRow, targetCol, matchingGlyphIndices) {
            // Remove any existing bubble
            hideGlyphChoiceBubble();

            const square = document.getElementById(`sq-${row}-${col}`);
            if (!square) return;

            const board = document.getElementById('board');
            const boardRect = board.getBoundingClientRect();
            const squareRect = square.getBoundingClientRect();

            // Create bubble
            const bubble = document.createElement('div');
            bubble.className = 'glyph-choice-bubble';
            bubble.id = 'glyphChoiceBubble';

            // Add matching glyphs
            const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
            matchingGlyphIndices.forEach(index => {
                const glyph = hand[index];
                const glyphEl = createGlyphElement(glyph, gameState.currentPlayer, index, false);
                glyphEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Select glyph and execute move immediately
                    gameState.selectedGlyph = { player: gameState.currentPlayer, index };
                    hideGlyphChoiceBubble();
                    saveState();
                    movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, targetRow, targetCol);
                });
                bubble.appendChild(glyphEl);
            });

            // Use fixed positioning for reliability
            bubble.style.position = 'fixed';
            document.body.appendChild(bubble);

            // Calculate position after adding to DOM
            const bubbleRect = bubble.getBoundingClientRect();
            const squareCenterX = squareRect.left + squareRect.width / 2;
            
            // Center horizontally on the square
            let left = squareCenterX - bubbleRect.width / 2;
            
            // Keep bubble within viewport horizontally
            left = Math.max(8, Math.min(left, window.innerWidth - bubbleRect.width - 8));

            // Check if there's room above the square
            const spaceAbove = squareRect.top;

            bubble.style.left = left + 'px';

            if (spaceAbove >= bubbleRect.height + 15) {
                // Position above
                bubble.classList.add('above');
                bubble.style.top = (squareRect.top - bubbleRect.height - 10) + 'px';
            } else {
                // Position below
                bubble.classList.add('below');
                bubble.style.top = (squareRect.bottom + 10) + 'px';
            }

            activeChoiceBubble = bubble;

            // Add click-outside listener
            setTimeout(() => {
                document.addEventListener('click', handleChoiceBubbleClickOutside);
            }, 0);
        }

        function hideGlyphChoiceBubble() {
            if (activeChoiceBubble) {
                activeChoiceBubble.remove();
                activeChoiceBubble = null;
            }
            document.removeEventListener('click', handleChoiceBubbleClickOutside);
        }

        function handleChoiceBubbleClickOutside(e) {
            if (activeChoiceBubble && !activeChoiceBubble.contains(e.target)) {
                hideGlyphChoiceBubble();
            }
        }

        function handleSquareClick(row, col) {
            if (gameState.gameOver || gameState.isPaused) return;
            
            // In online mode, only allow moves on local player's turn
            if (onlineMode && !isLocalPlayerTurn()) return;

            const piece = gameState.board[row][col];

            // Check for reactivation on shadow (mask selected + glyph selected)
            if (piece?.type === 'shadow' && piece.player === gameState.currentPlayer && 
                gameState.selectedMask !== null && gameState.selectedGlyph) {
                executeReactivation(row, col, gameState.selectedMask);
                return;
            }

            // Legacy: Check for reactivation on shadow (glyph selected, find matching mask)
            if (piece?.type === 'shadow' && piece.player === gameState.currentPlayer && 
                gameState.selectedGlyph && gameState.selectedMask === null) {
                const targets = getReactivationTargets();
                const target = targets.find(t => t.row === row && t.col === col);
                if (target) {
                    executeReactivation(row, col, target.maskIndex);
                    return;
                }
            }

            // Moving to valid square
            if (gameState.selectedPiece && gameState.selectedGlyph) {
                const validMoves = getValidMoves(gameState.selectedPiece.row, gameState.selectedPiece.col);
                if (validMoves.some(m => m.row === row && m.col === col)) {
                    saveState();
                    movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
                    return;
                }
            }

            // Clicking a projected square (piece selected but no glyph) - show choice bubble
            if (gameState.selectedPiece && !gameState.selectedGlyph) {
                const piece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const matchingGlyphIndices = [];
                hand.forEach((glyph, index) => {
                    if (glyphMatchesPiece(glyph, piece)) {
                        matchingGlyphIndices.push(index);
                    }
                });
                
                // Only show bubble if there are matching glyphs (choice required, not blocked)
                if (matchingGlyphIndices.length > 0) {
                    const projectedMoves = getValidMoves(gameState.selectedPiece.row, gameState.selectedPiece.col);
                    if (projectedMoves.some(m => m.row === row && m.col === col)) {
                        showGlyphChoiceBubble(row, col, row, col, matchingGlyphIndices);
                        return;
                    }
                }
            }

            // Selecting a piece (with or without glyph selected)
            if (piece?.type === 'golem' && piece.player === gameState.currentPlayer) {
                // Clear mask selection when selecting a piece
                gameState.selectedMask = null;
                
                // Toggle off if clicking same piece
                if (gameState.selectedPiece?.row === row && gameState.selectedPiece?.col === col) {
                    gameState.selectedPiece = null;
                    gameState.selectedGlyph = null;
                    renderGame();
                    return;
                }
                
                // Select this piece
                gameState.selectedPiece = { row, col };
                
                // Tutorial objective - track golem selections for Glyphs capsule
                if (tutorialMode && tutorialCurrentCapsule === 4) {
                    checkGlyphTutorialGolemSelection(row, col);
                }
                
                // If glyph already selected, check if this piece matches it
                if (gameState.selectedGlyph) {
                    if (!canSelectPiece(row, col)) {
                        // Piece doesn't match current glyph, deselect glyph
                        gameState.selectedGlyph = null;
                    }
                }
                
                // If no glyph selected (or was just deselected), check for auto-select
                if (!gameState.selectedGlyph) {
                    const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                    const matchingGlyphs = [];
                    hand.forEach((glyph, index) => {
                        if (glyphMatchesPiece(glyph, piece)) {
                            matchingGlyphs.push(index);
                        }
                    });
                    
                    // If exactly one glyph matches, auto-select it
                    if (matchingGlyphs.length === 1) {
                        gameState.selectedGlyph = { player: gameState.currentPlayer, index: matchingGlyphs[0] };
                        
                        // Tutorial objective - auto-selected glyph counts
                        if (tutorialMode) completeTutorialObjective('select-glyph');
                    }
                }
                
                renderGame();
            }
        }

        function canSelectPiece(row, col) {
            if (!gameState.selectedGlyph) return false;

            const piece = gameState.board[row][col];
            if (!piece || piece.type !== 'golem' || piece.player !== gameState.currentPlayer) return false;

            const glyph = getCurrentGlyph();

            if (glyph.type === 'mirror') {
                const resting = getOpponentResting();
                if (!resting) return false;
                return matchesGlyph(piece, resting);
            }

            return matchesGlyph(piece, glyph);
        }

        function getCurrentGlyph() {
            const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
            return hand[gameState.selectedGlyph.index];
        }

        function getOpponentResting() {
            return gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
        }

        function matchesGlyph(piece, glyph) {
            if (glyph.type === 'shape') return piece.shape === glyph.value;
            if (glyph.type === 'color') return piece.color === glyph.value;
            return false;
        }

        // === MOVEMENT ===
        function getValidMoves(row, col) {
            const moves = [];
            const piece = gameState.board[row][col];
            if (!piece || piece.type !== 'golem') return moves;

            // Orthogonal steps (2 spaces) - blocked only by OPPONENT pieces in the middle
            const orthDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dr, dc] of orthDirs) {
                const midRow = row + dr;
                const midCol = col + dc;
                const newRow = row + 2 * dr;
                const newCol = col + 2 * dc;

                if (isValidPos(newRow, newCol) && !gameState.board[newRow][newCol]) {
                    const midPiece = gameState.board[midRow][midCol];
                    // Can move if middle is empty OR middle has own piece (not blocked by own pieces)
                    // Blocked only by opponent pieces
                    if (!midPiece || midPiece.player === piece.player) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }

            // Diagonal steps (1 space) - cannot be hindered
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dr, dc] of diagDirs) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPos(newRow, newCol) && !gameState.board[newRow][newCol]) {
                    moves.push({ row: newRow, col: newCol });
                }
            }

            // Diagonal jumps - must jump over at least one own piece
            const jumps = getDiagonalJumps(row, col, piece.player, new Set([`${row},${col}`]), row, col);
            moves.push(...jumps);

            // Remove duplicates
            const seen = new Set();
            return moves.filter(m => {
                const key = `${m.row},${m.col}`;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        function getDiagonalJumps(row, col, player, visited, origRow, origCol) {
            const jumps = [];
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

            for (const [dr, dc] of diagDirs) {
                // First square must be an own piece (golem or shadow) to start a jump
                const firstRow = row + dr;
                const firstCol = col + dc;
                
                if (!isValidPos(firstRow, firstCol)) continue;
                
                // The original piece's position is empty (piece is moving) - can't jump over empty
                if (firstRow === origRow && firstCol === origCol) continue;
                
                const firstPiece = gameState.board[firstRow][firstCol];
                
                // Must be own piece - golem or shadow (not empty, not opponent)
                if (!firstPiece || firstPiece.player !== player) continue;
                
                // We have an adjacent own piece - now continue jumping over contiguous own pieces
                let checkRow = firstRow + dr;
                let checkCol = firstCol + dc;
                
                while (isValidPos(checkRow, checkCol)) {
                    // The original piece's position is effectively empty - treat as landing spot or blocker
                    if (checkRow === origRow && checkCol === origCol) {
                        // Can't land on original position (already visited), and can't jump "through" it
                        // since it's empty. Break here.
                        break;
                    }
                    
                    const checkPiece = gameState.board[checkRow][checkCol];
                    
                    if (!checkPiece) {
                        // Empty square - valid landing spot
                        const key = `${checkRow},${checkCol}`;
                        if (!visited.has(key)) {
                            jumps.push({ row: checkRow, col: checkCol });
                            visited.add(key);
                            // Chain jumps from this position
                            const chainJumps = getDiagonalJumps(checkRow, checkCol, player, visited, origRow, origCol);
                            jumps.push(...chainJumps);
                        }
                        break;
                    } else if (checkPiece.player === player) {
                        // Another own piece (golem or shadow) - continue over it
                        checkRow += dr;
                        checkCol += dc;
                    } else {
                        // Opponent piece - blocked, cannot jump over
                        break;
                    }
                }
            }

            return jumps;
        }

        function isValidPos(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const player = gameState.currentPlayer;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const glyphUsed = hand[gameState.selectedGlyph.index];
            
            // Prepare move data for analysis
            const moveData = {
                player,
                type: 'movement',
                piece: { shape: piece.shape, color: piece.color },
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                glyphUsed: { ...glyphUsed },
                shadowPlaced: null,
                captures: []
            };
            
            // Check tutorial objectives BEFORE moving
            if (tutorialMode) {
                checkTutorialMoveObjective(fromRow, fromCol, toRow, toCol);
                
                // Detect if this is a diagonal jump (moved more than 1 square diagonally)
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                // Only check for jumps if it's a diagonal move (both row and col changed)
                // Orthogonal steps (rowDiff=0 or colDiff=0) are not jumps
                if (rowDiff > 0 && colDiff > 0 && (rowDiff >= 2 || colDiff >= 2)) {
                    let piecesJumped = 0;
                    let emptySquares = 0;
                    
                    // Only count straight-line pieces if it's a straight diagonal
                    if (rowDiff === colDiff && rowDiff >= 2) {
                        const dr = toRow > fromRow ? 1 : -1;
                        const dc = toCol > fromCol ? 1 : -1;
                        let checkR = fromRow + dr;
                        let checkC = fromCol + dc;
                        while (checkR !== toRow && checkC !== toCol) {
                            if (gameState.board[checkR][checkC]) {
                                piecesJumped++;
                            } else {
                                emptySquares++;
                            }
                            checkR += dr;
                            checkC += dc;
                        }
                    } else {
                        // Non-straight diagonal path = chain jump (direction changed)
                        emptySquares = 1; // Treat as having gaps to trigger chain jump detection
                    }
                    
                    // Track for tutorial objectives
                    const squaresTraveled = Math.max(rowDiff, colDiff);
                    checkTutorialJumpObjective(fromRow, fromCol, toRow, toCol, piecesJumped, emptySquares, squaresTraveled);
                }
            }
            
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;

            gameState.lastMove = { fromRow, fromCol, toRow, toCol };

            // Check for breakthrough - dark wins by reaching row 0, light by reaching row 7
            const isBreakthrough = (piece.player === 'dark' && toRow === 0) || 
                                   (piece.player === 'light' && toRow === 7);
            
            if (isBreakthrough) {
                // Handle captures FIRST (scoring golem still participates)
                const captures = handleCaptures(toRow, toCol, piece);
                moveData.captures = captures;
                
                if (tutorialMode) {
                    recordMove(moveData);
                    completeTutorialObjective('reach-goal');
                    return;
                }
                
                // Check opponent's lives
                const opponent = piece.player === 'dark' ? 'light' : 'dark';
                
                // Decrement opponent's lives
                if (opponent === 'dark') {
                    gameState.darkLives--;
                } else {
                    gameState.lightLives--;
                }
                
                const remainingLives = opponent === 'dark' ? gameState.darkLives : gameState.lightLives;
                
                // If opponent has no lives left, immediate win
                if (remainingLives <= 0) {
                    recordMove(moveData);
                    endGame(piece.player);
                    return;
                }
                
                // Dismantle scoring golem back to scorer's supply as mask + shadow
                gameState.board[toRow][toCol] = null;
                const supply = piece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                supply.masks.push({ shape: piece.shape, color: piece.color });
                supply.shadows++;
                
                // Place shadow on origin square if primed (before checking game end)
                const canPlaceShadow = supply.shadows > 0 && 
                    (piece.player === 'light' || gameState.lightHasPlacedShadow);
                if (canPlaceShadow && gameState.shadowPrimed) {
                    placeShadow(fromRow, fromCol, piece.player);
                    moveData.shadowPlaced = { row: fromRow, col: fromCol };
                }
                gameState.shadowPrimed = false;
                
                // Record move data for breakthrough
                moveData.breakthrough = true;
                moveData.dismantled = { shape: piece.shape, color: piece.color };
                recordMove(moveData);
                
                // Send move to opponent in online mode
                if (onlineMode && isLocalPlayerTurn()) {
                    sendOnlineMessage({
                        type: 'move',
                        move: moveData
                    });
                }
                
                // Game continues - show breakthrough notification
                showBreakthroughNotification(piece.player, remainingLives);
                
                completeTurn();
                return;
            }

            // Handle captures (and collect capture data)
            const captures = handleCaptures(toRow, toCol, piece);
            moveData.captures = captures;
            
            // Check tutorial capture objectives
            if (tutorialMode && captures.length > 0) {
                checkTutorialCaptureObjective(captures.length);
            }
            
            // Check tutorial safe move objective (moved between enemies without being captured)
            if (tutorialMode && captures.length === 0) {
                checkTutorialSafeMoveObjective(toRow, toCol);
            }

            // Place shadow if primed
            const supply = piece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            const canPlaceShadow = supply.shadows > 0 && 
                (piece.player === 'light' || gameState.lightHasPlacedShadow);

            if (canPlaceShadow && gameState.shadowPrimed) {
                placeShadow(fromRow, fromCol, piece.player);
                moveData.shadowPlaced = { row: fromRow, col: fromCol };
                
                // Check tutorial shadow objective
                if (tutorialMode) {
                    checkTutorialShadowObjective();
                }
            }

            // Reset shadow primed state
            gameState.shadowPrimed = false;

            // Record the move for analysis
            recordMove(moveData);
            
            // Send move to opponent in online mode
            if (onlineMode && isLocalPlayerTurn()) {
                sendOnlineMessage({
                    type: 'move',
                    move: moveData
                });
            }

            completeTurn();
        }

        function placeShadow(row, col, player) {
            if (gameState.board[row][col]) {
                return; // Square occupied (shouldn't happen but safety check)
            }
            
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            
            // Safety check: don't go negative
            if (supply.shadows <= 0) {
                console.warn('Attempted to place shadow with none available');
                return;
            }

            gameState.board[row][col] = { type: 'shadow', player };
            supply.shadows--;

            if (player === 'light') {
                gameState.lightHasPlacedShadow = true;
            }
        }

        // === CAPTURES ===
        function handleCaptures(row, col, movingPiece) {
            const directions = [
                [[0, -1], [0, 1]],   // horizontal
                [[-1, 0], [1, 0]]    // vertical
            ];

            const capturedShadowOwners = new Set();
            const captures = []; // Track captures for analysis

            for (const [dir1, dir2] of directions) {
                // Check both directions
                for (const dir of [dir1, dir2]) {
                    const enemyRow = row + dir[0];
                    const enemyCol = col + dir[1];
                    const supportRow = row + dir[0] * 2;
                    const supportCol = col + dir[1] * 2;

                    if (!isValidPos(enemyRow, enemyCol) || !isValidPos(supportRow, supportCol)) continue;

                    const enemyPiece = gameState.board[enemyRow][enemyCol];
                    const supportPiece = gameState.board[supportRow][supportCol];

                    if (!enemyPiece || !supportPiece) continue;
                    if (enemyPiece.player === movingPiece.player) continue;
                    if (supportPiece.player !== movingPiece.player) continue;

                    // Check if capture is valid
                    if (canCapture(movingPiece, enemyPiece)) {
                        // Record capture data before removing
                        captures.push({
                            piece: enemyPiece.type === 'shadow' 
                                ? { type: 'shadow', player: enemyPiece.player }
                                : { shape: enemyPiece.shape, color: enemyPiece.color },
                            position: { row: enemyRow, col: enemyCol }
                        });
                        // Animate the capture before removing from board
                        animateCapture(enemyRow, enemyCol);
                        capturePiece(enemyRow, enemyCol, enemyPiece, capturedShadowOwners);
                    }
                }
            }

            // Remove all shadows of captured shadow owners (shadow cascade)
            for (const owner of capturedShadowOwners) {
                removeAllShadows(owner);
                // Mark that a shadow cascade occurred
                captures.forEach(c => {
                    if (c.piece.type === 'shadow' && c.piece.player === owner) {
                        c.shadowCascade = true;
                    }
                });
            }
            
            return captures;
        }

        function canCapture(movingPiece, targetPiece) {
            if (targetPiece.type === 'shadow') return true;
            if (movingPiece.shape === targetPiece.shape) return false;
            if (movingPiece.color === targetPiece.color) return false;
            return true;
        }

        function capturePiece(row, col, piece, capturedShadowOwners) {
            gameState.board[row][col] = null;
            const supply = piece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;

            if (piece.type === 'shadow') {
                capturedShadowOwners.add(piece.player);
                supply.shadows++; // Return the captured shadow to supply
            } else {
                supply.shadows++;
                supply.masks.push({ shape: piece.shape, color: piece.color });
            }
        }

        function removeAllShadows(player) {
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'shadow' && piece.player === player) {
                        // Animate the shadow before removing
                        animateCapture(row, col);
                        gameState.board[row][col] = null;
                        supply.shadows++;
                    }
                }
            }
        }

        // === REACTIVATION ===
        function getReactivationTargets() {
            if (!gameState.selectedGlyph) return [];

            const player = gameState.currentPlayer;
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;

            if (!resting || supply.masks.length === 0) return [];

            const targets = [];
            const activeGlyph = getCurrentGlyph();

            // Find all shadows
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'shadow' && piece.player === player) {
                        // Check if any mask matches both glyphs
                        supply.masks.forEach((mask, maskIndex) => {
                            if (maskMatchesBothGlyphs(mask, activeGlyph, resting)) {
                                targets.push({ row, col, maskIndex });
                            }
                        });
                    }
                }
            }

            return targets;
        }

        function maskMatchesBothGlyphs(mask, activeGlyph, restingGlyph) {
            const matchActive = glyphMatchesMask(activeGlyph, mask, restingGlyph);
            const matchResting = glyphMatchesMask(restingGlyph, mask, activeGlyph);
            return matchActive && matchResting;
        }

        function glyphMatchesMask(glyph, mask, otherGlyph) {
            if (glyph.type === 'mirror') {
                // Mirror copies the other glyph
                return glyphMatchesMask(otherGlyph, mask, null);
            }
            if (glyph.type === 'shape') return mask.shape === glyph.value;
            if (glyph.type === 'color') return mask.color === glyph.value;
            return false;
        }

        function maskMatchesGlyphs(mask, glyphIndex) {
            const player = gameState.currentPlayer;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            const activeGlyph = hand[glyphIndex];

            if (!resting) return false;
            return maskMatchesBothGlyphs(mask, activeGlyph, resting);
        }

        function executeReactivation(row, col, maskIndex) {
            saveState();

            const player = gameState.currentPlayer;
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const mask = supply.masks[maskIndex];
            const glyphUsed = hand[gameState.selectedGlyph.index];

            // Prepare move data for analysis
            const moveData = {
                player,
                type: 'reactivation',
                mask: { shape: mask.shape, color: mask.color },
                position: { row, col },
                glyphUsed: { ...glyphUsed },
                captures: []
            };

            // Remove shadow and place golem
            gameState.board[row][col] = {
                type: 'golem',
                player,
                shape: mask.shape,
                color: mask.color
            };

            supply.masks.splice(maskIndex, 1);

            gameState.lastMove = { fromRow: row, fromCol: col, toRow: row, toCol: col };

            // Handle captures from reactivation
            const captures = handleCaptures(row, col, gameState.board[row][col]);
            moveData.captures = captures;

            // Record the move for analysis
            recordMove(moveData);
            
            // Send move to opponent in online mode
            if (onlineMode && isLocalPlayerTurn()) {
                sendOnlineMessage({
                    type: 'move',
                    move: moveData
                });
            }

            // Check tutorial reactivation objective
            if (tutorialMode && tutorialCurrentCapsule === 14) {
                completeTutorialObjective('reactivate');
            }
            
            // Check tutorial reactivation capture objective
            if (tutorialMode && tutorialCurrentCapsule === 15 && captures.length > 0) {
                completeTutorialObjective('reactivate-capture');
            }

            completeTurn();
        }

        // === TURN MANAGEMENT ===
        function completeTurn() {
            const player = gameState.currentPlayer;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const usedGlyph = hand.splice(gameState.selectedGlyph.index, 1)[0];

            // Add increment to the player who just moved (before switching)
            if (!gameState.noTimeLimit && gameState.increment > 0) {
                if (player === 'dark') {
                    gameState.darkTime += gameState.increment;
                } else {
                    gameState.lightTime += gameState.increment;
                }
            }

            // Pick up resting glyph
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            if (resting) {
                hand.push(resting);
            }

            // Tutorial mode: keep it Dark's turn, simulate glyph exchange
            if (tutorialMode) {
                // In tutorial, we simulate Light's turn:
                // 1. The glyph Dark just used (usedGlyph) goes to Light as their resting
                // 2. Light "uses" a random glyph from their hand (becomes Dark's new resting)
                // 3. Light picks up their resting (the glyph Dark just used)
                
                // Determine which glyphs Light currently has (all glyphs not in Dark's hand or Dark's resting)
                const allGlyphs = [
                    { type: 'shape', value: 'Λ' },
                    { type: 'shape', value: 'Χ' },
                    { type: 'shape', value: 'Ω' },
                    { type: 'color', value: 'white' },
                    { type: 'color', value: 'blue' },
                    { type: 'color', value: 'orange' },
                    { type: 'mirror', value: '◇' }
                ];
                
                // Find glyphs not in Dark's hand and not Dark's current resting
                const darkHandKeys = gameState.darkHand.map(g => g.type + ':' + g.value);
                const darkRestingKey = gameState.darkResting ? gameState.darkResting.type + ':' + gameState.darkResting.value : null;
                const lightGlyphs = allGlyphs.filter(g => {
                    const key = g.type + ':' + g.value;
                    return !darkHandKeys.includes(key) && key !== darkRestingKey;
                });
                
                // Light "uses" a random glyph from their hand, which becomes Dark's new resting
                if (lightGlyphs.length > 0) {
                    const randomIndex = Math.floor(Math.random() * lightGlyphs.length);
                    gameState.darkResting = JSON.parse(JSON.stringify(lightGlyphs[randomIndex]));
                }
                
                gameState.currentPlayer = 'dark'; // Stay as Dark
                
                gameState.selectedGlyph = null;
                gameState.selectedPiece = null;
                gameState.selectedMask = null;
                gameState.lastMoveTime = Date.now();

                renderGame();
                flashCompletedRun();
                return;
            }

            // Normal game: Set opponent's resting and switch players
            if (player === 'dark') {
                gameState.lightResting = usedGlyph;
                gameState.darkResting = null;
                gameState.currentPlayer = 'light';
            } else {
                gameState.darkResting = usedGlyph;
                gameState.lightResting = null;
                gameState.currentPlayer = 'dark';
            }

            gameState.selectedGlyph = null;
            gameState.selectedPiece = null;
            gameState.selectedMask = null;
            gameState.lastMoveTime = Date.now();

            renderGame();
            
            // Flash the golem that just completed its run
            flashCompletedRun();

            // Check for no valid actions
            if (!hasValidActions(gameState.currentPlayer)) {
                // In lives mode, player with more lives wins
                if (gameState.darkLives > 1 || gameState.lightLives > 1) {
                    if (gameState.darkLives > gameState.lightLives) {
                        endGame('dark', 'No valid moves - Dark wins with more lives!');
                    } else if (gameState.lightLives > gameState.darkLives) {
                        endGame('light', 'No valid moves - Light wins with more lives!');
                    } else {
                        endGame('draw', 'No valid moves - Draw (equal lives)!');
                    }
                } else {
                    endGame('draw', 'Draw - no valid moves available!');
                }
            }
            
            // Reset move timer for online games
            if (onlineMode && gameState.moveTimer > 0) {
                resetMoveTimer();
            }
            
            // Auto-save online game for disconnect recovery
            if (onlineMode) {
                saveOnlineGameBackup();
            }
            
            // Trigger CPU move if it's CPU's turn
            triggerCpuMoveIfNeeded();
        }

        function hasValidActions(player) {
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;

            for (let i = 0; i < hand.length; i++) {
                const glyph = hand[i];
                const effectiveGlyph = glyph.type === 'mirror' ? resting : glyph;

                if (!effectiveGlyph) continue;

                // Check if any golem can move with this glyph
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = gameState.board[row][col];
                        if (piece?.type === 'golem' && piece.player === player) {
                            if (matchesGlyph(piece, effectiveGlyph)) {
                                if (getValidMoves(row, col).length > 0) return true;
                            }
                        }
                    }
                }

                // Check for reactivation with this glyph
                if (resting) {
                    const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                    for (const mask of supply.masks) {
                        if (maskMatchesBothGlyphs(mask, glyph, resting)) {
                            // Check if there's a shadow to reactivate on
                            for (let row = 0; row < 8; row++) {
                                for (let col = 0; col < 8; col++) {
                                    const piece = gameState.board[row][col];
                                    if (piece?.type === 'shadow' && piece.player === player) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return false;
        }

        // === CPU PLAYER (V3 Heuristic) ===
        
        function getCpuLegalMoves(player) {
            const moves = [];
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            
            // Shadow lock: Dark can only place shadows if Light has placed one
            const canPlaceShadow = supply.shadows > 0 && 
                (player === 'light' || gameState.lightHasPlacedShadow);

            for (let glyphIndex = 0; glyphIndex < hand.length; glyphIndex++) {
                const glyph = hand[glyphIndex];
                const effectiveGlyph = glyph.type === 'mirror' ? resting : glyph;
                if (!effectiveGlyph) continue;

                // Movement moves
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = gameState.board[row][col];
                        if (piece?.type === 'golem' && piece.player === player) {
                            if (matchesGlyph(piece, effectiveGlyph)) {
                                const destinations = getValidMoves(row, col);
                                for (const dest of destinations) {
                                    moves.push({
                                        type: 'movement',
                                        glyphIndex,
                                        from: { row, col },
                                        to: dest,
                                        placeShadow: false
                                    });
                                    if (canPlaceShadow) {
                                        moves.push({
                                            type: 'movement',
                                            glyphIndex,
                                            from: { row, col },
                                            to: dest,
                                            placeShadow: true
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                // Reactivation moves
                if (resting && supply.masks.length > 0) {
                    for (let maskIndex = 0; maskIndex < supply.masks.length; maskIndex++) {
                        const mask = supply.masks[maskIndex];
                        if (maskMatchesBothGlyphs(mask, glyph, resting)) {
                            for (let row = 0; row < 8; row++) {
                                for (let col = 0; col < 8; col++) {
                                    const piece = gameState.board[row][col];
                                    if (piece?.type === 'shadow' && piece.player === player) {
                                        moves.push({
                                            type: 'reactivation',
                                            glyphIndex,
                                            maskIndex,
                                            position: { row, col }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return moves;
        }

        function cpuPredictCaptures(move, player) {
            if (move.type === 'reactivation') return 0;
            
            const toRow = move.to.row;
            const toCol = move.to.col;
            const movingPiece = gameState.board[move.from.row][move.from.col];
            let captures = 0;
            
            const directions = [
                [[0, -1], [0, 1]],
                [[-1, 0], [1, 0]]
            ];
            
            for (const [dir1, dir2] of directions) {
                for (const dir of [dir1, dir2]) {
                    const enemyRow = toRow + dir[0];
                    const enemyCol = toCol + dir[1];
                    const supportRow = toRow + dir[0] * 2;
                    const supportCol = toCol + dir[1] * 2;
                    
                    if (!isValidPos(enemyRow, enemyCol) || !isValidPos(supportRow, supportCol)) continue;
                    
                    const enemyPiece = gameState.board[enemyRow][enemyCol];
                    const supportPiece = gameState.board[supportRow][supportCol];
                    
                    if (!enemyPiece || !supportPiece) continue;
                    if (enemyPiece.player === player) continue;
                    if (supportPiece.player !== player) continue;
                    
                    if (canCapture(movingPiece, enemyPiece)) {
                        captures++;
                    }
                }
            }
            
            return captures;
        }

        function cpuFindBlockingMoves(moves, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const opponentGoalRow = player === 'dark' ? 7 : 0;
            const blocking = [];
            
            // Find opponent pieces that can win next turn
            const threats = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'golem' && piece.player === opponent) {
                        const pieceMoves = getValidMoves(row, col);
                        for (const dest of pieceMoves) {
                            if (dest.row === opponentGoalRow) {
                                threats.push({ from: { row, col }, to: dest, piece });
                            }
                        }
                    }
                }
            }
            
            if (threats.length === 0) return [];
            
            for (const move of moves) {
                if (move.type !== 'movement') continue;
                
                for (const threat of threats) {
                    // Can we capture the threatening piece?
                    if (move.to.row === threat.from.row && move.to.col === threat.from.col) {
                        const movingPiece = gameState.board[move.from.row][move.from.col];
                        if (canCapture(movingPiece, threat.piece)) {
                            blocking.push(move);
                        }
                    }
                    // Can we block the destination?
                    if (move.to.row === threat.to.row && move.to.col === threat.to.col) {
                        blocking.push(move);
                    }
                }
            }
            
            return blocking;
        }

        function cpuMoveExposesToCapture(move) {
            if (move.type !== 'movement') return false;
            
            const player = gameState.currentPlayer;
            const opponent = player === 'dark' ? 'light' : 'dark';
            const destRow = move.to.row;
            const destCol = move.to.col;
            
            const directions = [
                [[-1, 0], [1, 0]],
                [[0, -1], [0, 1]]
            ];
            
            for (const [d1, d2] of directions) {
                const pos1 = { row: destRow + d1[0], col: destCol + d1[1] };
                const pos2 = { row: destRow + d2[0], col: destCol + d2[1] };
                
                if (!isValidPos(pos1.row, pos1.col) || !isValidPos(pos2.row, pos2.col)) continue;
                
                const piece1 = gameState.board[pos1.row][pos1.col];
                const piece2 = gameState.board[pos2.row][pos2.col];
                
                if (piece1?.player === opponent && piece2?.player === opponent) {
                    return true;
                }
            }
            
            return false;
        }

        function cpuHasOtherGlyphForPiece(piece, usedGlyphIndex, player) {
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            
            for (let i = 0; i < hand.length; i++) {
                if (i === usedGlyphIndex) continue;
                
                const glyph = hand[i];
                const effectiveGlyph = glyph.type === 'mirror' ? resting : glyph;
                if (!effectiveGlyph) continue;
                
                if (matchesGlyph(piece, effectiveGlyph)) {
                    return true;
                }
            }
            return false;
        }

        // Evaluate shadow placement as an offensive launchpad
        function cpuEvaluateShadowLaunchpad(shadowPos, player) {
            const goalRow = player === 'dark' ? 0 : 7;
            const direction = player === 'dark' ? -1 : 1;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            
            let launchpadScore = 0;
            
            // Check all 4 diagonal directions - who can jump OVER this shadow?
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for (const [dr, dc] of diagDirs) {
                // Piece that would jump is at shadowPos - (dr, dc)
                const jumperRow = shadowPos.row - dr;
                const jumperCol = shadowPos.col - dc;
                // Landing spot is at shadowPos + (dr, dc)
                const landRow = shadowPos.row + dr;
                const landCol = shadowPos.col + dc;
                
                if (!isValidPos(jumperRow, jumperCol) || !isValidPos(landRow, landCol)) continue;
                
                const jumper = gameState.board[jumperRow][jumperCol];
                const landing = gameState.board[landRow][landCol];
                
                // Need: friendly golem at jumper pos, empty landing, landing is toward goal
                if (!jumper || jumper.type !== 'golem' || jumper.player !== player) continue;
                if (landing) continue; // Landing must be empty
                
                // Is this jump toward our goal?
                const jumpTowardGoal = player === 'dark' 
                    ? landRow < jumperRow 
                    : landRow > jumperRow;
                if (!jumpTowardGoal) continue;
                
                // Can we actually move this jumper? Check glyphs
                let canMoveJumper = false;
                for (const glyph of hand) {
                    const effectiveGlyph = glyph.type === 'mirror' && resting ? resting : glyph;
                    if (!effectiveGlyph) continue;
                    
                    const matches = effectiveGlyph.type === 'color'
                        ? jumper.color === effectiveGlyph.value
                        : effectiveGlyph.type === 'shape'
                            ? jumper.shape === effectiveGlyph.value
                            : false;
                    
                    if (matches) {
                        canMoveJumper = true;
                        break;
                    }
                }
                
                if (canMoveJumper) {
                    // Score based on how close the landing gets us to goal
                    const distanceToGoal = Math.abs(landRow - goalRow);
                    const progressScore = (7 - distanceToGoal) * 10;
                    
                    // Bonus if landing is in opponent's half
                    const opponentHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
                    const inEnemyTerritory = opponentHalf.includes(landRow) ? 20 : 0;
                    
                    // Bonus if this creates a winning threat (landing 1 away from goal)
                    const createsWinThreat = distanceToGoal <= 1 ? 50 : 0;
                    
                    launchpadScore += progressScore + inEnemyTerritory + createsWinThreat;
                }
            }
            
            // Also check if shadow itself is in a good forward position (for future chains)
            const shadowDistanceToGoal = Math.abs(shadowPos.row - goalRow);
            if (shadowDistanceToGoal <= 3) {
                launchpadScore += (4 - shadowDistanceToGoal) * 5; // Forward shadows are valuable
            }
            
            return launchpadScore;
        }

        // Check if placing a shadow at this position would be immediately capturable
        function cpuShadowIsVulnerable(shadowPos, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            
            // Check all 4 orthogonal directions for potential captures
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            for (const [dr, dc] of directions) {
                // Attacker would be at shadowPos + direction
                const attackerRow = shadowPos.row + dr;
                const attackerCol = shadowPos.col + dc;
                // Support would be at shadowPos - direction  
                const supportRow = shadowPos.row - dr;
                const supportCol = shadowPos.col - dc;
                
                if (!isValidPos(attackerRow, attackerCol) || !isValidPos(supportRow, supportCol)) continue;
                
                const attacker = gameState.board[attackerRow][attackerCol];
                const support = gameState.board[supportRow][supportCol];
                
                // Is there an enemy piece that could capture with support?
                if (attacker?.player === opponent && attacker?.type === 'golem') {
                    if (support?.player === opponent) {
                        return true; // Shadow would be immediately capturable
                    }
                }
            }
            
            return false;
        }

        function cpuSelectShadowVariant(moves, player) {
            const moveGroups = new Map();
            
            for (const move of moves) {
                if (move.type !== 'movement') continue;
                
                const key = `${move.from.row},${move.from.col}->${move.to.row},${move.to.col}:${move.glyphIndex}`;
                
                if (!moveGroups.has(key)) {
                    moveGroups.set(key, { withShadow: null, withoutShadow: null });
                }
                
                if (move.placeShadow) {
                    moveGroups.get(key).withShadow = move;
                } else {
                    moveGroups.get(key).withoutShadow = move;
                }
            }
            
            const selectedMoves = [];
            
            for (const [key, group] of moveGroups) {
                if (group.withShadow && group.withoutShadow) {
                    // First check: would this shadow be immediately capturable?
                    const shadowVulnerable = cpuShadowIsVulnerable(group.withShadow.from, player);
                    
                    if (shadowVulnerable) {
                        // Don't place shadow if it would be captured
                        selectedMoves.push(group.withoutShadow);
                    } else {
                        // Evaluate the shadow as a launchpad
                        const launchpadScore = cpuEvaluateShadowLaunchpad(group.withShadow.from, player);
                        
                        // Use shadow if it creates a good launchpad (score > 40)
                        if (launchpadScore > 40) {
                            selectedMoves.push(group.withShadow);
                        } else {
                            selectedMoves.push(group.withoutShadow);
                        }
                    }
                } else {
                    selectedMoves.push(group.withShadow || group.withoutShadow);
                }
            }
            
            // Add non-movement moves
            for (const move of moves) {
                if (move.type !== 'movement') {
                    selectedMoves.push(move);
                }
            }
            
            return selectedMoves;
        }

        function cpuCountPiecesInOpponentHalf(player) {
            const opponentHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
            let count = 0;
            
            for (let row = 0; row < 8; row++) {
                if (!opponentHalf.includes(row)) continue;
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'golem' && piece.player === player) {
                        count++;
                    }
                }
            }
            
            return count;
        }

        function cpuGetMove() {
            const player = gameState.currentPlayer;
            const opponent = player === 'dark' ? 'light' : 'dark';
            const goalRow = player === 'dark' ? 0 : 7;
            
            let moves = getCpuLegalMoves(player);
            if (moves.length === 0) return null;
            
            // Apply smart shadow selection
            moves = cpuSelectShadowVariant(moves, player);
            
            // 1. Win if possible
            for (const move of moves) {
                if (move.type === 'movement' && move.to.row === goalRow) {
                    return move;
                }
            }
            
            // 2. Block opponent's winning threats
            const blockingMoves = cpuFindBlockingMoves(moves, player);
            if (blockingMoves.length > 0) {
                return blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
            }
            
            // 3. Capture if possible
            const capturingMoves = [];
            for (const move of moves) {
                const captures = cpuPredictCaptures(move, player);
                if (captures > 0) {
                    capturingMoves.push({ move, captures });
                }
            }
            if (capturingMoves.length > 0) {
                capturingMoves.sort((a, b) => b.captures - a.captures);
                return capturingMoves[0].move;
            }
            
            // 4. Safe advance toward goal
            const isEarlyGame = cpuCountPiecesInOpponentHalf(player) < 3;
            
            if (isEarlyGame) {
                const safeAdvances = [];
                const unsafeAdvances = [];
                
                for (const move of moves) {
                    if (move.type === 'movement') {
                        const advancesTowardGoal = player === 'dark'
                            ? move.to.row < move.from.row
                            : move.to.row > move.from.row;
                        
                        if (advancesTowardGoal) {
                            const piece = gameState.board[move.from.row][move.from.col];
                            const hasBackup = cpuHasOtherGlyphForPiece(piece, move.glyphIndex, player);
                            const isSafe = !cpuMoveExposesToCapture(move);
                            
                            if (isSafe) {
                                safeAdvances.push({ move, hasBackup });
                            } else {
                                unsafeAdvances.push({ move, hasBackup });
                            }
                        }
                    }
                }
                
                if (safeAdvances.length > 0) {
                    const withBackup = safeAdvances.filter(m => m.hasBackup);
                    if (withBackup.length > 0) {
                        return withBackup[Math.floor(Math.random() * withBackup.length)].move;
                    }
                    return safeAdvances[Math.floor(Math.random() * safeAdvances.length)].move;
                }
                
                if (unsafeAdvances.length > 0) {
                    const withBackup = unsafeAdvances.filter(m => m.hasBackup);
                    if (withBackup.length > 0) {
                        return withBackup[Math.floor(Math.random() * withBackup.length)].move;
                    }
                    return unsafeAdvances[Math.floor(Math.random() * unsafeAdvances.length)].move;
                }
            }
            
            // 5. Any advancing move
            const opponentHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
            const advancingMoves = moves.filter(m => 
                m.type === 'movement' && 
                opponentHalf.includes(m.to.row) &&
                (player === 'dark' ? m.to.row < m.from.row : m.to.row > m.from.row)
            );
            
            if (advancingMoves.length > 0) {
                return advancingMoves[Math.floor(Math.random() * advancingMoves.length)];
            }
            
            // 6. Random
            return moves[Math.floor(Math.random() * moves.length)];
        }

        // === CPU V4 - Medium difficulty with 2-ply lookahead ===
        
        function cpuSimulateMove(move, player) {
            // Create a minimal copy of relevant game state
            const boardCopy = gameState.board.map(row => row.map(cell => cell ? {...cell} : null));
            
            if (move.type === 'movement') {
                // Move the piece
                boardCopy[move.to.row][move.to.col] = boardCopy[move.from.row][move.from.col];
                boardCopy[move.from.row][move.from.col] = move.placeShadow 
                    ? { type: 'shadow', player } 
                    : null;
            }
            
            return boardCopy;
        }

        function cpuCanWinOnBoard(board, player) {
            const goalRow = player === 'dark' ? 0 : 7;
            
            // Check if any piece can reach goal row
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece?.type === 'golem' && piece.player === player) {
                        const moves = cpuGetValidMovesOnBoard(board, row, col, player);
                        for (const dest of moves) {
                            if (dest.row === goalRow) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function cpuGetValidMovesOnBoard(board, row, col, player) {
            // Simplified getValidMoves that works on a board copy
            const moves = [];
            const piece = board[row][col];
            if (!piece || piece.type !== 'golem') return moves;

            // Orthogonal steps (2 spaces)
            const orthDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dr, dc] of orthDirs) {
                const midRow = row + dr;
                const midCol = col + dc;
                const newRow = row + 2 * dr;
                const newCol = col + 2 * dc;

                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 && !board[newRow][newCol]) {
                    const midPiece = board[midRow]?.[midCol];
                    if (!midPiece || midPiece.player === piece.player) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }

            // Diagonal steps (1 space)
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dr, dc] of diagDirs) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 && !board[newRow][newCol]) {
                    moves.push({ row: newRow, col: newCol });
                }
            }

            // Diagonal jumps (simplified - just immediate jumps)
            for (const [dr, dc] of diagDirs) {
                const jumpOver = board[row + dr]?.[col + dc];
                if (jumpOver?.player === player) {
                    const landRow = row + 2 * dr;
                    const landCol = col + 2 * dc;
                    if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8 && !board[landRow][landCol]) {
                        moves.push({ row: landRow, col: landCol });
                    }
                }
            }

            return moves;
        }

        function cpuMoveCreatesWinThreat(move, player) {
            if (move.type !== 'movement') return false;
            
            const goalRow = player === 'dark' ? 0 : 7;
            const boardAfter = cpuSimulateMove(move, player);
            
            // Check if the moved piece can now reach goal
            const movedPieceMoves = cpuGetValidMovesOnBoard(boardAfter, move.to.row, move.to.col, player);
            for (const dest of movedPieceMoves) {
                if (dest.row === goalRow) {
                    return true;
                }
            }
            
            return false;
        }

        function cpuMoveAllowsOpponentWin(move, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const boardAfter = cpuSimulateMove(move, player);
            return cpuCanWinOnBoard(boardAfter, opponent);
        }

        // Check if a move sets up a future jump-threat (2-move threat)
        function cpuMoveCreatesSetup(move, player) {
            if (move.type !== 'movement') return false;
            
            const goalRow = player === 'dark' ? 0 : 7;
            const direction = player === 'dark' ? -1 : 1;
            const boardAfter = cpuSimulateMove(move, player);
            
            // Check if the moved piece will be able to CREATE a win threat next turn
            // by jumping over a friendly piece toward goal
            const destRow = move.to.row;
            const destCol = move.to.col;
            
            // Look for friendly pieces we could jump over next turn
            const diagDirs = [[direction, 1], [direction, -1]]; // Only toward goal
            
            for (const [dr, dc] of diagDirs) {
                const adjacentRow = destRow + dr;
                const adjacentCol = destCol + dc;
                const landRow = destRow + 2 * dr;
                const landCol = destCol + 2 * dc;
                
                // Check if there's a friendly piece adjacent and landing is valid
                if (adjacentRow >= 0 && adjacentRow < 8 && adjacentCol >= 0 && adjacentCol < 8 &&
                    landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8) {
                    
                    const adjacent = boardAfter[adjacentRow]?.[adjacentCol];
                    const landing = boardAfter[landRow]?.[landCol];
                    
                    if (adjacent?.player === player && !landing) {
                        // We can jump! Does the landing threaten goal?
                        if (landRow === goalRow) {
                            return true; // Jump leads directly to win
                        }
                        // Or is landing one diagonal step from goal?
                        if (Math.abs(landRow - goalRow) === 1) {
                            return true; // Jump puts us in winning position
                        }
                    }
                }
            }
            
            // Also check: does this move place us adjacent to a friendly piece
            // that could then jump over US toward goal?
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardAfter[r][c];
                    if (piece?.type === 'golem' && piece.player === player && !(r === destRow && c === destCol)) {
                        // Can this piece jump over our new position toward goal?
                        for (const [dr, dc] of diagDirs) {
                            if (r + dr === destRow && c + dc === destCol) {
                                // We're adjacent! Can they land?
                                const landRow = r + 2 * dr;
                                const landCol = c + 2 * dc;
                                if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8 && !boardAfter[landRow][landCol]) {
                                    if (landRow === goalRow || Math.abs(landRow - goalRow) === 1) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Check shadow placement setups
            if (move.placeShadow) {
                // Shadow at from position - can any piece jump over it?
                const shadowRow = move.from.row;
                const shadowCol = move.from.col;
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = boardAfter[r][c];
                        if (piece?.type === 'golem' && piece.player === player) {
                            for (const [dr, dc] of diagDirs) {
                                if (r + dr === shadowRow && c + dc === shadowCol) {
                                    const landRow = r + 2 * dr;
                                    const landCol = c + 2 * dc;
                                    if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8 && !boardAfter[landRow][landCol]) {
                                        if (landRow === goalRow || Math.abs(landRow - goalRow) === 1) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return false;
        }

        function cpuGetMoveV4() {
            const player = gameState.currentPlayer;
            const opponent = player === 'dark' ? 'light' : 'dark';
            const goalRow = player === 'dark' ? 0 : 7;
            
            let moves = getCpuLegalMoves(player);
            if (moves.length === 0) return null;
            
            // Apply smart shadow selection
            moves = cpuSelectShadowVariant(moves, player);
            
            // 1. Win if possible
            for (const move of moves) {
                if (move.type === 'movement' && move.to.row === goalRow) {
                    return move;
                }
            }
            
            // 2. Categorize all moves by safety, threat, and setup potential
            const safeMoves = [];          // Don't lose, no threat
            const safeThreats = [];        // Don't lose, creates immediate threat (best!)
            const safeSetups = [];         // Don't lose, sets up future threat (great!)
            const losingMoves = [];        // Lets opponent win
            const losingThreats = [];      // Lets opponent win, but we also threaten
            
            for (const move of moves) {
                const allowsWin = cpuMoveAllowsOpponentWin(move, player);
                const createsThreat = cpuMoveCreatesWinThreat(move, player);
                const createsSetup = cpuMoveCreatesSetup(move, player);
                
                if (allowsWin) {
                    if (createsThreat) {
                        losingThreats.push(move);
                    } else {
                        losingMoves.push(move);
                    }
                } else {
                    if (createsThreat) {
                        safeThreats.push(move);
                    } else if (createsSetup) {
                        safeSetups.push(move);
                    } else {
                        safeMoves.push(move);
                    }
                }
            }
            
            // 3. If we have safe immediate threats, pick one!
            if (safeThreats.length > 0) {
                return safeThreats[Math.floor(Math.random() * safeThreats.length)];
            }
            
            // 4. If we have safe setups (future threats), prioritize those!
            if (safeSetups.length > 0) {
                // Prefer setups that also advance toward goal
                const advancingSetups = safeSetups.filter(m =>
                    m.type === 'movement' &&
                    (player === 'dark' ? m.to.row < m.from.row : m.to.row > m.from.row)
                );
                if (advancingSetups.length > 0) {
                    return advancingSetups[Math.floor(Math.random() * advancingSetups.length)];
                }
                return safeSetups[Math.floor(Math.random() * safeSetups.length)];
            }
            
            // 5. Among safe moves, use V3 logic (block, capture, advance)
            if (safeMoves.length > 0) {
                // Block opponent threats
                const blockingMoves = cpuFindBlockingMoves(safeMoves, player);
                if (blockingMoves.length > 0) {
                    return blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
                }
                
                // Capture
                const capturingMoves = [];
                for (const move of safeMoves) {
                    const captures = cpuPredictCaptures(move, player);
                    if (captures > 0) {
                        capturingMoves.push({ move, captures });
                    }
                }
                if (capturingMoves.length > 0) {
                    capturingMoves.sort((a, b) => b.captures - a.captures);
                    return capturingMoves[0].move;
                }
                
                // Advance toward goal
                const advancingMoves = safeMoves.filter(m => 
                    m.type === 'movement' && 
                    (player === 'dark' ? m.to.row < m.from.row : m.to.row > m.from.row)
                );
                if (advancingMoves.length > 0) {
                    return advancingMoves[Math.floor(Math.random() * advancingMoves.length)];
                }
                
                // Any safe move
                return safeMoves[Math.floor(Math.random() * safeMoves.length)];
            }
            
            // 6. No safe moves! At least scare them with a counter-threat
            if (losingThreats.length > 0) {
                return losingThreats[Math.floor(Math.random() * losingThreats.length)];
            }
            
            // 7. We're doomed, just pick something
            return losingMoves.length > 0 
                ? losingMoves[Math.floor(Math.random() * losingMoves.length)]
                : moves[Math.floor(Math.random() * moves.length)];
        }

        // === CPU V6 - 3-ply lookahead with smart shadows ===
        
        function cpuApplyMoveToState(move, player) {
            // Create a simplified state after the move
            const newBoard = gameState.board.map(row => row.map(cell => cell ? {...cell} : null));
            const newHands = {
                darkHand: gameState.darkHand.map(g => ({...g})),
                lightHand: gameState.lightHand.map(g => ({...g})),
                darkResting: gameState.darkResting ? {...gameState.darkResting} : null,
                lightResting: gameState.lightResting ? {...gameState.lightResting} : null,
                darkSupply: { shadows: gameState.darkSupply.shadows },
                lightSupply: { shadows: gameState.lightSupply.shadows }
            };
            
            if (move.type === 'movement') {
                newBoard[move.to.row][move.to.col] = newBoard[move.from.row][move.from.col];
                newBoard[move.from.row][move.from.col] = move.placeShadow 
                    ? { type: 'shadow', player } 
                    : null;
                
                // Handle glyph transfer
                const hand = player === 'dark' ? newHands.darkHand : newHands.lightHand;
                const usedGlyph = hand.splice(move.glyphIndex, 1)[0];
                
                if (player === 'dark') {
                    if (newHands.darkResting) hand.push(newHands.darkResting);
                    newHands.darkResting = null;
                    newHands.lightResting = usedGlyph;
                } else {
                    if (newHands.lightResting) hand.push(newHands.lightResting);
                    newHands.lightResting = null;
                    newHands.darkResting = usedGlyph;
                }
                
                if (move.placeShadow) {
                    const supply = player === 'dark' ? newHands.darkSupply : newHands.lightSupply;
                    supply.shadows--;
                }
            }
            
            return { board: newBoard, ...newHands };
        }

        function cpuGetLegalMovesForState(simState, player) {
            // Generate legal moves for a simulated state
            const moves = [];
            const hand = player === 'dark' ? simState.darkHand : simState.lightHand;
            const resting = player === 'dark' ? simState.darkResting : simState.lightResting;
            const supply = player === 'dark' ? simState.darkSupply : simState.lightSupply;
            const canPlaceShadow = supply.shadows > 0;
            
            for (let glyphIndex = 0; glyphIndex < hand.length; glyphIndex++) {
                const glyph = hand[glyphIndex];
                const effectiveGlyph = glyph.type === 'mirror' && resting ? resting : glyph;
                
                // Find matching pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = simState.board[row][col];
                        if (!piece || piece.type !== 'golem' || piece.player !== player) continue;
                        
                        const matches = effectiveGlyph.type === 'color' 
                            ? piece.color === effectiveGlyph.value
                            : effectiveGlyph.type === 'shape' 
                                ? piece.shape === effectiveGlyph.value 
                                : false;
                        
                        if (!matches) continue;
                        
                        // Get valid destinations
                        const destinations = cpuGetValidMovesOnBoard(simState.board, row, col, player);
                        for (const dest of destinations) {
                            moves.push({
                                type: 'movement',
                                from: { row, col },
                                to: dest,
                                glyphIndex,
                                placeShadow: false
                            });
                            if (canPlaceShadow) {
                                moves.push({
                                    type: 'movement',
                                    from: { row, col },
                                    to: dest,
                                    glyphIndex,
                                    placeShadow: true
                                });
                            }
                        }
                    }
                }
            }
            
            return moves;
        }

        function cpuEvaluatePosition(board, player) {
            const goalRow = player === 'dark' ? 0 : 7;
            let bestDistance = 8;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece?.type === 'golem' && piece.player === player) {
                        const distance = Math.abs(row - goalRow);
                        if (distance < bestDistance) bestDistance = distance;
                    }
                }
            }
            
            return 8 - bestDistance;
        }

        function cpuMoveScore3Ply(move, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const goalRow = player === 'dark' ? 0 : 7;
            const opponentGoalRow = player === 'dark' ? 7 : 0;
            
            // Immediate win
            if (move.type === 'movement' && move.to.row === goalRow) {
                return 10000;
            }
            
            // Apply our move
            const stateAfterOurMove = cpuApplyMoveToState(move, player);
            
            // Check if opponent can win immediately
            const oppMoves = cpuGetLegalMovesForState(stateAfterOurMove, opponent);
            for (const oppMove of oppMoves) {
                if (oppMove.type === 'movement' && oppMove.to.row === opponentGoalRow) {
                    return -5000; // Losing move
                }
            }
            
            // Find opponent's best response
            let bestOppMove = null;
            let bestOppScore = -Infinity;
            
            for (const oppMove of oppMoves) {
                let score = 0;
                
                // Check if creates threat
                const boardAfterOpp = cpuSimulateMove(oppMove, opponent);
                const oppPieceMoves = cpuGetValidMovesOnBoard(boardAfterOpp, oppMove.to.row, oppMove.to.col, opponent);
                for (const dest of oppPieceMoves) {
                    if (dest.row === opponentGoalRow) {
                        score += 100;
                        break;
                    }
                }
                
                // Advancement
                if (oppMove.type === 'movement') {
                    const advancement = opponent === 'dark' 
                        ? oppMove.from.row - oppMove.to.row
                        : oppMove.to.row - oppMove.from.row;
                    score += advancement * 10;
                }
                
                if (score > bestOppScore) {
                    bestOppScore = score;
                    bestOppMove = oppMove;
                }
            }
            
            if (!bestOppMove) {
                return 5000; // Opponent has no moves
            }
            
            // Apply opponent's best response
            const stateAfterOppResponse = cpuApplyMoveToState(bestOppMove, opponent);
            stateAfterOppResponse.board = cpuSimulateMove(bestOppMove, opponent);
            
            // Check our next turn options
            const ourNextMoves = cpuGetLegalMovesForState(stateAfterOppResponse, player);
            
            let score = 0;
            
            // Can we win?
            for (const nextMove of ourNextMoves) {
                if (nextMove.type === 'movement' && nextMove.to.row === goalRow) {
                    score += 1000;
                    break;
                }
            }
            
            // Do we have threats?
            for (const nextMove of ourNextMoves) {
                if (cpuMoveCreatesWinThreat(nextMove, player)) {
                    score += 50;
                    break;
                }
            }
            
            // Position evaluation
            score += cpuEvaluatePosition(stateAfterOppResponse.board, player) * 5;
            score -= cpuEvaluatePosition(stateAfterOppResponse.board, opponent) * 5;
            
            // Bonus for immediate threat
            if (cpuMoveCreatesWinThreat(move, player)) {
                score += 200;
            }
            
            // Bonus for setup
            if (cpuMoveCreatesSetup(move, player)) {
                score += 30;
            }
            
            // Bonus for captures
            const captures = cpuPredictCaptures(move, player);
            if (captures > 0) {
                score += captures * 75; // Significant bonus for each capture
            }
            
            return score;
        }

        // Comprehensive threat assessment - considers stepping stones and jump chains
        function cpuAssessThreats(player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const oppHand = opponent === 'dark' ? gameState.darkHand : gameState.lightHand;
            const oppResting = opponent === 'dark' ? gameState.darkResting : gameState.lightResting;
            const ourGoalRow = player === 'dark' ? 7 : 0;
            const dangerZone = player === 'dark' ? [4, 5, 6, 7] : [0, 1, 2, 3];
            const direction = opponent === 'dark' ? -1 : 1; // Direction opponent advances
            
            // Find all opponent pieces
            const oppPieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.player === opponent && piece.type === 'golem') {
                        oppPieces.push({ row, col, piece });
                    }
                }
            }
            
            // Find pieces in our danger zone
            const piecesInDangerZone = oppPieces.filter(p => dangerZone.includes(p.row));
            
            // For each piece in danger zone, assess threat level
            const threats = [];
            
            for (const advanced of piecesInDangerZone) {
                let threatLevel = 0;
                const distanceToGoal = Math.abs(advanced.row - ourGoalRow);
                
                // 1. Can they move this piece directly? (check glyphs)
                let canMoveDirect = false;
                let canWinNow = false;
                
                for (const glyph of oppHand) {
                    const effectiveGlyph = glyph.type === 'mirror' && oppResting ? oppResting : glyph;
                    if (!effectiveGlyph) continue;
                    
                    const matches = effectiveGlyph.type === 'color'
                        ? advanced.piece.color === effectiveGlyph.value
                        : effectiveGlyph.type === 'shape'
                            ? advanced.piece.shape === effectiveGlyph.value
                            : false;
                    
                    if (matches) {
                        canMoveDirect = true;
                        threatLevel += 30; // Direct threat
                        
                        // Check if they can WIN with this piece right now
                        const moves = cpuGetValidMovesOnBoard(gameState.board, advanced.row, advanced.col, opponent);
                        for (const m of moves) {
                            if (m.row === ourGoalRow) {
                                canWinNow = true;
                                threatLevel += 500; // CRITICAL - they can win!
                                break;
                            }
                        }
                        break;
                    }
                }
                
                // 1b. Even if they can't move THIS piece, check if it enables a winning jump
                if (!canWinNow && distanceToGoal <= 2) {
                    // Check if another piece can use this as stepping stone to win
                    for (const other of oppPieces) {
                        if (other.row === advanced.row && other.col === advanced.col) continue;
                        
                        // Can 'other' jump over 'advanced' to our goal?
                        const diagDirs = [[direction, 1], [direction, -1]];
                        for (const [dr, dc] of diagDirs) {
                            if (advanced.row === other.row + dr && advanced.col === other.col + dc) {
                                const landRow = other.row + 2 * dr;
                                const landCol = other.col + 2 * dc;
                                
                                if (landRow === ourGoalRow && landCol >= 0 && landCol < 8) {
                                    const landSpot = gameState.board[landRow][landCol];
                                    if (!landSpot) {
                                        // Can they move 'other'?
                                        for (const glyph of oppHand) {
                                            const effectiveGlyph = glyph.type === 'mirror' && oppResting ? oppResting : glyph;
                                            if (!effectiveGlyph) continue;
                                            
                                            const matches = effectiveGlyph.type === 'color'
                                                ? other.piece.color === effectiveGlyph.value
                                                : effectiveGlyph.type === 'shape'
                                                    ? other.piece.shape === effectiveGlyph.value
                                                    : false;
                                            
                                            if (matches) {
                                                canWinNow = true;
                                                threatLevel += 400; // Critical stepping stone threat
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (canWinNow) break;
                    }
                }
                
                // 2. Can other pieces use this as a stepping stone?
                let steppingStoneValue = 0;
                for (const other of oppPieces) {
                    if (other.row === advanced.row && other.col === advanced.col) continue;
                    
                    // Check if 'other' can jump over 'advanced' toward goal
                    const diagDirs = [[direction, 1], [direction, -1]];
                    for (const [dr, dc] of diagDirs) {
                        // Is 'advanced' diagonally adjacent to 'other' in the goal direction?
                        if (advanced.row === other.row + dr && advanced.col === other.col + dc) {
                            // Landing spot
                            const landRow = other.row + 2 * dr;
                            const landCol = other.col + 2 * dc;
                            
                            if (landRow >= 0 && landRow < 8 && landCol >= 0 && landCol < 8) {
                                const landSpot = gameState.board[landRow][landCol];
                                if (!landSpot) {
                                    // Can jump! Check if they have glyph for 'other'
                                    for (const glyph of oppHand) {
                                        const effectiveGlyph = glyph.type === 'mirror' && oppResting ? oppResting : glyph;
                                        if (!effectiveGlyph) continue;
                                        
                                        const matches = effectiveGlyph.type === 'color'
                                            ? other.piece.color === effectiveGlyph.value
                                            : effectiveGlyph.type === 'shape'
                                                ? other.piece.shape === effectiveGlyph.value
                                                : false;
                                        
                                        if (matches) {
                                            const jumpDistance = Math.abs(landRow - ourGoalRow);
                                            steppingStoneValue += (8 - jumpDistance) * 5; // Closer = scarier
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                threatLevel += steppingStoneValue;
                
                // 3. Pieces behind that could chain through
                let chainPotential = 0;
                const behindRows = opponent === 'dark' 
                    ? [advanced.row + 1, advanced.row + 2] 
                    : [advanced.row - 1, advanced.row - 2];
                
                for (const other of oppPieces) {
                    if (behindRows.includes(other.row)) {
                        // Piece behind could potentially chain
                        chainPotential += 10;
                    }
                }
                
                threatLevel += chainPotential;
                
                // 4. Distance bonus - closer is more urgent
                threatLevel += (7 - distanceToGoal) * 15;
                
                if (threatLevel > 0) {
                    threats.push({
                        row: advanced.row,
                        col: advanced.col,
                        distanceToGoal,
                        piece: advanced.piece,
                        threatLevel,
                        canMoveDirect,
                        canWinNow,
                        isSteppingStone: steppingStoneValue > 0
                    });
                }
            }
            
            // Sort by threat level
            threats.sort((a, b) => b.threatLevel - a.threatLevel);
            
            return threats;
        }

        // Count our pieces in opponent's half
        function cpuCountOurPenetration(player) {
            const theirHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
            let count = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.type === 'golem' && piece.player === player && theirHalf.includes(row)) {
                        count++;
                    }
                }
            }
            
            return count;
        }
        
        // Evaluate the danger of giving a specific glyph to the opponent
        function cpuEvaluateGlyphDanger(move, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const ourHand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const oppHand = opponent === 'dark' ? gameState.darkHand : gameState.lightHand;
            const oppResting = opponent === 'dark' ? gameState.darkResting : gameState.lightResting;
            const goalRow = player === 'dark' ? 7 : 0; // Our goal row (where opponent threatens)
            
            // Get the glyph we're about to use
            const glyphUsed = ourHand[move.glyphIndex];
            if (!glyphUsed) return 0;
            
            // Check if opponent has mirror in hand
            const oppHasMirror = oppHand.some(g => g.type === 'mirror');
            
            // Find all opponent pieces
            const oppPieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece?.player === opponent && piece.type === 'golem') {
                        oppPieces.push({ row, col, piece });
                    }
                }
            }
            
            let totalPenalty = 0;
            
            for (const { row, col, piece } of oppPieces) {
                // Check if opponent can ALREADY move this piece
                let canAlreadyMove = false;
                for (const g of oppHand) {
                    let effectiveGlyph = g;
                    if (g.type === 'mirror') {
                        effectiveGlyph = oppResting;
                    }
                    if (!effectiveGlyph) continue;
                    
                    const matches = (effectiveGlyph.type === 'color' && piece.color === effectiveGlyph.value) ||
                                   (effectiveGlyph.type === 'shape' && piece.shape === effectiveGlyph.value);
                    if (matches) {
                        canAlreadyMove = true;
                        break;
                    }
                }
                
                // If they can already move it, no additional danger from our glyph
                if (canAlreadyMove) continue;
                
                // Does our glyph match this piece?
                let glyphMatchesPiece = false;
                if (glyphUsed.type === 'color' && piece.color === glyphUsed.value) {
                    glyphMatchesPiece = true;
                } else if (glyphUsed.type === 'shape' && piece.shape === glyphUsed.value) {
                    glyphMatchesPiece = true;
                } else if (glyphUsed.type === 'mirror') {
                    // If we use mirror, our resting goes to them - check if that matches
                    const ourResting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
                    if (ourResting) {
                        if (ourResting.type === 'color' && piece.color === ourResting.value) {
                            glyphMatchesPiece = true;
                        } else if (ourResting.type === 'shape' && piece.shape === ourResting.value) {
                            glyphMatchesPiece = true;
                        }
                    }
                }
                
                if (!glyphMatchesPiece) continue;
                
                // Assess threat level of this piece using jump connectivity
                const threatLevel = cpuAssessPieceThreatLevel(row, col, piece, opponent, goalRow, oppPieces);
                
                if (threatLevel > 0) {
                    if (oppHasMirror) {
                        // Mirror path - immediate danger (full penalty)
                        totalPenalty += threatLevel;
                    } else {
                        // Direct path - delayed by one turn (reduced penalty)
                        totalPenalty += Math.floor(threatLevel * 0.5);
                    }
                }
            }
            
            return totalPenalty;
        }
        
        // Assess how threatening a specific piece is based on jump connectivity
        function cpuAssessPieceThreatLevel(row, col, piece, player, goalRow, allPieces) {
            // Check if this piece can reach goal directly
            const moves = cpuGetValidMovesOnBoard(gameState.board, row, col, player);
            for (const m of moves) {
                if (m.row === goalRow) {
                    return 200; // Can win now - critical!
                }
            }
            
            // Check if this piece is one jump away from goal (stepping stone exists)
            const direction = player === 'dark' ? -1 : 1;
            const distanceToGoal = Math.abs(row - goalRow);
            
            if (distanceToGoal <= 3) {
                // Check for stepping stone potential - can another piece jump over this one to win?
                for (const other of allPieces) {
                    if (other.row === row && other.col === col) continue;
                    
                    // Check if 'other' could jump over 'piece' to reach goal
                    const diagDirs = [[direction, 1], [direction, -1]];
                    for (const [dr, dc] of diagDirs) {
                        // piece would be at other + (dr, dc)
                        // landing would be at other + 2*(dr, dc)
                        if (row === other.row + dr && col === other.col + dc) {
                            const landRow = other.row + 2 * dr;
                            const landCol = other.col + 2 * dc;
                            
                            if (landRow === goalRow && landCol >= 0 && landCol < 8) {
                                const landSpot = gameState.board[landRow][landCol];
                                if (!landSpot) {
                                    return 80; // Stepping stone to win
                                }
                            }
                        }
                    }
                }
                
                // Check if this piece itself can reach a good position
                for (const m of moves) {
                    const newDistanceToGoal = Math.abs(m.row - goalRow);
                    if (newDistanceToGoal <= 1) {
                        return 40; // Can advance to dangerous position
                    }
                }
            }
            
            // Base threat by distance
            if (distanceToGoal <= 2) return 20;
            if (distanceToGoal <= 4) return 10;
            
            return 0;
        }
        
        // Check if player can respond to an enemy at (targetRow, targetCol) with a capture
        // This requires:
        // 1. A piece that can move adjacent to target
        // 2. A supporting piece on the opposite side  
        // 3. The moving piece shares NO traits with target (different shape AND different color)
        // 4. Player has a glyph to move that piece
        function cpuCanRespondWithCapture(board, targetRow, targetCol, targetPiece, player, hand, resting) {
            if (!targetPiece || targetPiece.player === player) return false;
            
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            for (const [dr, dc] of directions) {
                const adjRow = targetRow + dr;
                const adjCol = targetCol + dc;
                const supportRow = targetRow - dr;
                const supportCol = targetCol - dc;
                
                if (adjRow < 0 || adjRow >= 8 || adjCol < 0 || adjCol >= 8) continue;
                if (supportRow < 0 || supportRow >= 8 || supportCol < 0 || supportCol >= 8) continue;
                
                // Need supporting piece on opposite side
                const supportPiece = board[supportRow]?.[supportCol];
                if (!supportPiece || supportPiece.player !== player || supportPiece.type !== 'golem') continue;
                
                // Adjacent square must be empty (to move there)
                if (board[adjRow][adjCol] !== null) continue;
                
                // Find a piece that can reach adj and can capture target
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (!piece || piece.player !== player || piece.type !== 'golem') continue;
                        
                        // Moving piece must NOT share traits with target
                        if (piece.shape === targetPiece.shape || piece.color === targetPiece.color) continue;
                        
                        // Can this piece move to adj?
                        const moves = cpuGetValidMovesOnBoard(board, r, c, player);
                        if (!moves.some(m => m.row === adjRow && m.col === adjCol)) continue;
                        
                        // Do we have a glyph for this piece?
                        for (const glyph of hand) {
                            const effectiveGlyph = glyph.type === 'mirror' && resting ? resting : glyph;
                            if (!effectiveGlyph) continue;
                            
                            const canMove = effectiveGlyph.type === 'color'
                                ? piece.color === effectiveGlyph.value
                                : effectiveGlyph.type === 'shape'
                                    ? piece.shape === effectiveGlyph.value
                                    : false;
                            
                            if (canMove) return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Check if a move sets up capture threat against enemy breakthrough squares
        // Returns score based on how well this move defends goal row
        function cpuMoveSetupsCaptureDefense(move, threats, player) {
            if (move.type !== 'movement') return 0;
            
            let defenseScore = 0;
            const ourGoalRow = player === 'dark' ? 7 : 0;
            const opponent = player === 'dark' ? 'light' : 'dark';
            const ourHand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const ourResting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
            
            // Simulate board after our move
            const newBoard = gameState.board.map(r => r.map(c => c ? {...c} : null));
            const movingPiece = newBoard[move.from.row][move.from.col];
            newBoard[move.from.row][move.from.col] = null;
            newBoard[move.to.row][move.to.col] = movingPiece;
            
            // For each threat, check if this move helps us defend against it
            for (const threat of threats) {
                // Find where this threat could break through
                const threatMoves = cpuGetValidMovesOnBoard(gameState.board, threat.row, threat.col, opponent);
                
                for (const tm of threatMoves) {
                    if (tm.row !== ourGoalRow) continue; // Only care about breakthrough squares
                    
                    // Would we be able to capture them at this breakthrough square after our move?
                    // We need to simulate: enemy at (tm.row, tm.col), can we respond?
                    const hypotheticalBoard = newBoard.map(r => r.map(c => c ? {...c} : null));
                    hypotheticalBoard[tm.row][tm.col] = threat.piece;
                    
                    // Check if we could capture at (tm.row, tm.col) with our next move
                    // This requires checking if our moved piece (or another) can sandwich them
                    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                    
                    for (const [dr, dc] of directions) {
                        const adjRow = tm.row + dr;
                        const adjCol = tm.col + dc;
                        const supportRow = tm.row - dr;
                        const supportCol = tm.col - dc;
                        
                        if (adjRow < 0 || adjRow >= 8 || adjCol < 0 || adjCol >= 8) continue;
                        if (supportRow < 0 || supportRow >= 8 || supportCol < 0 || supportCol >= 8) continue;
                        
                        const supportPiece = hypotheticalBoard[supportRow]?.[supportCol];
                        if (!supportPiece || supportPiece.player !== player) continue;
                        
                        // Is adj empty (so we could move there)?
                        if (hypotheticalBoard[adjRow][adjCol] !== null) continue;
                        
                        // Can our moved piece reach adj and capture the threat?
                        const movedPieceMoves = cpuGetValidMovesOnBoard(hypotheticalBoard, move.to.row, move.to.col, player);
                        
                        if (movedPieceMoves.some(m => m.row === adjRow && m.col === adjCol)) {
                            // Check trait compatibility
                            if (movingPiece.shape !== threat.piece.shape && 
                                movingPiece.color !== threat.piece.color) {
                                defenseScore += 150; // Good defensive setup!
                            }
                        }
                    }
                }
            }
            
            return defenseScore;
        }

        // Check if a move blocks or contests opponent's advanced pieces
        function cpuMoveContestsThreats(move, threats, player) {
            if (move.type !== 'movement') return 0;
            
            let contestScore = 0;
            const ourGoalRow = player === 'dark' ? 7 : 0;
            const opponent = player === 'dark' ? 'light' : 'dark';
            
            for (const threat of threats) {
                // Does this move land adjacent to a threat? (potential capture setup)
                const rowDiff = Math.abs(move.to.row - threat.row);
                const colDiff = Math.abs(move.to.col - threat.col);
                
                if (rowDiff <= 1 && colDiff <= 1) {
                    contestScore += 10;
                }
                
                // Does this move block a path toward our goal?
                if (move.to.col === threat.col && 
                    Math.abs(move.to.row - ourGoalRow) < Math.abs(threat.row - ourGoalRow)) {
                    contestScore += 20;
                }
                
                // Does this move land on a square the threat could reach?
                const threatMoves = cpuGetValidMovesOnBoard(gameState.board, threat.row, threat.col, opponent);
                for (const tm of threatMoves) {
                    if (tm.row === move.to.row && tm.col === move.to.col) {
                        contestScore += 15; // We're taking a square they wanted
                        
                        // HUGE bonus if we're blocking their winning move
                        if (tm.row === ourGoalRow) {
                            contestScore += 500;
                        }
                        break;
                    }
                }
                
                // Check if this move blocks diagonal jump paths to goal row
                // A piece 2 rows from goal can jump diagonally to win
                if (threat.distanceToGoal === 2) {
                    // Check both diagonal landing spots
                    const jumpRow = ourGoalRow;
                    const jumpCols = [threat.col - 2, threat.col + 2];
                    
                    for (const jumpCol of jumpCols) {
                        if (jumpCol >= 0 && jumpCol < 8) {
                            // Check if the middle square (stepping stone) is occupied by opponent
                            const midRow = threat.row + (opponent === 'dark' ? -1 : 1);
                            const midCol = (threat.col + jumpCol) / 2;
                            const midPiece = gameState.board[midRow]?.[midCol];
                            
                            if (midPiece?.player === opponent) {
                                // There's a stepping stone - can they land on goal?
                                const landPiece = gameState.board[jumpRow][jumpCol];
                                if (!landPiece) {
                                    // They can win via this diagonal jump!
                                    // Check if our move blocks the landing
                                    if (move.to.row === jumpRow && move.to.col === jumpCol) {
                                        contestScore += 400;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Check orthogonal 2-step breakthrough threats
                if (threat.distanceToGoal === 2) {
                    const stepRow = threat.row + (opponent === 'dark' ? -1 : 1);
                    const stepPiece = gameState.board[stepRow]?.[threat.col];
                    
                    // If the square in front is empty or has our piece (can step through)
                    if (!stepPiece || stepPiece.player === player) {
                        const goalSpot = gameState.board[ourGoalRow][threat.col];
                        if (!goalSpot && move.to.row === ourGoalRow && move.to.col === threat.col) {
                            contestScore += 400;
                        }
                    }
                }
            }
            
            return contestScore;
        }

        function cpuGetMoveV6() {
            const player = gameState.currentPlayer;
            const goalRow = player === 'dark' ? 0 : 7;
            
            let moves = getCpuLegalMoves(player);
            if (moves.length === 0) return null;
            
            // 1. Win if possible (check before any filtering)
            for (const move of moves) {
                if (move.type === 'movement' && move.to.row === goalRow) {
                    return move;
                }
            }
            
            // 2. Assess threats with stepping stone detection
            const threats = cpuAssessThreats(player);
            const ourPenetration = cpuCountOurPenetration(player);
            
            // Calculate total threat level
            const totalThreatLevel = threats.reduce((sum, t) => sum + t.threatLevel, 0);
            const hasActiveThreats = threats.some(t => t.canMoveDirect || t.isSteppingStone);
            const hasUrgentThreat = threats.some(t => t.distanceToGoal <= 2);
            const hasCriticalThreat = threats.some(t => t.canWinNow);
            
            // Critical mode: opponent can win next turn!
            const criticalMode = hasCriticalThreat;
            // Panic if: high threat level with active threats, and we're not counter-attacking
            const panicMode = totalThreatLevel >= 60 && hasActiveThreats && ourPenetration <= 1;
            const urgentMode = hasUrgentThreat;
            
            // 3. Filter shadow variants (after strategic assessment)
            moves = cpuSelectShadowVariant(moves, player);
            
            // 4. Score all moves with 3-ply lookahead
            const scoredMoves = moves.map(move => {
                let score = cpuMoveScore3Ply(move, player);
                
                // Add defensive setup scoring - moves that position for capture response
                if (threats.length > 0) {
                    const defenseScore = cpuMoveSetupsCaptureDefense(move, threats, player);
                    score += defenseScore;
                }
                
                // In critical/panic/urgent mode, boost moves that contest threats
                if (criticalMode || panicMode || urgentMode) {
                    const contestScore = cpuMoveContestsThreats(move, threats, player);
                    
                    // Critical mode gets highest multiplier
                    const multiplier = criticalMode ? 5 : (urgentMode ? 3 : 2);
                    score += contestScore * multiplier;
                    
                    // Penalize pure advancement when we should be defending
                    if (contestScore === 0 && move.type === 'movement') {
                        const isAdvancing = player === 'dark' 
                            ? move.to.row < move.from.row 
                            : move.to.row > move.from.row;
                        if (isAdvancing) {
                            // Check if this move at least sets up defense
                            const defenseScore = cpuMoveSetupsCaptureDefense(move, threats, player);
                            if (defenseScore === 0) {
                                if (criticalMode) {
                                    score -= 200; // Don't advance when opponent can win!
                                } else if (panicMode) {
                                    score -= 50; // Don't just advance when under attack!
                                }
                            }
                        }
                    }
                }
                
                // Evaluate glyph danger - penalize moves that gift useful glyphs to opponent
                const glyphDanger = cpuEvaluateGlyphDanger(move, player);
                score -= glyphDanger;
                
                return { move, score };
            });
            
            scoredMoves.sort((a, b) => b.score - a.score);
            
            const bestScore = scoredMoves[0].score;
            const bestMoves = scoredMoves.filter(m => m.score === bestScore);
            
            return bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
        }

        // ============== V7 CPU: Minimax with proper position evaluation ==============
        
        function cpuGetMoveV7() {
            const player = gameState.currentPlayer;
            const opponent = player === 'dark' ? 'light' : 'dark';
            const goalRow = player === 'dark' ? 0 : 7;
            const oppGoalRow = opponent === 'dark' ? 0 : 7;
            
            const moves = getCpuLegalMoves(player);
            if (moves.length === 0) return null;
            
            // 1. Immediate win check
            for (const move of moves) {
                if (move.type === 'movement' && move.to.row === goalRow) {
                    return move;
                }
            }
            
            // 2. Find opponent's winning pieces (pieces that can reach goal)
            const currentState = v7CloneState();
            const oppWinningPieces = v7FindWinningPieces(currentState, opponent);
            
            if (oppWinningPieces.length > 0) {
                // EMERGENCY: Opponent can win! Find disruptive moves
                const disruptiveMoves = [];
                
                for (const move of moves) {
                    const simState = v7CloneState();
                    const movingPiece = move.type === 'movement' 
                        ? simState.board[move.from.row][move.from.col]
                        : null;
                    
                    // Apply move
                    v7ApplyMove(simState, move, player);
                    
                    // Check if opponent can still win after our move
                    const oppCanStillWin = v7CanPlayerWin(simState, opponent);
                    
                    if (!oppCanStillWin) {
                        // This move stops their win somehow (capture, etc)
                        disruptiveMoves.push({ move, score: 1000, reason: 'stops_win' });
                        continue;
                    }
                    
                    // Check if we captured one of their winning pieces
                    let capturedWinner = false;
                    for (const wp of oppWinningPieces) {
                        const pieceStillThere = simState.board[wp.row]?.[wp.col];
                        if (!pieceStillThere || pieceStillThere.player !== opponent) {
                            capturedWinner = true;
                            break;
                        }
                    }
                    
                    if (capturedWinner) {
                        disruptiveMoves.push({ move, score: 800, reason: 'captured_winner' });
                        continue;
                    }
                    
                    // Check if we're threatening to win ourselves (forcing response)
                    const ourWinningPiecesAfter = v7FindWinningPieces(simState, player);
                    if (ourWinningPiecesAfter.length > 0) {
                        disruptiveMoves.push({ move, score: 600, reason: 'counter_threat' });
                        continue;
                    }
                    
                    // Check if we're setting up a capture on their winning piece
                    if (move.type === 'movement' && movingPiece) {
                        for (const wp of oppWinningPieces) {
                            const captureSetup = v7CheckCaptureSetup(simState, wp.row, wp.col, player, movingPiece, move.to);
                            if (captureSetup) {
                                disruptiveMoves.push({ move, score: 400, reason: 'capture_setup' });
                                break;
                            }
                        }
                    }
                }
                
                if (disruptiveMoves.length > 0) {
                    disruptiveMoves.sort((a, b) => b.score - a.score);
                    return disruptiveMoves[0].move;
                }
                
                // No good disruption found — we're likely losing
                // DESPERATION MODE: At least try to create our own winning threat
                // or advance our most forward piece
                const myGoalRow = player === 'dark' ? 0 : 7;
                const myDirection = player === 'dark' ? -1 : 1;
                
                let bestDesperationMove = null;
                let bestDesperationScore = -Infinity;
                
                for (const move of moves) {
                    if (move.type !== 'movement') continue;
                    
                    let score = 0;
                    
                    // Bonus for advancing toward goal
                    const fromDist = Math.abs(move.from.row - myGoalRow);
                    const toDist = Math.abs(move.to.row - myGoalRow);
                    if (toDist < fromDist) {
                        score += (fromDist - toDist) * 20;
                    }
                    
                    // Big bonus if this move reaches goal (mutual breakthrough)
                    if (move.to.row === myGoalRow) {
                        score += 500;
                    }
                    
                    // Bonus for capturing something
                    const simState = v7CloneState();
                    const movingPiece = simState.board[move.from.row][move.from.col];
                    if (movingPiece) {
                        simState.board[move.to.row][move.to.col] = movingPiece;
                        simState.board[move.from.row][move.from.col] = null;
                        const captures = v7EvaluateCapturesAt(simState, move.to.row, move.to.col, movingPiece, player);
                        score += captures.value;
                    }
                    
                    if (score > bestDesperationScore) {
                        bestDesperationScore = score;
                        bestDesperationMove = move;
                    }
                }
                
                if (bestDesperationMove) {
                    return bestDesperationMove;
                }
            }
            
            // 3. Normal move scoring
            const scoredMoves = moves.map(move => {
                const score = v7EvaluateMove(move, player, 2);
                return { move, score };
            });
            
            scoredMoves.sort((a, b) => b.score - a.score);
            
            // Pick randomly among tied best moves
            const bestScore = scoredMoves[0].score;
            const bestMoves = scoredMoves.filter(m => m.score === bestScore);
            
            return bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
        }
        
        // Find all pieces that can reach the goal row
        function v7FindWinningPieces(state, player) {
            const goalRow = player === 'dark' ? 0 : 7;
            const hand = player === 'dark' ? state.darkHand : state.lightHand;
            const resting = player === 'dark' ? state.darkResting : state.lightResting;
            
            const winningPieces = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = state.board[row][col];
                    if (!piece || piece.player !== player || piece.type !== 'golem') continue;
                    
                    // Can we move this piece?
                    if (!v7CanMovePiece(piece, hand, resting)) continue;
                    
                    // Can this piece reach the goal?
                    const moves = v7GetValidMoves(state.board, row, col);
                    for (const m of moves) {
                        if (m.row === goalRow) {
                            winningPieces.push({ row, col, piece });
                            break;
                        }
                    }
                }
            }
            
            return winningPieces;
        }
        
        // Check if we're setting up a capture on enemy piece at (targetRow, targetCol)
        function v7CheckCaptureSetup(state, targetRow, targetCol, player, movingPiece, moveTo) {
            // After our move, check if we can capture the target next turn
            // We need: our piece on one side, ability to move another piece to the other side
            
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            const hand = player === 'dark' ? state.darkHand : state.lightHand;
            const resting = player === 'dark' ? state.darkResting : state.lightResting;
            
            for (const [dr, dc] of dirs) {
                const side1Row = targetRow + dr;
                const side1Col = targetCol + dc;
                const side2Row = targetRow - dr;
                const side2Col = targetCol - dc;
                
                if (side1Row < 0 || side1Row > 7 || side1Col < 0 || side1Col > 7) continue;
                if (side2Row < 0 || side2Row > 7 || side2Col < 0 || side2Col > 7) continue;
                
                // Check if our move puts us on one side
                const weAreOnSide1 = moveTo.row === side1Row && moveTo.col === side1Col;
                const weAreOnSide2 = moveTo.row === side2Row && moveTo.col === side2Col;
                
                if (!weAreOnSide1 && !weAreOnSide2) continue;
                
                const ourSide = weAreOnSide1 ? { row: side1Row, col: side1Col } : { row: side2Row, col: side2Col };
                const otherSide = weAreOnSide1 ? { row: side2Row, col: side2Col } : { row: side1Row, col: side1Col };
                
                // Is the other side empty? (so a piece could move there)
                const otherSidePiece = state.board[otherSide.row][otherSide.col];
                if (otherSidePiece) continue; // Blocked
                
                // Can any of our pieces reach the other side?
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = state.board[r][c];
                        if (!p || p.player !== player || p.type !== 'golem') continue;
                        if (r === moveTo.row && c === moveTo.col) continue; // Skip piece we just moved
                        
                        // Can we move this piece?
                        if (!v7CanMovePiece(p, hand, resting)) continue;
                        
                        // Can it reach the other side?
                        const pMoves = v7GetValidMoves(state.board, r, c);
                        for (const pm of pMoves) {
                            if (pm.row === otherSide.row && pm.col === otherSide.col) {
                                // Can this piece capture the target?
                                const target = state.board[targetRow][targetCol];
                                if (target && target.type === 'golem') {
                                    if (p.shape !== target.shape && p.color !== target.color) {
                                        return true; // Capture setup!
                                    }
                                } else if (target && target.type === 'shadow') {
                                    return true; // Can capture shadow
                                }
                            }
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Evaluate a move by simulating it and opponent's best response
        function v7EvaluateMove(move, player, depth) {
            // Create a simulation state
            const simState = v7CloneState();
            
            // Check if opponent can win BEFORE our move
            const opponent = player === 'dark' ? 'light' : 'dark';
            const oppGoalRow = opponent === 'dark' ? 0 : 7;
            const oppCanWinBefore = v7CanPlayerWin(v7CloneState(), opponent);
            
            // Evaluate captures we'll make with this move BEFORE applying
            let captureBonus = 0;
            if (move.type === 'movement') {
                const movingPiece = gameState.board[move.from.row][move.from.col];
                if (movingPiece) {
                    // Temporarily place piece to evaluate captures
                    const tempState = v7CloneState();
                    tempState.board[move.to.row][move.to.col] = movingPiece;
                    tempState.board[move.from.row][move.from.col] = null;
                    
                    const captures = v7EvaluateCapturesAt(tempState, move.to.row, move.to.col, movingPiece, player);
                    captureBonus = captures.value;
                    
                    // Multi-capture bonus
                    if (captures.count >= 2) {
                        captureBonus += captures.count * 20; // Extra bonus for multi-captures
                    }
                }
            }
            
            // Apply our move
            v7ApplyMove(simState, move, player);
            
            // Check threat level at our new position
            if (move.type === 'movement') {
                const ourPiece = simState.board[move.to.row][move.to.col];
                if (ourPiece) {
                    const threatValue = v7EvaluateThreatsAt(simState, move.to.row, move.to.col, ourPiece, player);
                    if (threatValue > 0) {
                        // We're in danger - but is it worth it?
                        if (captureBonus < threatValue) {
                            // We lose more than we gain
                            return -threatValue + captureBonus;
                        }
                        // Otherwise, the trade might be worth it - continue evaluation
                    }
                }
            }
            
            // If depth exhausted, add capture bonus and evaluate position
            if (depth <= 1) {
                return v7EvaluatePosition(simState, player) + captureBonus;
            }
            
            // Find opponent's best response
            const opponentMoves = v7GetLegalMoves(simState, opponent);
            
            if (opponentMoves.length === 0) {
                // Opponent has no moves - very good for us
                return 1000 + captureBonus;
            }
            
            // Check if opponent can win after our move
            const oppCanWinAfter = v7CanPlayerWin(simState, opponent);
            
            if (oppCanWinBefore && !oppCanWinAfter) {
                // Great! Our move blocked their win
                return 500 + captureBonus;
            }
            
            if (oppCanWinAfter) {
                // They can win and we didn't stop them - terrible move
                return -1000;
            }
            
            // Find opponent's best move (maximizing their position = minimizing ours)
            let worstForUs = Infinity;
            for (const oppMove of opponentMoves) {
                const simState2 = v7CloneStateFrom(simState);
                v7ApplyMove(simState2, oppMove, opponent);
                const positionScore = v7EvaluatePosition(simState2, player);
                worstForUs = Math.min(worstForUs, positionScore);
            }
            
            return worstForUs + captureBonus;
        }
        
        // Check if a player can win on their next move
        function v7CanPlayerWin(state, player) {
            const goalRow = player === 'dark' ? 0 : 7;
            const hand = player === 'dark' ? state.darkHand : state.lightHand;
            const resting = player === 'dark' ? state.darkResting : state.lightResting;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = state.board[row][col];
                    if (!piece || piece.player !== player || piece.type !== 'golem') continue;
                    
                    // Can we move this piece?
                    if (!v7CanMovePiece(piece, hand, resting)) continue;
                    
                    // Can this piece reach the goal?
                    const moves = v7GetValidMoves(state.board, row, col);
                    for (const m of moves) {
                        if (m.row === goalRow) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Check if a piece at (row, col) can be captured by opponent
        function v7CheckCaptureDanger(state, row, col, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const ourPiece = state.board[row][col];
            if (!ourPiece) return false;
            
            const oppHand = opponent === 'dark' ? state.darkHand : state.lightHand;
            const oppResting = opponent === 'dark' ? state.darkResting : state.lightResting;
            
            // Check all 4 directions for custodian capture threat
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            for (const [dr, dc] of dirs) {
                const supportRow = row + dr;
                const supportCol = col + dc;
                const attackLandRow = row - dr;
                const attackLandCol = col - dc;
                
                if (supportRow < 0 || supportRow > 7 || supportCol < 0 || supportCol > 7) continue;
                if (attackLandRow < 0 || attackLandRow > 7 || attackLandCol < 0 || attackLandCol > 7) continue;
                
                const supportPiece = state.board[supportRow][supportCol];
                const attackLand = state.board[attackLandRow][attackLandCol];
                
                // Need opponent support piece
                if (!supportPiece || supportPiece.player !== opponent) continue;
                
                // Attack landing must be empty
                if (attackLand) continue;
                
                // Can any opponent piece reach attackLand and capture us?
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const attacker = state.board[r][c];
                        if (!attacker || attacker.player !== opponent || attacker.type !== 'golem') continue;
                        
                        // Can they capture us? (different shape AND color)
                        if (ourPiece.type === 'golem') {
                            if (attacker.shape === ourPiece.shape || attacker.color === ourPiece.color) continue;
                        }
                        
                        // Can they move this piece?
                        if (!v7CanMovePiece(attacker, oppHand, oppResting)) continue;
                        
                        // Can they reach the attack position?
                        const moves = v7GetValidMoves(state.board, r, c);
                        for (const m of moves) {
                            if (m.row === attackLandRow && m.col === attackLandCol) {
                                return true; // We can be captured!
                            }
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Clone the current game state for simulation
        function v7CloneState() {
            return {
                board: gameState.board.map(row => row.map(cell => cell ? {...cell} : null)),
                darkHand: gameState.darkHand.map(g => ({...g})),
                lightHand: gameState.lightHand.map(g => ({...g})),
                darkResting: gameState.darkResting ? {...gameState.darkResting} : null,
                lightResting: gameState.lightResting ? {...gameState.lightResting} : null,
                darkSupply: {
                    shadows: gameState.darkSupply.shadows,
                    masks: gameState.darkSupply.masks.map(m => ({...m}))
                },
                lightSupply: {
                    shadows: gameState.lightSupply.shadows,
                    masks: gameState.lightSupply.masks.map(m => ({...m}))
                },
                lightHasPlacedShadow: gameState.lightHasPlacedShadow
            };
        }
        
        // Clone a simulation state
        function v7CloneStateFrom(state) {
            return {
                board: state.board.map(row => row.map(cell => cell ? {...cell} : null)),
                darkHand: state.darkHand.map(g => ({...g})),
                lightHand: state.lightHand.map(g => ({...g})),
                darkResting: state.darkResting ? {...state.darkResting} : null,
                lightResting: state.lightResting ? {...state.lightResting} : null,
                darkSupply: {
                    shadows: state.darkSupply.shadows,
                    masks: state.darkSupply.masks.map(m => ({...m}))
                },
                lightSupply: {
                    shadows: state.lightSupply.shadows,
                    masks: state.lightSupply.masks.map(m => ({...m}))
                },
                lightHasPlacedShadow: state.lightHasPlacedShadow
            };
        }
        
        // Apply a move to a simulation state
        function v7ApplyMove(state, move, player) {
            const hand = player === 'dark' ? state.darkHand : state.lightHand;
            const supply = player === 'dark' ? state.darkSupply : state.lightSupply;
            const opponent = player === 'dark' ? 'light' : 'dark';
            
            // Get the glyph being used
            const glyphUsed = hand[move.glyphIndex];
            
            if (move.type === 'movement') {
                // Move the piece
                const piece = state.board[move.from.row][move.from.col];
                state.board[move.to.row][move.to.col] = piece;
                state.board[move.from.row][move.from.col] = null;
                
                // Place shadow if applicable
                if (move.placeShadow && supply.shadows > 0) {
                    state.board[move.from.row][move.from.col] = { type: 'shadow', player };
                    supply.shadows--;
                    if (player === 'light') state.lightHasPlacedShadow = true;
                }
                
                // Handle captures
                v7HandleCaptures(state, move.to.row, move.to.col, piece);
                
            } else if (move.type === 'reactivation') {
                // Remove shadow, place golem
                const mask = supply.masks[move.maskIndex];
                state.board[move.position.row][move.position.col] = {
                    type: 'golem',
                    player,
                    shape: mask.shape,
                    color: mask.color
                };
                supply.masks.splice(move.maskIndex, 1);
                
                // Handle captures from reactivation
                const newPiece = state.board[move.position.row][move.position.col];
                v7HandleCaptures(state, move.position.row, move.position.col, newPiece);
            }
            
            // Update glyphs: used glyph goes to opponent's resting
            hand.splice(move.glyphIndex, 1);
            
            // Pick up current resting
            const resting = player === 'dark' ? state.darkResting : state.lightResting;
            if (resting) {
                hand.push(resting);
            }
            
            // Set opponent's new resting
            if (opponent === 'dark') {
                state.darkResting = glyphUsed;
            } else {
                state.lightResting = glyphUsed;
            }
            
            // Clear our resting
            if (player === 'dark') {
                state.darkResting = null;
            } else {
                state.lightResting = null;
            }
        }
        
        // Handle captures in simulation
        function v7HandleCaptures(state, row, col, movingPiece) {
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            const capturedShadowOwners = new Set();
            
            for (const [dr, dc] of directions) {
                const enemyRow = row + dr;
                const enemyCol = col + dc;
                const supportRow = row + dr * 2;
                const supportCol = col + dc * 2;
                
                if (enemyRow < 0 || enemyRow > 7 || enemyCol < 0 || enemyCol > 7) continue;
                if (supportRow < 0 || supportRow > 7 || supportCol < 0 || supportCol > 7) continue;
                
                const enemyPiece = state.board[enemyRow][enemyCol];
                const supportPiece = state.board[supportRow][supportCol];
                
                if (!enemyPiece || !supportPiece) continue;
                if (enemyPiece.player === movingPiece.player) continue;
                if (supportPiece.player !== movingPiece.player) continue;
                
                // Check capture validity (can't capture same shape or same color)
                if (enemyPiece.type === 'golem') {
                    if (movingPiece.shape === enemyPiece.shape) continue;
                    if (movingPiece.color === enemyPiece.color) continue;
                }
                
                // Capture!
                const supply = enemyPiece.player === 'dark' ? state.darkSupply : state.lightSupply;
                if (enemyPiece.type === 'shadow') {
                    capturedShadowOwners.add(enemyPiece.player);
                    supply.shadows++;
                } else {
                    supply.shadows++;
                    supply.masks.push({ shape: enemyPiece.shape, color: enemyPiece.color });
                }
                state.board[enemyRow][enemyCol] = null;
            }
            
            // Shadow cascade
            for (const owner of capturedShadowOwners) {
                const supply = owner === 'dark' ? state.darkSupply : state.lightSupply;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = state.board[r][c];
                        if (p?.type === 'shadow' && p.player === owner) {
                            state.board[r][c] = null;
                            supply.shadows++;
                        }
                    }
                }
            }
        }
        
        // Evaluate captures from landing at a position (without modifying state)
        // Returns { count, value, shadowCascade } where value accounts for piece importance
        function v7EvaluateCapturesAt(state, row, col, movingPiece, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const oppGoalRow = opponent === 'dark' ? 0 : 7;
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            let count = 0;
            let value = 0;
            let shadowCascade = false;
            
            for (const [dr, dc] of directions) {
                const enemyRow = row + dr;
                const enemyCol = col + dc;
                const supportRow = row + dr * 2;
                const supportCol = col + dc * 2;
                
                if (enemyRow < 0 || enemyRow > 7 || enemyCol < 0 || enemyCol > 7) continue;
                if (supportRow < 0 || supportRow > 7 || supportCol < 0 || supportCol > 7) continue;
                
                const enemyPiece = state.board[enemyRow][enemyCol];
                const supportPiece = state.board[supportRow][supportCol];
                
                if (!enemyPiece || !supportPiece) continue;
                if (enemyPiece.player === player) continue; // Not an enemy
                if (supportPiece.player !== player) continue; // No support
                
                // Check capture validity
                if (enemyPiece.type === 'golem') {
                    if (movingPiece.shape === enemyPiece.shape) continue;
                    if (movingPiece.color === enemyPiece.color) continue;
                    
                    count++;
                    
                    // Value based on how advanced the piece is
                    const distToGoal = Math.abs(enemyRow - oppGoalRow);
                    const advancementValue = (7 - distToGoal) * 10; // 0-70 based on position
                    value += 40 + advancementValue; // Base 40 + position bonus
                    
                } else if (enemyPiece.type === 'shadow') {
                    count++;
                    value += 30; // Shadow capture
                    shadowCascade = true; // Will trigger cascade!
                }
            }
            
            // Shadow cascade bonus - all opponent shadows get removed
            if (shadowCascade) {
                let cascadeCount = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = state.board[r][c];
                        if (p?.type === 'shadow' && p.player === opponent) {
                            cascadeCount++;
                        }
                    }
                }
                // Additional shadows beyond the first one we captured
                value += (cascadeCount - 1) * 25;
            }
            
            return { count, value, shadowCascade };
        }
        
        // Check what captures opponent could make against us at a position
        function v7EvaluateThreatsAt(state, row, col, ourPiece, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const myGoalRow = player === 'dark' ? 0 : 7;
            const oppHand = opponent === 'dark' ? state.darkHand : state.lightHand;
            const oppResting = opponent === 'dark' ? state.darkResting : state.lightResting;
            
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            let maxThreat = 0;
            
            for (const [dr, dc] of directions) {
                const supportRow = row + dr;
                const supportCol = col + dc;
                const attackLandRow = row - dr;
                const attackLandCol = col - dc;
                
                if (supportRow < 0 || supportRow > 7 || supportCol < 0 || supportCol > 7) continue;
                if (attackLandRow < 0 || attackLandRow > 7 || attackLandCol < 0 || attackLandCol > 7) continue;
                
                const supportPiece = state.board[supportRow][supportCol];
                const attackLand = state.board[attackLandRow][attackLandCol];
                
                // Need opponent support
                if (!supportPiece || supportPiece.player !== opponent) continue;
                // Attack land must be empty
                if (attackLand) continue;
                
                // Can any opponent piece capture us from attackLand?
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const attacker = state.board[r][c];
                        if (!attacker || attacker.player !== opponent || attacker.type !== 'golem') continue;
                        
                        // Can they capture us?
                        if (ourPiece.type === 'golem') {
                            if (attacker.shape === ourPiece.shape || attacker.color === ourPiece.color) continue;
                        }
                        
                        // Can they move?
                        if (!v7CanMovePiece(attacker, oppHand, oppResting)) continue;
                        
                        // Can they reach attack position?
                        const moves = v7GetValidMoves(state.board, r, c);
                        for (const m of moves) {
                            if (m.row === attackLandRow && m.col === attackLandCol) {
                                // Calculate how valuable our piece is
                                const distToGoal = Math.abs(row - myGoalRow);
                                const ourValue = 40 + (7 - distToGoal) * 10;
                                
                                // But also check if THEY could multi-capture
                                // (This is the key insight - one attack might get multiple pieces)
                                const theirCaptures = v7EvaluateCapturesAt(
                                    state, attackLandRow, attackLandCol, attacker, opponent
                                );
                                
                                const threat = Math.max(ourValue, theirCaptures.value);
                                maxThreat = Math.max(maxThreat, threat);
                            }
                        }
                    }
                }
            }
            
            return maxThreat;
        }
        
        // Get legal moves for a simulation state
        function v7GetLegalMoves(state, player) {
            const moves = [];
            const hand = player === 'dark' ? state.darkHand : state.lightHand;
            const resting = player === 'dark' ? state.darkResting : state.lightResting;
            const supply = player === 'dark' ? state.darkSupply : state.lightSupply;
            
            const canPlaceShadow = supply.shadows > 0 && 
                (player === 'light' || state.lightHasPlacedShadow);
            
            for (let glyphIndex = 0; glyphIndex < hand.length; glyphIndex++) {
                const glyph = hand[glyphIndex];
                const effectiveGlyph = glyph.type === 'mirror' ? resting : glyph;
                if (!effectiveGlyph) continue;
                
                // Movement moves
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = state.board[row][col];
                        if (piece?.type === 'golem' && piece.player === player) {
                            const matches = (effectiveGlyph.type === 'color' && piece.color === effectiveGlyph.value) ||
                                          (effectiveGlyph.type === 'shape' && piece.shape === effectiveGlyph.value);
                            if (matches) {
                                const destinations = v7GetValidMoves(state.board, row, col);
                                for (const dest of destinations) {
                                    moves.push({
                                        type: 'movement',
                                        glyphIndex,
                                        from: { row, col },
                                        to: dest,
                                        placeShadow: false
                                    });
                                    if (canPlaceShadow) {
                                        moves.push({
                                            type: 'movement',
                                            glyphIndex,
                                            from: { row, col },
                                            to: dest,
                                            placeShadow: true
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Reactivation moves
                if (resting && supply.masks.length > 0) {
                    for (let maskIndex = 0; maskIndex < supply.masks.length; maskIndex++) {
                        const mask = supply.masks[maskIndex];
                        // Check if mask matches both glyphs
                        const matchesGlyph = (effectiveGlyph.type === 'color' && mask.color === effectiveGlyph.value) ||
                                            (effectiveGlyph.type === 'shape' && mask.shape === effectiveGlyph.value);
                        const matchesResting = (resting.type === 'color' && mask.color === resting.value) ||
                                              (resting.type === 'shape' && mask.shape === resting.value);
                        if (matchesGlyph && matchesResting) {
                            for (let row = 0; row < 8; row++) {
                                for (let col = 0; col < 8; col++) {
                                    const piece = state.board[row][col];
                                    if (piece?.type === 'shadow' && piece.player === player) {
                                        moves.push({
                                            type: 'reactivation',
                                            glyphIndex,
                                            maskIndex,
                                            position: { row, col }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a piece on a board (simplified version for simulation)
        function v7GetValidMoves(board, row, col) {
            const moves = [];
            const piece = board[row][col];
            if (!piece || piece.type !== 'golem') return moves;
            
            // Orthogonal steps (2 spaces)
            const orthDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dr, dc] of orthDirs) {
                const midRow = row + dr;
                const midCol = col + dc;
                const newRow = row + 2 * dr;
                const newCol = col + 2 * dc;
                
                if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) continue;
                if (midRow < 0 || midRow > 7 || midCol < 0 || midCol > 7) continue;
                
                const midPiece = board[midRow][midCol];
                const destPiece = board[newRow][newCol];
                
                // Blocked only by opponent in middle
                if (midPiece && midPiece.player !== piece.player) continue;
                if (destPiece) continue;
                
                moves.push({ row: newRow, col: newCol });
            }
            
            // Diagonal jumps
            const diagDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            const visited = new Set();
            visited.add(`${row},${col}`);
            
            function findJumps(r, c) {
                for (const [dr, dc] of diagDirs) {
                    const midR = r + dr;
                    const midC = c + dc;
                    const landR = r + 2 * dr;
                    const landC = c + 2 * dc;
                    
                    if (landR < 0 || landR > 7 || landC < 0 || landC > 7) continue;
                    if (midR < 0 || midR > 7 || midC < 0 || midC > 7) continue;
                    
                    const midPiece = board[midR][midC];
                    const landPiece = board[landR][landC];
                    
                    // Must jump over OWN piece, land on empty
                    if (!midPiece) continue;
                    if (midPiece.player !== piece.player) continue; // Can only jump over own pieces
                    if (landPiece) continue;
                    
                    const key = `${landR},${landC}`;
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    moves.push({ row: landR, col: landC });
                    findJumps(landR, landC);
                }
            }
            
            findJumps(row, col);
            
            return moves;
        }
        
        // Evaluate a position from a player's perspective
        function v7EvaluatePosition(state, player) {
            const opponent = player === 'dark' ? 'light' : 'dark';
            const myGoalRow = player === 'dark' ? 0 : 7;
            const oppGoalRow = opponent === 'dark' ? 0 : 7;
            const myDirection = player === 'dark' ? -1 : 1;
            
            let score = 0;
            
            // Find all pieces and shadows
            const myPieces = [];
            const oppPieces = [];
            const myShadows = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = state.board[row][col];
                    if (piece?.type === 'golem') {
                        if (piece.player === player) {
                            myPieces.push({ row, col, piece });
                        } else {
                            oppPieces.push({ row, col, piece });
                        }
                    } else if (piece?.type === 'shadow' && piece.player === player) {
                        myShadows.push({ row, col });
                    }
                }
            }
            
            // Material
            score += (myPieces.length - oppPieces.length) * 50;
            
            // My best turn distance to goal
            const myHand = player === 'dark' ? state.darkHand : state.lightHand;
            const myResting = player === 'dark' ? state.darkResting : state.lightResting;
            let myBestTurnDistance = Infinity;
            
            for (const { row, col, piece } of myPieces) {
                const turnDist = v7TurnDistanceToGoal(state, row, col, piece, player, myGoalRow, myHand, myResting);
                myBestTurnDistance = Math.min(myBestTurnDistance, turnDist);
            }
            
            // Opponent's best turn distance to goal
            const oppHand = opponent === 'dark' ? state.darkHand : state.lightHand;
            const oppResting = opponent === 'dark' ? state.darkResting : state.lightResting;
            let oppBestTurnDistance = Infinity;
            
            for (const { row, col, piece } of oppPieces) {
                const turnDist = v7TurnDistanceToGoal(state, row, col, piece, opponent, oppGoalRow, oppHand, oppResting);
                oppBestTurnDistance = Math.min(oppBestTurnDistance, turnDist);
            }
            
            // Turn distance advantage - weighted heavily
            if (myBestTurnDistance < Infinity) {
                score += (10 - myBestTurnDistance) * 40;
            }
            if (oppBestTurnDistance < Infinity) {
                score -= (10 - oppBestTurnDistance) * 40;
            }
            
            // CRITICAL: If opponent can win in 1 turn, huge penalty
            if (oppBestTurnDistance === 1) {
                score -= 300;
            }
            
            // Bonus for pieces in opponent's half (attacking position)
            const oppHalf = player === 'dark' ? [0, 1, 2, 3] : [4, 5, 6, 7];
            for (const { row } of myPieces) {
                if (oppHalf.includes(row)) {
                    const distToGoal = Math.abs(row - myGoalRow);
                    score += 20 + (4 - distToGoal) * 10;
                }
            }
            
            // Glyph availability - can I move my advanced pieces?
            for (const { row, col, piece } of myPieces) {
                const distToGoal = Math.abs(row - myGoalRow);
                if (distToGoal <= 3) {
                    const canMove = v7CanMovePiece(piece, myHand, myResting);
                    if (canMove) {
                        score += 15;
                    } else {
                        score -= 10;
                    }
                }
            }
            
            // === PIECE COORDINATION ===
            // Bonus for pieces that can jump off each other toward goal
            for (const p1 of myPieces) {
                for (const p2 of myPieces) {
                    if (p1.row === p2.row && p1.col === p2.col) continue;
                    
                    // Check if p1 can jump over p2 toward goal
                    const diagDirs = [[myDirection, 1], [myDirection, -1]];
                    for (const [dr, dc] of diagDirs) {
                        // p2 would need to be at p1 + (dr, dc)
                        // landing would be at p1 + 2*(dr, dc)
                        if (p2.row === p1.row + dr && p2.col === p1.col + dc) {
                            const landRow = p1.row + 2 * dr;
                            const landCol = p1.col + 2 * dc;
                            
                            if (landRow >= 0 && landRow <= 7 && landCol >= 0 && landCol <= 7) {
                                const landSpot = state.board[landRow][landCol];
                                if (!landSpot) {
                                    // p1 can jump over p2!
                                    score += 15;
                                    
                                    // Extra bonus if the jump reaches goal
                                    if (landRow === myGoalRow) {
                                        score += 40;
                                    }
                                    // Bonus if jump gets significantly closer
                                    else if (Math.abs(landRow - myGoalRow) < Math.abs(p1.row - myGoalRow)) {
                                        score += 10;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Also check jumps over shadows
                for (const shadow of myShadows) {
                    const diagDirs = [[myDirection, 1], [myDirection, -1]];
                    for (const [dr, dc] of diagDirs) {
                        if (shadow.row === p1.row + dr && shadow.col === p1.col + dc) {
                            const landRow = p1.row + 2 * dr;
                            const landCol = p1.col + 2 * dc;
                            
                            if (landRow >= 0 && landRow <= 7 && landCol >= 0 && landCol <= 7) {
                                const landSpot = state.board[landRow][landCol];
                                if (!landSpot) {
                                    score += 12; // Slightly less than golem jump
                                    if (landRow === myGoalRow) {
                                        score += 35;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Bonus for pieces that form capture setups
            for (const p1 of myPieces) {
                // Check if p1 can participate in a capture with another piece
                const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                for (const [dr, dc] of dirs) {
                    const supportRow = p1.row + dr * 2;
                    const supportCol = p1.col + dc * 2;
                    const targetRow = p1.row + dr;
                    const targetCol = p1.col + dc;
                    
                    if (supportRow < 0 || supportRow > 7 || supportCol < 0 || supportCol > 7) continue;
                    if (targetRow < 0 || targetRow > 7 || targetCol < 0 || targetCol > 7) continue;
                    
                    const supportPiece = state.board[supportRow][supportCol];
                    const targetPiece = state.board[targetRow][targetCol];
                    
                    // We have a support piece, and there's an enemy in between
                    if (supportPiece?.player === player && targetPiece?.player === opponent) {
                        // Check if p1 could capture this target (different traits)
                        if (targetPiece.type === 'golem') {
                            if (p1.piece.shape !== targetPiece.shape && p1.piece.color !== targetPiece.color) {
                                // More valuable to threaten advanced pieces
                                const targetDistToGoal = Math.abs(targetRow - oppGoalRow);
                                const threatValue = 25 + (7 - targetDistToGoal) * 5;
                                score += threatValue;
                            }
                        } else {
                            score += 20; // Can capture shadow
                        }
                    }
                }
            }
            
            // === DISRUPTION SCORING ===
            // Evaluate how well we're positioned to threaten opponent's advanced pieces
            for (const opp of oppPieces) {
                const oppDistToGoal = Math.abs(opp.row - oppGoalRow);
                
                // The more advanced an opponent piece, the more we should be threatening it
                if (oppDistToGoal <= 4) { // Opponent piece is in our half or close
                    const threatLevel = 5 - oppDistToGoal; // 1-5 based on how close to our goal
                    
                    // Check if any of our pieces can capture this opponent piece
                    let canCapture = false;
                    let captureSetupExists = false;
                    
                    for (const [dr, dc] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
                        const side1Row = opp.row + dr;
                        const side1Col = opp.col + dc;
                        const side2Row = opp.row - dr;
                        const side2Col = opp.col - dc;
                        
                        if (side1Row < 0 || side1Row > 7 || side1Col < 0 || side1Col > 7) continue;
                        if (side2Row < 0 || side2Row > 7 || side2Col < 0 || side2Col > 7) continue;
                        
                        const piece1 = state.board[side1Row][side1Col];
                        const piece2 = state.board[side2Row][side2Col];
                        
                        // Check if we already have pieces on both sides (immediate capture possible)
                        if (piece1?.player === player && piece2?.player === player) {
                            // One of these pieces could capture if it can and has right traits
                            for (const p of myPieces) {
                                if ((p.row === side1Row && p.col === side1Col) ||
                                    (p.row === side2Row && p.col === side2Col)) {
                                    if (p.piece.shape !== opp.piece.shape && p.piece.color !== opp.piece.color) {
                                        if (v7CanMovePiece(p.piece, myHand, myResting)) {
                                            canCapture = true;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Check if we have one piece on a side and could move another to the other side
                        if ((piece1?.player === player && !piece2) || 
                            (piece2?.player === player && !piece1)) {
                            const ourSide = piece1?.player === player ? { row: side1Row, col: side1Col } : { row: side2Row, col: side2Col };
                            const emptySide = piece1?.player === player ? { row: side2Row, col: side2Col } : { row: side1Row, col: side1Col };
                            
                            // Can any piece reach the empty side?
                            for (const p of myPieces) {
                                if (p.row === ourSide.row && p.col === ourSide.col) continue;
                                
                                // Can this piece capture the opponent?
                                if (p.piece.shape === opp.piece.shape || p.piece.color === opp.piece.color) continue;
                                
                                const pMoves = v7GetValidMoves(state.board, p.row, p.col);
                                for (const pm of pMoves) {
                                    if (pm.row === emptySide.row && pm.col === emptySide.col) {
                                        captureSetupExists = true;
                                        break;
                                    }
                                }
                                if (captureSetupExists) break;
                            }
                        }
                        
                        if (canCapture || captureSetupExists) break;
                    }
                    
                    // Score based on threat situation
                    if (canCapture) {
                        score += threatLevel * 30; // We can capture this piece
                    } else if (captureSetupExists) {
                        score += threatLevel * 15; // We're one move away from capture
                    } else if (oppDistToGoal <= 2) {
                        // Advanced piece we can't threaten - penalty
                        score -= threatLevel * 20;
                    }
                }
            }
            
            return score;
        }
        
        // Calculate turn distance to goal for a piece
        // This considers: can we move it now? Do we need to wait for glyphs?
        function v7TurnDistanceToGoal(state, row, col, piece, player, goalRow, hand, resting) {
            // Check if piece can reach goal this turn
            const moves = v7GetValidMoves(state.board, row, col);
            for (const m of moves) {
                if (m.row === goalRow) {
                    // Can reach goal - but can we move this piece?
                    if (v7CanMovePiece(piece, hand, resting)) {
                        return 1; // Win in 1 turn
                    } else {
                        return 2; // Could win but need the right glyph
                    }
                }
            }
            
            // Simple heuristic: row distance as baseline
            const rowDistance = Math.abs(row - goalRow);
            
            // Each orthogonal step covers 2 rows, each jump covers 2 rows
            // But we need right glyphs, so estimate turns
            const baseTurns = Math.ceil(rowDistance / 2);
            
            // Add penalty if we can't currently move this piece
            if (!v7CanMovePiece(piece, hand, resting)) {
                return baseTurns + 1;
            }
            
            return baseTurns;
        }
        
        // Check if we have a glyph to move a piece
        function v7CanMovePiece(piece, hand, resting) {
            for (const glyph of hand) {
                let effective = glyph;
                if (glyph.type === 'mirror') {
                    effective = resting;
                }
                if (!effective) continue;
                
                if (effective.type === 'color' && piece.color === effective.value) return true;
                if (effective.type === 'shape' && piece.shape === effective.value) return true;
            }
            return false;
        }

        function executeCpuMove(move) {
            if (!move) return;
            
            saveState();
            
            // Select the glyph
            gameState.selectedGlyph = { index: move.glyphIndex };
            
            if (move.type === 'movement') {
                // Set shadow primed if needed
                gameState.shadowPrimed = move.placeShadow;
                
                // Execute the move
                movePiece(move.from.row, move.from.col, move.to.row, move.to.col);
            } else if (move.type === 'reactivation') {
                // Select the mask
                gameState.selectedMask = { index: move.maskIndex };
                
                // Execute reactivation
                executeReactivation(move.position.row, move.position.col, move.maskIndex);
            }
        }

        function triggerCpuMoveIfNeeded() {
            if (!cpuMode || gameState.gameOver) return;
            
            // In spectate mode, CPU plays both sides
            // In regular CPU mode, only play if it's the CPU's turn
            if (!spectateMode && gameState.currentPlayer !== cpuPlayer) return;
            
            // Use longer delay for spectate mode so viewers can follow
            const delay = spectateMode ? 4000 : 500;
            
            setTimeout(() => {
                // Check conditions again after delay
                if (gameState.gameOver) return;
                if (!spectateMode && gameState.currentPlayer !== cpuPlayer) return;
                
                const move = cpuGetMoveV7();
                if (move) {
                    executeCpuMove(move);
                }
            }, delay);
        }

        // === GAME END ===
        function showBreakthroughNotification(scorer, opponentLivesRemaining) {
            // Create temporary notification
            const notification = document.createElement('div');
            notification.className = 'breakthrough-notification';
            notification.innerHTML = `
                <div style="font-size: 1.2rem; font-weight: 600;">${capitalize(scorer)} scores!</div>
                <div style="font-size: 0.9rem; opacity: 0.8; margin-top: 4px;">
                    ${opponentLivesRemaining} ${opponentLivesRemaining === 1 ? 'life' : 'lives'} remaining
                </div>
            `;
            document.body.appendChild(notification);
            
            // Animate in
            requestAnimationFrame(() => {
                notification.classList.add('show');
            });
            
            // Remove after delay
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 1500);
        }
        
        function endGame(winner, message) {
            gameState.gameOver = true;
            if (gameState.clockInterval) clearInterval(gameState.clockInterval);
            
            // Clear online backup since game ended normally
            if (onlineMode) {
                clearOnlineGameBackup();
            }

            document.getElementById('victoryTitle').textContent = winner === 'draw' ? 'Draw!' : 'Victory!';
            document.getElementById('victoryMessage').textContent = 
                message || `${capitalize(winner)} Wins!`;
            document.getElementById('victoryModal').classList.add('show');
            
            // Show analysis console after a brief delay
            setTimeout(() => {
                showAnalysisUI();
            }, 500);
        }

        // === UNDO ===
        function saveState() {
            historyStack.push(JSON.stringify(gameState));
        }

        function undoMove() {
            if (historyStack.length === 0 || gameState.gameOver) return;

            const prevState = JSON.parse(historyStack.pop());
            
            // Also remove the last recorded move from analysis
            if (analysisData.moves.length > 0) {
                analysisData.moves.pop();
            }
            
            // Preserve clock interval
            const clockInterval = gameState.clockInterval;
            
            gameState = prevState;
            gameState.clockInterval = clockInterval;
            gameState.lastMoveTime = Date.now();

            renderGame();
        }

        // === UTILITIES ===
        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        function startNewGame() {
            document.getElementById('victoryModal').classList.remove('show');
            showNewGameModal();
        }

        // Board flip functionality
        let boardFlipped = false;

        function toggleBoardFlip() {
            boardFlipped = !boardFlipped;
            applyBoardFlip();
        }

        function setBoardFlip(flipped) {
            boardFlipped = flipped;
            applyBoardFlip();
        }

        function applyBoardFlip() {
            const board = document.getElementById('board');
            const sidebar = document.querySelector('.left-sidebar');
            const gameArea = document.querySelector('.game-area');
            board.classList.toggle('flipped', boardFlipped);
            sidebar.classList.toggle('flipped', boardFlipped);
            gameArea.classList.toggle('flipped', boardFlipped);
            updateCoordinates();
        }

        function updateCoordinates() {
            // Remove all existing coordinates
            document.querySelectorAll('.coord').forEach(el => el.remove());
            
            // When not flipped: ranks on col 0 (left), files on row 7 (bottom)
            // When flipped: ranks on col 7 (left after flip), files on row 0 (bottom after flip)
            
            const rankCol = boardFlipped ? 7 : 0;
            const fileRow = boardFlipped ? 0 : 7;
            
            for (let row = 0; row < 8; row++) {
                const square = document.getElementById(`sq-${row}-${rankCol}`);
                if (square) {
                    const rankCoord = document.createElement('span');
                    rankCoord.className = 'coord coord-rank';
                    rankCoord.textContent = 8 - row;
                    square.appendChild(rankCoord);
                }
            }
            
            for (let col = 0; col < 8; col++) {
                const square = document.getElementById(`sq-${fileRow}-${col}`);
                if (square) {
                    const fileCoord = document.createElement('span');
                    fileCoord.className = 'coord coord-file';
                    fileCoord.textContent = 'abcdefgh'[col];
                    square.appendChild(fileCoord);
                }
            }
        }

        function showNewGameModal() {
            // Restore sliders to last selected values
            const timeSlider = document.getElementById('timeSlider');
            const incrementSlider = document.getElementById('incrementSlider');
            
            // Convert selectedTime back to minutes for slider
            timeSlider.value = selectedTime === 0 ? 0 : selectedTime / 60;
            incrementSlider.value = selectedIncrement;
            
            updateTimeDisplay();
            updateIncrementDisplay();
            document.getElementById('newGameModal').classList.add('show');
        }

        function updateTimeDisplay() {
            const slider = document.getElementById('timeSlider');
            const display = document.getElementById('timeDisplay');
            const minutes = parseInt(slider.value);
            
            if (minutes === 0) {
                display.textContent = '∞';
                selectedTime = 0;
            } else {
                display.textContent = `${minutes}:00`;
                selectedTime = minutes * 60;
            }
        }

        function updateIncrementDisplay() {
            const slider = document.getElementById('incrementSlider');
            const display = document.getElementById('incrementDisplay');
            const seconds = parseInt(slider.value);
            
            display.textContent = `+${seconds}s`;
            selectedIncrement = seconds;
        }

        function setLives(lives) {
            selectedLives = lives;
            
            // Update button styles (0, 1, 2, 3 are the options)
            [1, 2, 3].forEach(n => {
                const btn = document.getElementById(`lives${n}Btn`);
                btn.style.background = lives === n ? 'var(--gold)' : 'var(--slate)';
                btn.style.color = lives === n ? '' : 'var(--pearl)';
            });
            
            // Sudden Death button (0 lives)
            const sdBtn = document.getElementById('lives0Btn');
            sdBtn.style.background = lives === 0 ? 'var(--gold)' : 'var(--slate)';
            sdBtn.style.color = lives === 0 ? '' : 'var(--pearl)';
        }

        // Game Mode controls
        let selectedGameMode = 'human'; // 'human', 'cpu', or 'online'
        let selectedPlayerSide = 'dark';
        let spectateMode = false;

        function setGameMode(mode) {
            selectedGameMode = mode;
            
            // If online mode selected, open the online modal instead
            if (mode === 'online') {
                document.getElementById('newGameModal').classList.remove('show');
                openOnlineModal();
                return;
            }
            
            // Update button styles
            document.getElementById('humanBtn').style.background = mode === 'human' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('humanBtn').style.color = mode === 'human' ? '' : 'var(--pearl)';
            document.getElementById('cpuBtn').style.background = mode === 'cpu' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('cpuBtn').style.color = mode === 'cpu' ? '' : 'var(--pearl)';
            document.getElementById('onlineBtn').style.background = mode === 'online' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('onlineBtn').style.color = mode === 'online' ? '' : 'var(--pearl)';
            
            // Show side selection only for CPU mode
            document.getElementById('cpuSideSelect').style.display = mode === 'cpu' ? 'block' : 'none';
        }

        function setPlayerSide(side) {
            selectedPlayerSide = side;
            
            document.getElementById('playDarkBtn').style.background = side === 'dark' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('playDarkBtn').style.color = side === 'dark' ? '' : 'var(--pearl)';
            document.getElementById('playLightBtn').style.background = side === 'light' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('playLightBtn').style.color = side === 'light' ? '' : 'var(--pearl)';
        }

        function startGameWithTime() {
            // Exit tutorial if active
            if (tutorialMode) {
                exitTutorial();
                document.getElementById('welcomeModal').classList.remove('show');
            }
            
            // Set game mode based on selection
            if (selectedGameMode === 'cpu') {
                cpuMode = true;
                spectateMode = false;
                cpuPlayer = selectedPlayerSide === 'dark' ? 'light' : 'dark';
            } else {
                cpuMode = false;
                spectateMode = false;
                cpuPlayer = 'light';
            }
            
            document.getElementById('newGameModal').classList.remove('show');
            initGame();
            
            // Auto-flip board when playing as Light vs CPU
            if (cpuMode && selectedPlayerSide === 'light') {
                setBoardFlip(true);
            } else {
                setBoardFlip(false);
            }
            
            // If CPU plays first (player chose Light) or spectate mode, trigger CPU move
            if (cpuMode && (cpuPlayer === 'dark' || spectateMode)) {
                triggerCpuMoveIfNeeded();
            }
        }

        function closeWelcome() {
            document.getElementById('welcomeModal').classList.remove('show');
        }

        function closeVictoryModal() {
            document.getElementById('victoryModal').classList.remove('show');
        }

        // === RESIGN / DRAW ===
        let resigningPlayer = null;

        function confirmResign(player) {
            if (gameState.gameOver) return;
            
            resigningPlayer = player;
            document.getElementById('resignMessage').textContent = 
                `${capitalize(player)} player: What would you like to do?`;
            document.getElementById('resignModal').classList.add('show');
        }

        function executeResign() {
            if (!resigningPlayer) return;
            
            // In online mode, can only resign as local player
            if (onlineMode && resigningPlayer !== localPlayer) return;
            
            document.getElementById('resignModal').classList.remove('show');
            const winner = resigningPlayer === 'dark' ? 'light' : 'dark';
            
            // Notify opponent
            if (onlineMode) {
                sendOnlineMessage({
                    type: 'resign',
                    player: resigningPlayer
                });
            }
            
            endGame(winner, `${capitalize(winner)} wins by resignation!`);
            resigningPlayer = null;
        }

        function showDrawOffer() {
            if (!resigningPlayer) return;
            
            document.getElementById('resignModal').classList.remove('show');
            
            // In online mode, send draw offer to opponent
            if (onlineMode) {
                if (resigningPlayer !== localPlayer) return;
                sendOnlineMessage({ type: 'drawOffer' });
                // Show waiting message
                document.getElementById('drawOfferMessage').textContent = 'Waiting for opponent to respond to draw offer...';
                document.getElementById('drawOfferModal').classList.add('show');
                // Hide the accept/decline buttons - we're offering, not receiving
                document.querySelector('#drawOfferModal .modal-content').innerHTML = `
                    <h2>Draw Offered</h2>
                    <p style="margin: 20px 0; color: var(--silver);">Waiting for opponent to respond...</p>
                    <button class="btn" onclick="declineDraw()" style="background: var(--slate); color: var(--pearl);">Cancel</button>
                `;
                return;
            }
            
            const otherPlayer = resigningPlayer === 'dark' ? 'light' : 'dark';
            
            document.getElementById('drawOfferMessage').textContent = 
                `${capitalize(resigningPlayer)} offers a draw. ${capitalize(otherPlayer)}, do you accept?`;
            document.getElementById('drawOfferModal').classList.add('show');
        }

        function acceptDraw() {
            document.getElementById('drawOfferModal').classList.remove('show');
            
            // Notify opponent
            if (onlineMode) {
                sendOnlineMessage({ type: 'drawAccept' });
            }
            
            endGame('draw', 'Game drawn by agreement!');
            resigningPlayer = null;
        }

        function declineDraw() {
            document.getElementById('drawOfferModal').classList.remove('show');
            
            // Notify opponent
            if (onlineMode) {
                sendOnlineMessage({ type: 'drawDecline' });
            }
            
            resigningPlayer = null;
        }

        function cancelResign() {
            document.getElementById('resignModal').classList.remove('show');
            resigningPlayer = null;
        }

        function toggleRules() {
            const modal = document.getElementById('rulesModal');
            if (modal.classList.contains('show')) {
                // Closing - reset to language selection for next open
                modal.classList.remove('show');
                document.getElementById('rulesLangSelect').style.display = 'block';
                document.getElementById('rulesContent').style.display = 'none';
            } else {
                // Opening - show language selection
                document.getElementById('rulesLangSelect').style.display = 'block';
                document.getElementById('rulesContent').style.display = 'none';
                modal.classList.add('show');
            }
        }
        
        function showRulesWithLang(lang) {
            setLanguage(lang);
            document.getElementById('rulesLangSelect').style.display = 'none';
            document.getElementById('rulesContent').style.display = 'block';
        }
        
        const aboutTranslations = {
            en: {
                text: "I've been working on this game with support from friends and family since 2017. Most of it came together within a year, some of it took longer to draw out. I hope others find as much joy and connection in playing it as I have found in making it.",
                contact: 'If you have thoughts about the game, feel free to drop me a line!<br><a href="mailto:jfkuang@proton.me" style="color: var(--gold);">jfkuang@proton.me</a>'
            },
            zh: {
                text: "自2017年以来，我一直在朋友和家人的支持下开发这款游戏。大部分内容在一年内完成，有些则花了更长时间才逐渐成形。我希望其他人在游戏中也能找到我在创作过程中所感受到的快乐与连结。",
                contact: '如果您对游戏有任何想法，欢迎联系我！<br><a href="mailto:jfkuang@proton.me" style="color: var(--gold);">jfkuang@proton.me</a>'
            },
            es: {
                text: "He estado trabajando en este juego con el apoyo de amigos y familiares desde 2017. La mayor parte se desarrolló en un año, algunas cosas tardaron más en tomar forma. Espero que otros encuentren tanta alegría y conexión al jugarlo como yo he encontrado al crearlo.",
                contact: '¡Si tienes comentarios sobre el juego, no dudes en escribirme!<br><a href="mailto:jfkuang@proton.me" style="color: var(--gold);">jfkuang@proton.me</a>'
            }
        };
        
        function showAbout() {
            // Show language selection first
            document.getElementById('aboutLangSelect').style.display = 'block';
            document.getElementById('aboutContent').style.display = 'none';
            document.getElementById('aboutModal').classList.add('show');
        }
        
        function showAboutWithLang(lang) {
            const trans = aboutTranslations[lang] || aboutTranslations.en;
            document.getElementById('aboutText').innerHTML = trans.text;
            document.getElementById('aboutContact').innerHTML = trans.contact;
            document.getElementById('aboutLangSelect').style.display = 'none';
            document.getElementById('aboutContent').style.display = 'block';
        }
        
        function closeAbout() {
            document.getElementById('aboutModal').classList.remove('show');
            // Reset to language selection for next open
            document.getElementById('aboutLangSelect').style.display = 'block';
            document.getElementById('aboutContent').style.display = 'none';
        }

        // Rules tab switching
        document.querySelectorAll('.rules-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active from all tabs and contents
                document.querySelectorAll('.rules-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.rules-tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active to clicked tab and corresponding content
                tab.classList.add('active');
                const tabName = tab.dataset.tab;
                document.getElementById(`rules-${tabName}`).classList.add('active');
            });
        });

        // === TUTORIAL ===
        const tutorialTotalCapsules = 16;

        // Tutorial scenarios for interactive capsules
        const tutorialScenarios = {
            // Capsule 4: Glyphs
            4: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Simple setup to practice glyph selection (dark pieces on light squares: row+col even)
                    board[6][0] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'white' };
                    board[6][2] = { type: 'golem', player: 'dark', shape: 'Χ', color: 'blue' };
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'orange' };
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Λ' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Ω' }
                ],
                darkResting: { type: 'color', value: 'orange' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['select-golem-1', 'select-golem-2']
            },
            // Capsule 5: Steps
            5: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // One dark piece to move, one light piece blocking one direction
                    board[4][4] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'white' };  // e4 - piece to move
                    board[3][4] = { type: 'golem', player: 'light', shape: 'Χ', color: 'blue' };  // e5 - blocker (blocks ortho step north)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Λ' },
                    { type: 'color', value: 'white' },
                    { type: 'shape', value: 'Ω' },
                ],
                darkResting: { type: 'color', value: 'orange' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['ortho-step', 'diag-step']
            },
            // Capsule 6: Single Jump
            6: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Simple setup for a single forward jump (dark on light squares: row+col even)
                    // f3 = [5][5], d3 = [5][3], e4 = [4][4]
                    board[5][5] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'white' };  // f3 (5+5=10 even)
                    board[5][3] = { type: 'golem', player: 'dark', shape: 'Χ', color: 'blue' };   // d3 (5+3=8 even)
                    board[4][4] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'orange' }; // e4 - jumper (4+4=8 even)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Ω' },
                    { type: 'color', value: 'orange' },
                    { type: 'shape', value: 'Χ' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['single-jump']
            },
            // Capsule 7: Multi-Piece Jump
            7: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Setup for jumping over multiple contiguous pieces (dark on light squares: row+col even)
                    // f1 = [7][5], e2 = [6][4], d3 = [5][3], c4 = [4][2]
                    // Diagonal line: jumper at f1 jumps over e2, d3 to land beyond c4
                    board[7][5] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'orange' }; // f1 - jumper (7+5=12 even)
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'white' };  // e2 (6+4=10 even)
                    board[5][3] = { type: 'golem', player: 'dark', shape: 'Χ', color: 'blue' };   // d3 (5+3=8 even)
                    board[4][2] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'blue' };   // c4 (4+2=6 even)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Ω' },
                    { type: 'color', value: 'orange' },
                    { type: 'shape', value: 'Χ' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['multi-piece-jump']
            },
            // Capsule 8: Chain Jumps
            8: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // h1=[7][7] blue/peak jumper, all other pieces are shadows
                    // g2=[6][6], e2=[6][4], c2=[6][2], c4=[4][2], d5=[3][3]
                    board[7][7] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'blue' };   // h1 - the only golem
                    board[6][6] = { type: 'shadow', player: 'dark' };  // g2
                    board[6][4] = { type: 'shadow', player: 'dark' };  // e2
                    board[6][2] = { type: 'shadow', player: 'dark' };  // c2
                    board[4][2] = { type: 'shadow', player: 'dark' };  // c4
                    board[3][3] = { type: 'shadow', player: 'dark' };  // d5
                    return board;
                },
                darkHand: [
                    { type: 'mirror', value: '◇' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Λ' }
                ],
                darkResting: { type: 'color', value: 'orange' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 0, masks: [] },  // No shadows left to place
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['chain-jump']
            },
            // Capsule 9: Winning
            9: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // a6 = [2][0], b7 = [1][1] shadow, f7 = [1][5]
                    board[2][0] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'orange' }; // a6 - can jump to win (2+0=2 even)
                    board[1][1] = { type: 'shadow', player: 'dark' };  // b7 - shadow to jump over (1+1=2 even)
                    board[1][5] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'white' };  // f7 - one step from victory (1+5=6 even)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Ω' },
                    { type: 'color', value: 'orange' },
                    { type: 'shape', value: 'Λ' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 0, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['reach-goal']
            },
            // Capsule 10: Capturing
            10: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Light piece ready to be captured (light on dark: row+col odd, dark on light: row+col even)
                    board[4][3] = { type: 'golem', player: 'light', shape: 'Ω', color: 'orange' }; // Target (4+3=7 odd=dark square)
                    board[4][2] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'orange' }; // Support (4+2=6 even=light square)
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Χ', color: 'blue' }; // Capturer (6+4=10 even=light square)
                    board[7][3] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'white' }; // Extra (7+3=10 even=light square)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Χ' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Ω' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['capture']
            },
            // Capsule 11: Double Capture with Immunity
            11: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Dark Χ/blue moves to capture two light pieces, but third is immune (shares blue)
                    // Dark piece at e2 [6][4] moves to e4 [4][4] to sandwich two pieces
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Χ', color: 'blue' };   // Capturer (6+4=10 even)
                    board[4][2] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'white' };  // Support left (4+2=6 even)
                    board[4][6] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'orange' }; // Support right (4+6=10 even)
                    board[2][4] = { type: 'golem', player: 'dark', shape: 'Λ', color: 'orange' }; // Support top (2+4=6 even)
                    // Light pieces to be captured (on dark squares: row+col odd)
                    board[4][3] = { type: 'golem', player: 'light', shape: 'Ω', color: 'orange' }; // Will be captured (4+3=7 odd)
                    board[4][5] = { type: 'golem', player: 'light', shape: 'Λ', color: 'white' };  // Will be captured (4+5=9 odd)
                    board[3][4] = { type: 'golem', player: 'light', shape: 'Ω', color: 'blue' };   // IMMUNE - shares blue (3+4=7 odd)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Χ' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Ω' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['double-capture']
            },
            // Capsule 12: Safe Movement
            12: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Dark Χ/blue can move between two light pieces safely because it shares blue with one
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Χ', color: 'blue' };   // Mover (6+4=10 even)
                    // Light pieces that would sandwich but can't capture (one shares blue)
                    board[4][3] = { type: 'golem', player: 'light', shape: 'Ω', color: 'blue' };  // Shares blue - immune! (4+3=7 odd)
                    board[4][5] = { type: 'golem', player: 'light', shape: 'Λ', color: 'orange' }; // (4+5=9 odd)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Χ' },
                    { type: 'color', value: 'blue' },
                    { type: 'shape', value: 'Ω' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                currentPlayer: 'dark',
                objectives: ['safe-move']
            },
            // Capsule 13: Shadows
            13: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // d3 = [5][3] golem, e2 = [6][4] shadow, c2 = [6][2] shadow
                    board[5][3] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'orange' }; // d3 - the only moveable piece (5+3=8 even)
                    board[6][4] = { type: 'shadow', player: 'dark' };  // e2 (6+4=10 even)
                    board[6][2] = { type: 'shadow', player: 'dark' };  // c2 (6+2=8 even)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Ω' },
                    { type: 'color', value: 'orange' },
                    { type: 'shape', value: 'Χ' }
                ],
                darkResting: { type: 'color', value: 'white' },
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 1, masks: [] },
                lightSupply: { shadows: 1, masks: [] },
                lightHasPlacedShadow: true, // Allow dark to place shadows
                shadowPrimed: true, // Preset the shadow toggle to on
                currentPlayer: 'dark',
                objectives: ['shadow-place']
            },
            // Capsule 14: Reactivation
            14: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Shadow on board (light square for dark: row+col even), mask in supply
                    board[5][1] = { type: 'shadow', player: 'dark' }; // 5+1=6 even=light square
                    board[7][3] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'orange' }; // 7+3=10 even=light square
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Λ' },
                    { type: 'color', value: 'white' },
                    { type: 'shape', value: 'Ω' }
                ],
                darkResting: { type: 'shape', value: 'Λ' }, // Matches mask shape
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 0, masks: [{ shape: 'Λ', color: 'white' }] }, // Mask matches Λ + white
                lightSupply: { shadows: 1, masks: [] },
                lightHasPlacedShadow: true,
                currentPlayer: 'dark',
                objectives: ['reactivate']
            },
            // Capsule 15: Reactivation Capture
            15: {
                board: createEmptyBoard(),
                setup: function(board) {
                    // Shadow at e4 [4][4], support at e2 [6][4], light target at e3 [5][4]
                    // When mask reactivates on shadow, it sandwiches and captures the light piece
                    board[4][4] = { type: 'shadow', player: 'dark' }; // e4 - shadow to reactivate on (4+4=8 even)
                    board[6][4] = { type: 'golem', player: 'dark', shape: 'Ω', color: 'orange' }; // e2 - support (6+4=10 even)
                    board[5][4] = { type: 'golem', player: 'light', shape: 'Χ', color: 'blue' }; // e3 - target (5+4=9 odd)
                    return board;
                },
                darkHand: [
                    { type: 'shape', value: 'Λ' },
                    { type: 'color', value: 'white' },
                    { type: 'shape', value: 'Ω' }
                ],
                darkResting: { type: 'shape', value: 'Λ' }, // Matches mask shape
                lightHand: [],
                lightResting: null,
                darkSupply: { shadows: 0, masks: [{ shape: 'Λ', color: 'white' }] }, // Mask matches Λ + white
                lightSupply: { shadows: 1, masks: [] },
                lightHasPlacedShadow: true,
                currentPlayer: 'dark',
                objectives: ['reactivate-capture']
            }
        };

        function createEmptyBoard() {
            return Array(8).fill(null).map(() => Array(8).fill(null));
        }

        function openTutorial() {
            // Show language selection first
            document.getElementById('tutorialLangSelect').style.display = 'block';
            document.getElementById('tutorialNav').style.display = 'none';
            document.getElementById('tutorialCapsules').style.display = 'none';
            document.getElementById('tutorialModal').classList.add('show');
        }
        
        function startTutorialWithLang(lang) {
            // Apply language
            setLanguage(lang);
            
            // Hide language selection, show tutorial content
            document.getElementById('tutorialLangSelect').style.display = 'none';
            document.getElementById('tutorialNav').style.display = 'flex';
            document.getElementById('tutorialCapsules').style.display = 'block';
            
            // Initialize tutorial
            tutorialCurrentCapsule = 1;
            tutorialMode = true;
            
            // Stop the clock
            if (gameState.clockInterval) {
                clearInterval(gameState.clockInterval);
            }
            
            // Save current game state
            tutorialSavedState = JSON.parse(JSON.stringify(gameState));
            // Can't stringify the interval, save it separately
            tutorialSavedState.clockInterval = gameState.clockInterval;
            
            updateTutorialDisplay();
        }

        function closeTutorial() {
            document.getElementById('tutorialModal').classList.remove('show');
            document.getElementById('tutorialConsole').classList.remove('show');
            document.querySelector('.game-area').classList.remove('tutorial-active');
            
            // Reset language selector visibility for next open
            document.getElementById('tutorialLangSelect').style.display = 'block';
            document.getElementById('tutorialNav').style.display = 'none';
            document.getElementById('tutorialCapsules').style.display = 'none';
            
            tutorialMode = false;
            
            // Restore saved game state
            if (tutorialSavedState) {
                const savedClockInterval = tutorialSavedState.clockInterval;
                gameState = tutorialSavedState;
                tutorialSavedState = null;
                
                // Restart clock if game was timed and not over
                if (!gameState.noTimeLimit && !gameState.gameOver) {
                    startClock();
                }
                
                renderBoard();
                renderPanels();
            }
        }
        
        function exitTutorial() {
            // Close tutorial UI
            document.getElementById('tutorialModal').classList.remove('show');
            document.getElementById('tutorialConsole').classList.remove('show');
            document.querySelector('.game-area').classList.remove('tutorial-active');
            
            // Reset language selector visibility for next open
            document.getElementById('tutorialLangSelect').style.display = 'block';
            document.getElementById('tutorialNav').style.display = 'none';
            document.getElementById('tutorialCapsules').style.display = 'none';
            
            tutorialMode = false;
            tutorialSavedState = null;
            
            // Return to welcome modal
            document.getElementById('welcomeModal').classList.add('show');
        }

        function tutorialNext() {
            if (tutorialCurrentCapsule < tutorialTotalCapsules) {
                tutorialCurrentCapsule++;
                updateTutorialDisplay();
            }
        }

        function tutorialPrev() {
            if (tutorialCurrentCapsule > 1) {
                tutorialCurrentCapsule--;
                updateTutorialDisplay();
            }
        }

        function updateTutorialDisplay() {
            // Update progress in modal
            document.getElementById('tutorialProgress').textContent = 
                `${tutorialCurrentCapsule} / ${tutorialTotalCapsules}`;
            
            // Update nav buttons in modal
            document.getElementById('tutorialPrev').disabled = tutorialCurrentCapsule === 1;
            document.getElementById('tutorialNext').disabled = tutorialCurrentCapsule === tutorialTotalCapsules;
            
            // Show current capsule, hide others in modal
            const capsules = document.querySelectorAll('.tutorial-capsule');
            capsules.forEach(capsule => {
                const capsuleNum = parseInt(capsule.dataset.capsule);
                if (capsuleNum === tutorialCurrentCapsule) {
                    capsule.classList.add('active');
                } else {
                    capsule.classList.remove('active');
                }
            });

            // Check if this is an interactive capsule
            const currentCapsule = document.querySelector(`.tutorial-capsule[data-capsule="${tutorialCurrentCapsule}"]`);
            const isInteractive = currentCapsule && currentCapsule.dataset.interactive === 'true';
            const tutorialConsole = document.getElementById('tutorialConsole');
            const gameArea = document.querySelector('.game-area');
            
            if (isInteractive && tutorialScenarios[tutorialCurrentCapsule]) {
                // Hide modal, show console
                document.getElementById('tutorialModal').classList.remove('show');
                tutorialConsole.classList.add('show');
                gameArea.classList.add('tutorial-active');
                
                // Update console content
                const title = currentCapsule.querySelector('h2').textContent;
                const body = currentCapsule.querySelector('.tutorial-body').innerHTML;
                document.getElementById('tutorialConsoleTitle').textContent = title;
                document.getElementById('tutorialConsoleBody').innerHTML = body;
                document.getElementById('tutorialConsoleProgress').textContent = 
                    `${tutorialCurrentCapsule} / ${tutorialTotalCapsules}`;
                
                loadTutorialScenario(tutorialCurrentCapsule);
            } else {
                // Show modal, hide console
                document.getElementById('tutorialModal').classList.add('show');
                tutorialConsole.classList.remove('show');
                gameArea.classList.remove('tutorial-active');
            }
        }

        function loadTutorialScenario(capsuleNum) {
            const scenario = tutorialScenarios[capsuleNum];
            if (!scenario) return;

            // Create fresh board and apply setup
            const board = createEmptyBoard();
            scenario.setup(board);

            // Set game state for tutorial
            gameState.board = board;
            gameState.currentPlayer = scenario.currentPlayer || 'dark';
            gameState.darkHand = JSON.parse(JSON.stringify(scenario.darkHand));
            gameState.lightHand = JSON.parse(JSON.stringify(scenario.lightHand));
            gameState.darkResting = scenario.darkResting ? JSON.parse(JSON.stringify(scenario.darkResting)) : null;
            gameState.lightResting = scenario.lightResting ? JSON.parse(JSON.stringify(scenario.lightResting)) : null;
            gameState.darkSupply = JSON.parse(JSON.stringify(scenario.darkSupply));
            gameState.lightSupply = JSON.parse(JSON.stringify(scenario.lightSupply));
            gameState.lightHasPlacedShadow = scenario.lightHasPlacedShadow || false;
            gameState.selectedGlyph = null;
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.shadowPrimed = scenario.shadowPrimed || false;
            gameState.gameOver = false;
            gameState.winner = null;

            // Disable CPU and timers for tutorial
            cpuMode = false;
            spectateMode = false;
            gameState.noTimeLimit = true;

            // Initialize objectives for this scenario
            if (scenario.objectives) {
                tutorialObjectives = {};
                scenario.objectives.forEach(obj => tutorialObjectives[obj] = false);
                // Reset golem tracking for Glyphs tutorial
                tutorialSelectedGolems.clear();
                updateTutorialChecklist();
                checkAllObjectivesComplete();
            }

            renderGame();
        }

        function resetTutorialScenario() {
            // Reset objectives for this capsule
            const scenario = tutorialScenarios[tutorialCurrentCapsule];
            if (scenario && scenario.objectives) {
                tutorialObjectives = {};
                scenario.objectives.forEach(obj => tutorialObjectives[obj] = false);
                updateTutorialChecklist();
            }
            // Reset golem tracking for Glyphs tutorial
            tutorialSelectedGolems.clear();
            loadTutorialScenario(tutorialCurrentCapsule);
        }

        function checkTutorialMoveObjective(fromRow, fromCol, toRow, toCol) {
            if (tutorialCurrentCapsule !== 5) return; // Only for Steps capsule
            
            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;
            const absRowDiff = Math.abs(rowDiff);
            const absColDiff = Math.abs(colDiff);
            
            // Diagonal step: exactly 1 square diagonal
            if (absRowDiff === 1 && absColDiff === 1) {
                completeTutorialObjective('diag-step');
            }
            // Orthogonal step: exactly 2 squares in one direction
            else if ((absRowDiff === 2 && absColDiff === 0) || (absRowDiff === 0 && absColDiff === 2)) {
                completeTutorialObjective('ortho-step');
            }
        }

        function checkTutorialCaptureObjective(captureCount) {
            if (tutorialCurrentCapsule === 10) {
                completeTutorialObjective('capture');
            } else if (tutorialCurrentCapsule === 11 && captureCount >= 2) {
                completeTutorialObjective('double-capture');
            }
        }

        function checkTutorialShadowObjective() {
            if (tutorialCurrentCapsule === 13) {
                completeTutorialObjective('shadow-place');
            }
        }

        function checkTutorialSafeMoveObjective(toRow, toCol) {
            // Capsule 12: Check if dark moved between two enemy pieces without being captured
            if (tutorialCurrentCapsule === 12) {
                // Check if there are enemy pieces on opposite sides
                const board = gameState.board;
                const hasLeftEnemy = toCol > 0 && board[toRow][toCol - 1]?.player === 'light';
                const hasRightEnemy = toCol < 7 && board[toRow][toCol + 1]?.player === 'light';
                const hasTopEnemy = toRow > 0 && board[toRow - 1][toCol]?.player === 'light';
                const hasBottomEnemy = toRow < 7 && board[toRow + 1][toCol]?.player === 'light';
                
                // If sandwiched horizontally or vertically by enemies (but not captured), it's a safe move
                if ((hasLeftEnemy && hasRightEnemy) || (hasTopEnemy && hasBottomEnemy)) {
                    completeTutorialObjective('safe-move');
                }
            }
        }

        function checkTutorialJumpObjective(fromRow, fromCol, toRow, toCol, piecesJumped, emptySquares, squaresTraveled) {
            // Must be a diagonal jump (more than 1 square)
            if (squaresTraveled < 2) return;
            
            // Capsule 6: Single jump forward (over 1 piece, moving toward row 0)
            if (tutorialCurrentCapsule === 6) {
                // Single jump = 2 squares traveled, over 1 piece, moving forward (row decreases for dark)
                if (squaresTraveled === 2 && piecesJumped === 1 && toRow < fromRow) {
                    completeTutorialObjective('single-jump');
                }
            }
            // Capsule 7: Multi-piece jump - jumping over 2+ contiguous pieces in one hop
            else if (tutorialCurrentCapsule === 7) {
                // Setup: f1=[7][5] jumps over e2, d3, c4 to land at b5=[3][1]
                const fromF1 = (fromRow === 7 && fromCol === 5);
                const toB5 = (toRow === 3 && toCol === 1);
                
                if (fromF1 && toB5) {
                    completeTutorialObjective('multi-piece-jump');
                }
            }
            // Capsule 8: Chain jump - multiple hops with direction changes
            else if (tutorialCurrentCapsule === 8) {
                // Valid chain jump destinations from h1=[7][7]:
                // h1 to d1=[7][3], b3=[5][1], e6=[2][4]
                // Also from intermediate positions after first hop
                const fromH1 = (fromRow === 7 && fromCol === 7);
                
                const toD1 = (toRow === 7 && toCol === 3);
                const toB3 = (toRow === 5 && toCol === 1);
                const toE6 = (toRow === 2 && toCol === 4);
                
                // Any of these destinations from h1 counts as a chain jump
                if (fromH1 && (toD1 || toB3 || toE6)) {
                    completeTutorialObjective('chain-jump');
                }
                // Also pass if emptySquares > 0 or traveled far (generic chain detection)
                else if (emptySquares > 0 || squaresTraveled >= 4) {
                    completeTutorialObjective('chain-jump');
                }
            }
        }

        function checkGlyphTutorialGolemSelection(row, col) {
            // Track unique golems selected (no need to check for glyph)
            const key = `${row},${col}`;
            tutorialSelectedGolems.add(key);
            
            if (tutorialSelectedGolems.size >= 1) {
                completeTutorialObjective('select-golem-1');
            }
            if (tutorialSelectedGolems.size >= 2) {
                completeTutorialObjective('select-golem-2');
            }
        }

        function completeTutorialObjective(objectiveId) {
            if (tutorialObjectives[objectiveId] === false) {
                tutorialObjectives[objectiveId] = true;
                updateTutorialChecklist();
                checkAllObjectivesComplete();
            }
        }

        function updateTutorialChecklist() {
            const items = document.querySelectorAll('.tutorial-checklist li');
            items.forEach(item => {
                const obj = item.dataset.objective;
                if (tutorialObjectives[obj]) {
                    item.classList.add('completed');
                    item.textContent = item.textContent.replace('☐', '☑');
                } else {
                    item.classList.remove('completed');
                    item.textContent = item.textContent.replace('☑', '☐');
                }
            });
        }

        function checkAllObjectivesComplete() {
            const allComplete = Object.values(tutorialObjectives).every(v => v === true);
            
            // Update both possible continue buttons
            const modalBtn = document.getElementById('tutorialContinueBtn');
            const consoleBtn = document.getElementById('tutorialConsoleContinue');
            
            if (modalBtn) modalBtn.disabled = !allComplete;
            if (consoleBtn) consoleBtn.disabled = !allComplete;
            
            // Auto-continue after a delay when all objectives complete
            if (allComplete && Object.keys(tutorialObjectives).length > 0) {
                setTimeout(() => {
                    // Verify still complete (user might have reset)
                    const stillComplete = Object.values(tutorialObjectives).every(v => v === true);
                    if (stillComplete && tutorialMode) {
                        tutorialNext();
                    }
                }, 1500);
            }
        }

        function toggleHistoryPanel() {
            const header = document.getElementById('historyHeader');
            const body = document.getElementById('historyBody');
            header.classList.toggle('expanded');
            body.classList.toggle('expanded');
        }

        function toggleSaveLoadPanel() {
            const header = document.getElementById('saveLoadHeader');
            const body = document.getElementById('saveLoadBody');
            header.classList.toggle('expanded');
            body.classList.toggle('expanded');
        }

        function toggleMenu() {
            const btn = document.getElementById('menuBtn');
            const dropdown = document.getElementById('menuDropdown');
            btn.classList.toggle('open');
            dropdown.classList.toggle('open');
        }

        function closeMenu() {
            const btn = document.getElementById('menuBtn');
            const dropdown = document.getElementById('menuDropdown');
            btn.classList.remove('open');
            dropdown.classList.remove('open');
        }

        // === ANALYSIS CONSOLE ===
        function showAnalysisUI() {
            analysisData.isAnalysisMode = true;
            analysisData.currentMoveIndex = analysisData.moves.length - 1;
            
            document.getElementById('analysisRibbon').classList.add('show');
            document.getElementById('moveHistoryPanel').classList.add('show');
            document.getElementById('saveLoadPanel').classList.add('show');
            document.getElementById('board').classList.add('analysis-mode');
            
            // Clear filename since this is from a live game
            document.getElementById('analysisFilename').textContent = '';
            
            renderAnalysisRibbon();
            renderMoveHistory();
            goToMove(analysisData.currentMoveIndex);
        }
        
        function hideAnalysisUI() {
            analysisData.isAnalysisMode = false;
            lastGoToMoveIndex = null; // Reset so next analysis session works properly
            isNavigating = false;
            
            document.getElementById('analysisRibbon').classList.remove('show');
            document.getElementById('moveHistoryPanel').classList.remove('show');
            document.getElementById('saveLoadPanel').classList.remove('show');
            document.getElementById('board').classList.remove('analysis-mode');
            
            // Clear filename
            document.getElementById('analysisFilename').textContent = '';
        }
        
        function playFromHere() {
            // Current board state is already set from analysis navigation
            // Just need to reset game state flags and exit analysis mode
            
            // Clear the clock interval if any
            if (gameState.clockInterval) {
                clearInterval(gameState.clockInterval);
                gameState.clockInterval = null;
            }
            
            // Set up for timeless play
            gameState.gameOver = false;
            gameState.isPaused = false;
            gameState.noTimeLimit = true;
            gameState.darkTime = 0;
            gameState.lightTime = 0;
            gameState.lastMoveTime = Date.now();
            
            // Clear selections
            gameState.selectedGlyph = null;
            gameState.selectedPiece = null;
            gameState.selectedMask = null;
            gameState.shadowPrimed = false;
            
            // Reset history stack for new branch
            historyStack = [];
            
            // Reset analysis data for fresh recording from this point
            analysisData.initialState = serializeGameState();
            analysisData.moves = [];
            analysisData.currentMoveIndex = -1;
            
            // Hide analysis UI
            hideAnalysisUI();
            
            // Update clocks to show unlimited
            renderClocks();
            
            // Render the game
            renderGame();
        }
        
        let analysisRibbonDelegationAttached = false;
        
        function renderAnalysisRibbon() {
            const container = document.getElementById('ribbonMoves');
            
            // Build all HTML at once to minimize reflows
            let html = '';
            
            // Add "Start" marker
            html += `<button class="ribbon-move${analysisData.currentMoveIndex === -1 ? ' active' : ''}" data-move-index="-1">Start</button>`;
            
            analysisData.moves.forEach((move, index) => {
                const pieceColor = move.type === 'reactivation' ? move.mask.color : move.piece.color;
                const pieceShape = move.type === 'reactivation' ? move.mask.shape : move.piece.shape;
                const clockTime = move.player === 'dark' ? move.darkClock : move.lightClock;
                const isActive = index === analysisData.currentMoveIndex ? ' active' : '';
                
                html += `<button class="ribbon-move ${move.player}-move${isActive}" data-move-index="${index}">
                    <span class="ribbon-move-num">${index + 1}.</span>
                    <span class="piece-icon ${move.player}-piece">
                        <span style="color: ${getColorValue(pieceColor)}">${pieceShape}</span>
                    </span>
                    <span class="ribbon-coords">${getMoveCoords(move)}</span>
                    <span class="ribbon-glyph">[${getGlyphHTML(move.glyphUsed)}]</span>
                    ${formatCapturesCompact(move.captures)}
                    <span class="ribbon-time">${formatClockForAnalysis(clockTime)}</span>
                </button>`;
            });
            
            // Single DOM update
            container.innerHTML = html;
            
            // Attach event delegation ONCE, not on every render
            if (!analysisRibbonDelegationAttached) {
                container.addEventListener('click', function(e) {
                    const btn = e.target.closest('.ribbon-move');
                    if (btn && btn.dataset.moveIndex !== undefined) {
                        e.stopPropagation();
                        goToMove(parseInt(btn.dataset.moveIndex, 10));
                    }
                });
                analysisRibbonDelegationAttached = true;
            }
            
            // Scroll active move into view with requestAnimationFrame to avoid blocking
            requestAnimationFrame(() => {
                const activeMove = container.querySelector('.ribbon-move.active');
                if (activeMove) {
                    activeMove.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'nearest' });
                }
            });
        }
        
        let moveHistoryDelegationAttached = false;
        
        function renderMoveHistory() {
            const container = document.getElementById('historyList');
            
            // Build all HTML at once to minimize reflows
            let html = '';
            
            analysisData.moves.forEach((move, index) => {
                const pieceColor = move.type === 'reactivation' ? move.mask.color : move.piece.color;
                const pieceShape = move.type === 'reactivation' ? move.mask.shape : move.piece.shape;
                const clockTime = move.player === 'dark' ? move.darkClock : move.lightClock;
                const isActive = index === analysisData.currentMoveIndex ? ' active' : '';
                
                html += `<div class="history-move ${move.player}-move${isActive}" data-move-index="${index}">
                    <span class="move-number">${index + 1}.</span>
                    <span class="piece-icon ${move.player}-piece">
                        <span style="color: ${getColorValue(pieceColor)}">${pieceShape}</span>
                    </span>
                    <span class="move-notation">${formatMoveNotation(move)}</span>
                    <span class="glyph-indicator">[${getGlyphHTML(move.glyphUsed)}]</span>
                    ${formatCapturesForHistory(move)}
                    <span class="move-time">${formatClockForAnalysis(clockTime)}</span>
                </div>`;
            });
            
            // Single DOM update
            container.innerHTML = html;
            
            // Attach event delegation ONCE, not on every render
            if (!moveHistoryDelegationAttached) {
                container.addEventListener('click', function(e) {
                    const div = e.target.closest('.history-move');
                    if (div && div.dataset.moveIndex !== undefined) {
                        e.stopPropagation();
                        goToMove(parseInt(div.dataset.moveIndex, 10));
                    }
                });
                moveHistoryDelegationAttached = true;
            }
            
            // Scroll active move into view - use requestAnimationFrame and 'auto' behavior
            requestAnimationFrame(() => {
                const activeMove = container.querySelector('.history-move.active');
                if (activeMove) {
                    activeMove.scrollIntoView({ behavior: 'auto', block: 'nearest' });
                }
            });
        }
        
        function formatCapturesCompact(captures) {
            if (!captures || captures.length === 0) return '';
            
            // Separate shadows from golems
            const shadowCaptures = captures.filter(c => c.piece.type === 'shadow');
            const golemCaptures = captures.filter(c => c.piece.type !== 'shadow');
            
            let html = '<span class="capture-icons">×';
            
            // Show captured golems
            golemCaptures.forEach(c => {
                html += `<span style="color: ${getColorValue(c.piece.color)}">${c.piece.shape}</span>`;
            });
            
            // Show shadow count if any
            if (shadowCaptures.length > 0) {
                html += `<span class="shadow-capture">◌${shadowCaptures.length > 1 ? shadowCaptures.length : ''}</span>`;
            }
            
            html += '</span>';
            return html;
        }
        
        function formatCapturesForHistory(move) {
            if (!move.captures || move.captures.length === 0) return '';
            
            // Separate shadows from golems
            const shadowCaptures = move.captures.filter(c => c.piece.type === 'shadow');
            const golemCaptures = move.captures.filter(c => c.piece.type !== 'shadow');
            
            let html = '<span class="capture-display">×';
            
            // Show captured golems with their piece icons
            golemCaptures.forEach(c => {
                const opponentPlayer = move.player === 'dark' ? 'light' : 'dark';
                html += `<span class="piece-icon ${opponentPlayer}-piece captured-piece">
                    <span style="color: ${getColorValue(c.piece.color)}">${c.piece.shape}</span>
                </span>`;
            });
            
            // Show shadow count if any
            if (shadowCaptures.length > 0) {
                const opponentPlayer = move.player === 'dark' ? 'light' : 'dark';
                html += `<span class="shadow-capture-icon ${opponentPlayer}-shadow-icon">◌${shadowCaptures.length > 1 ? shadowCaptures.length : ''}</span>`;
            }
            
            html += '</span>';
            return html;
        }
        
        function getGlyphSymbol(glyph) {
            if (glyph.type === 'mirror') return '◇';
            if (glyph.type === 'shape') return glyph.value;
            if (glyph.type === 'color') {
                const colorSymbols = { white: '○', orange: '◐', blue: '●' };
                return colorSymbols[glyph.value] || glyph.value;
            }
            return '?';
        }
        
        function getGlyphHTML(glyph) {
            if (!glyph) return '?';
            if (glyph.type === 'mirror') {
                return '<span style="color: #c0c0c8;">◇</span>';
            }
            if (glyph.type === 'shape') {
                return `<span style="color: var(--pearl);">${glyph.value}</span>`;
            }
            if (glyph.type === 'color') {
                // Show a filled circle in the glyph's color
                return `<span style="color: ${getColorValue(glyph.value)};">●</span>`;
            }
            return '?';
        }
        
        function formatClockForAnalysis(seconds) {
            if (seconds === undefined || seconds === null) return '--:--';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const tenths = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${tenths}`;
        }
        
        function getMoveCoords(move) {
            const colLabels = 'abcdefgh';
            if (move.type === 'reactivation') {
                const pos = `${colLabels[move.position.col]}${8 - move.position.row}`;
                return `@${pos}`;
            }
            const from = `${colLabels[move.from.col]}${8 - move.from.row}`;
            const to = `${colLabels[move.to.col]}${8 - move.to.row}`;
            return `${from}→${to}`;
        }
        
        function formatMoveNotation(move) {
            const colLabels = 'abcdefgh';
            
            if (move.type === 'reactivation') {
                const pos = `${colLabels[move.position.col]}${8 - move.position.row}`;
                return `↑@${pos}`;
            }
            
            const from = `${colLabels[move.from.col]}${8 - move.from.row}`;
            const to = `${colLabels[move.to.col]}${8 - move.to.row}`;
            let notation = `${from}→${to}`;
            
            // Add shadow placed indicator
            if (move.shadowPlaced) {
                notation += ' +◌';
            }
            
            return notation;
        }
        
        let goToMoveTimeout = null;
        let lastGoToMoveIndex = null;
        let isNavigating = false;
        
        function goToMove(index) {
            // Clamp index
            index = Math.max(-1, Math.min(index, analysisData.moves.length - 1));
            
            // Skip if same index (but allow after arrow keys reset this)
            if (index === lastGoToMoveIndex) return;
            lastGoToMoveIndex = index;
            
            analysisData.currentMoveIndex = index;
            
            // If already navigating, just update the target index - the pending frame will use it
            if (isNavigating) {
                return;
            }
            
            isNavigating = true;
            
            // Debounce rapid clicks - cancel pending render and schedule new one
            if (goToMoveTimeout) {
                cancelAnimationFrame(goToMoveTimeout);
            }
            
            goToMoveTimeout = requestAnimationFrame(() => {
                // Use the latest index that was set
                const targetIndex = analysisData.currentMoveIndex;
                
                // Reconstruct game state at this point
                reconstructStateAtMove(targetIndex);
                
                // Update clock displays for analysis mode
                updateAnalysisClocks(targetIndex);
                
                // Update UI
                renderAnalysisRibbon();
                renderMoveHistory();
                renderGame();
                
                goToMoveTimeout = null;
                isNavigating = false;
            });
        }
        
        function updateAnalysisClocks(moveIndex) {
            const darkClock = document.getElementById('darkClock');
            const lightClock = document.getElementById('lightClock');
            
            // Check if the game had no time limit
            if (analysisData.initialState && analysisData.initialState.noTimeLimit) {
                darkClock.textContent = '∞';
                lightClock.textContent = '∞';
                darkClock.classList.remove('warning');
                lightClock.classList.remove('warning');
                return;
            }
            
            if (moveIndex < 0) {
                // At start position - show initial times
                darkClock.textContent = formatClockForAnalysis(analysisData.initialState?.darkTime);
                lightClock.textContent = formatClockForAnalysis(analysisData.initialState?.lightTime);
            } else {
                const move = analysisData.moves[moveIndex];
                if (move.darkClock !== undefined && move.lightClock !== undefined) {
                    darkClock.textContent = formatClockForAnalysis(move.darkClock);
                    lightClock.textContent = formatClockForAnalysis(move.lightClock);
                }
            }
            
            darkClock.classList.remove('warning');
            lightClock.classList.remove('warning');
        }
        
        function reconstructStateAtMove(targetIndex) {
            // Start from initial state
            const initial = analysisData.initialState;
            
            gameState.board = initial.board.map(row => row.map(cell => cell ? {...cell} : null));
            gameState.currentPlayer = initial.currentPlayer;
            gameState.darkHand = initial.darkHand.map(g => ({...g}));
            gameState.lightHand = initial.lightHand.map(g => ({...g}));
            gameState.darkResting = initial.darkResting ? {...initial.darkResting} : null;
            gameState.lightResting = initial.lightResting ? {...initial.lightResting} : null;
            gameState.darkSupply = {
                shadows: initial.darkSupply.shadows,
                masks: initial.darkSupply.masks.map(m => ({...m}))
            };
            gameState.lightSupply = {
                shadows: initial.lightSupply.shadows,
                masks: initial.lightSupply.masks.map(m => ({...m}))
            };
            gameState.lightHasPlacedShadow = initial.lightHasPlacedShadow;
            gameState.darkLives = initial.darkLives !== undefined ? initial.darkLives : 1;
            gameState.lightLives = initial.lightLives !== undefined ? initial.lightLives : 1;
            gameState.lastMove = null;
            
            // Replay moves up to target index
            for (let i = 0; i <= targetIndex; i++) {
                replayMove(analysisData.moves[i]);
            }
        }
        
        function replayMove(move) {
            const player = move.player;
            const hand = player === 'dark' ? gameState.darkHand : gameState.lightHand;
            const supply = player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
            
            if (move.type === 'movement') {
                // Move piece
                const piece = gameState.board[move.from.row][move.from.col];
                gameState.board[move.to.row][move.to.col] = piece;
                gameState.board[move.from.row][move.from.col] = null;
                
                gameState.lastMove = { 
                    fromRow: move.from.row, 
                    fromCol: move.from.col, 
                    toRow: move.to.row, 
                    toCol: move.to.col 
                };
                
                // Handle captures
                if (move.captures) {
                    for (const capture of move.captures) {
                        const capturedPiece = gameState.board[capture.position.row][capture.position.col];
                        gameState.board[capture.position.row][capture.position.col] = null;
                        
                        if (capturedPiece) {
                            const capturedSupply = capturedPiece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                            if (capturedPiece.type === 'shadow') {
                                capturedSupply.shadows++; // Return the captured shadow to supply
                            } else {
                                capturedSupply.shadows++;
                                capturedSupply.masks.push({ shape: capturedPiece.shape, color: capturedPiece.color });
                            }
                        }
                    }
                    
                    // Handle shadow cascade
                    const cascadePlayers = new Set(move.captures.filter(c => c.shadowCascade).map(c => c.piece.player));
                    for (const cascadePlayer of cascadePlayers) {
                        const cascadeSupply = cascadePlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 8; c++) {
                                const p = gameState.board[r][c];
                                if (p?.type === 'shadow' && p.player === cascadePlayer) {
                                    gameState.board[r][c] = null;
                                    cascadeSupply.shadows++;
                                }
                            }
                        }
                    }
                }
                
                // Place shadow
                if (move.shadowPlaced) {
                    gameState.board[move.shadowPlaced.row][move.shadowPlaced.col] = { type: 'shadow', player };
                    supply.shadows--;
                    if (player === 'light') {
                        gameState.lightHasPlacedShadow = true;
                    }
                }
                
                // Handle breakthrough (scoring)
                if (move.breakthrough && move.dismantled) {
                    // Remove golem from destination (it was dismantled)
                    gameState.board[move.to.row][move.to.col] = null;
                    // Add mask + shadow to scorer's supply
                    supply.masks.push({ shape: move.dismantled.shape, color: move.dismantled.color });
                    supply.shadows++;
                    // Decrement opponent's lives
                    const opponent = player === 'dark' ? 'light' : 'dark';
                    if (opponent === 'dark') {
                        gameState.darkLives--;
                    } else {
                        gameState.lightLives--;
                    }
                }
                
            } else if (move.type === 'reactivation') {
                // Place golem from mask
                gameState.board[move.position.row][move.position.col] = {
                    type: 'golem',
                    player,
                    shape: move.mask.shape,
                    color: move.mask.color
                };
                
                // Remove mask from supply
                const maskIndex = supply.masks.findIndex(m => 
                    m.shape === move.mask.shape && m.color === move.mask.color
                );
                if (maskIndex >= 0) {
                    supply.masks.splice(maskIndex, 1);
                }
                
                gameState.lastMove = { 
                    fromRow: move.position.row, 
                    fromCol: move.position.col, 
                    toRow: move.position.row, 
                    toCol: move.position.col 
                };
                
                // Handle captures from reactivation
                if (move.captures) {
                    for (const capture of move.captures) {
                        gameState.board[capture.position.row][capture.position.col] = null;
                    }
                }
            }
            
            // Handle glyph exchange
            const glyphIndex = hand.findIndex(g => 
                g.type === move.glyphUsed.type && g.value === move.glyphUsed.value
            );
            if (glyphIndex >= 0) {
                const usedGlyph = hand.splice(glyphIndex, 1)[0];
                
                // Pick up resting
                const resting = player === 'dark' ? gameState.darkResting : gameState.lightResting;
                if (resting) {
                    hand.push(resting);
                }
                
                // Set opponent's resting
                if (player === 'dark') {
                    gameState.lightResting = usedGlyph;
                    gameState.darkResting = null;
                    gameState.currentPlayer = 'light';
                } else {
                    gameState.darkResting = usedGlyph;
                    gameState.lightResting = null;
                    gameState.currentPlayer = 'dark';
                }
            }
        }
        
        // === EXPORT / IMPORT ===
        function exportGameJSON() {
            // Determine game result
            let result = 'unknown';
            let resultReason = '';
            if (gameState.gameOver) {
                const victoryMsg = document.getElementById('victoryMessage').textContent;
                if (victoryMsg.includes('Dark')) {
                    result = 'dark';
                } else if (victoryMsg.includes('Light')) {
                    result = 'light';
                } else if (victoryMsg.includes('Draw') || victoryMsg.includes('draw')) {
                    result = 'draw';
                }
                resultReason = victoryMsg;
            }
            
            // Build export object
            const exportData = {
                format: 'inara-game',
                version: '1.0',
                exportedAt: new Date().toISOString(),
                game: {
                    date: new Date().toISOString().split('T')[0],
                    timeControl: analysisData.initialState.noTimeLimit 
                        ? 'unlimited' 
                        : `${Math.floor(analysisData.initialState.darkTime / 60)}+${gameState.increment || 0}`,
                    result: result,
                    resultReason: resultReason,
                    totalMoves: analysisData.moves.length,
                    gameMode: spectateMode ? 'spectate' : (cpuMode ? 'cpu' : 'human'),
                    cpuPlayer: cpuMode ? (spectateMode ? 'both' : cpuPlayer) : null
                },
                initialState: analysisData.initialState,
                moves: analysisData.moves
            };
            
            // Create and trigger download
            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const dateStr = new Date().toISOString().slice(0, 10);
            const timeStr = new Date().toTimeString().slice(0, 5).replace(':', '');
            a.download = `inara-${dateStr}-${timeStr}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Security: Validate and sanitize loaded game data
        const VALID_SHAPES = ['Λ', 'Χ', 'Ω'];
        const VALID_COLORS = ['blue', 'orange', 'white'];
        const VALID_PLAYERS = ['dark', 'light'];
        const VALID_GLYPH_TYPES = ['shape', 'color', 'mirror'];
        const VALID_PIECE_TYPES = ['golem', 'shadow'];
        
        function validateGameData(data) {
            try {
                const state = data.initialState;
                
                // Validate board
                if (!Array.isArray(state.board) || state.board.length !== 8) return false;
                for (const row of state.board) {
                    if (!Array.isArray(row) || row.length !== 8) return false;
                    for (const cell of row) {
                        if (cell !== null && !validatePiece(cell)) return false;
                    }
                }
                
                // Validate current player
                if (!VALID_PLAYERS.includes(state.currentPlayer)) return false;
                
                // Validate hands
                if (!validateGlyphArray(state.darkHand)) return false;
                if (!validateGlyphArray(state.lightHand)) return false;
                
                // Validate resting glyphs
                if (state.darkResting !== null && !validateGlyph(state.darkResting)) return false;
                if (state.lightResting !== null && !validateGlyph(state.lightResting)) return false;
                
                // Validate supplies
                if (!validateSupply(state.darkSupply)) return false;
                if (!validateSupply(state.lightSupply)) return false;
                
                // Validate numeric fields
                if (state.darkTime !== undefined && typeof state.darkTime !== 'number') return false;
                if (state.lightTime !== undefined && typeof state.lightTime !== 'number') return false;
                if (state.darkLives !== undefined && !Number.isInteger(state.darkLives)) return false;
                if (state.lightLives !== undefined && !Number.isInteger(state.lightLives)) return false;
                if (state.moveTimer !== undefined && typeof state.moveTimer !== 'number') return false;
                
                // Validate boolean fields
                if (state.lightHasPlacedShadow !== undefined && typeof state.lightHasPlacedShadow !== 'boolean') return false;
                if (state.noTimeLimit !== undefined && typeof state.noTimeLimit !== 'boolean') return false;
                
                // Validate moves array
                if (!Array.isArray(data.moves)) return false;
                for (const move of data.moves) {
                    if (!validateMove(move)) return false;
                }
                
                return true;
            } catch (e) {
                console.error('Validation error:', e);
                return false;
            }
        }
        
        function validatePiece(piece) {
            if (typeof piece !== 'object') return false;
            if (!VALID_PIECE_TYPES.includes(piece.type)) return false;
            if (!VALID_PLAYERS.includes(piece.player)) return false;
            if (piece.type === 'golem') {
                if (!VALID_SHAPES.includes(piece.shape)) return false;
                if (!VALID_COLORS.includes(piece.color)) return false;
            }
            return true;
        }
        
        function validateGlyph(glyph) {
            if (typeof glyph !== 'object') return false;
            if (!VALID_GLYPH_TYPES.includes(glyph.type)) return false;
            if (glyph.type === 'shape' && !VALID_SHAPES.includes(glyph.value)) return false;
            if (glyph.type === 'color' && !VALID_COLORS.includes(glyph.value)) return false;
            if (glyph.type === 'mirror' && glyph.value !== '◇') return false;
            return true;
        }
        
        function validateGlyphArray(arr) {
            if (!Array.isArray(arr)) return false;
            for (const glyph of arr) {
                if (!validateGlyph(glyph)) return false;
            }
            return true;
        }
        
        function validateSupply(supply) {
            if (typeof supply !== 'object') return false;
            if (typeof supply.shadows !== 'number' || supply.shadows < 0) return false;
            if (!Array.isArray(supply.masks)) return false;
            for (const mask of supply.masks) {
                if (typeof mask !== 'object') return false;
                if (!VALID_SHAPES.includes(mask.shape)) return false;
                if (!VALID_COLORS.includes(mask.color)) return false;
            }
            return true;
        }
        
        function validateMove(move) {
            if (typeof move !== 'object') return false;
            if (move.type !== 'movement' && move.type !== 'reactivation') return false;
            
            // Validate coordinates are integers in range
            if (move.from) {
                if (!Number.isInteger(move.from.row) || move.from.row < 0 || move.from.row > 7) return false;
                if (!Number.isInteger(move.from.col) || move.from.col < 0 || move.from.col > 7) return false;
            }
            if (move.to) {
                if (!Number.isInteger(move.to.row) || move.to.row < 0 || move.to.row > 7) return false;
                if (!Number.isInteger(move.to.col) || move.to.col < 0 || move.to.col > 7) return false;
            }
            if (move.position) {
                if (!Number.isInteger(move.position.row) || move.position.row < 0 || move.position.row > 7) return false;
                if (!Number.isInteger(move.position.col) || move.position.col < 0 || move.position.col > 7) return false;
            }
            
            // Validate glyph used
            if (move.glyphUsed && !validateGlyph(move.glyphUsed)) return false;
            
            // Validate player
            if (move.player && !VALID_PLAYERS.includes(move.player)) return false;
            
            // Validate captures array
            if (move.captures && Array.isArray(move.captures)) {
                for (const cap of move.captures) {
                    // Captures have a position object containing row/col
                    if (!cap.position) return false;
                    if (!Number.isInteger(cap.position.row) || cap.position.row < 0 || cap.position.row > 7) return false;
                    if (!Number.isInteger(cap.position.col) || cap.position.col < 0 || cap.position.col > 7) return false;
                }
            }
            
            return true;
        }
        
        function importGameJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate format
                    if (data.format !== 'inara-game') {
                        alert('Invalid file format. Please select an Inara game file.');
                        return;
                    }
                    
                    if (!data.initialState || !data.moves) {
                        alert('Invalid game file. Missing required data.');
                        return;
                    }
                    
                    // Sanitize and validate game data
                    if (!validateGameData(data)) {
                        alert('Invalid game file. Data failed validation.');
                        return;
                    }
                    
                    // Stop any running game
                    if (gameState?.clockInterval) {
                        clearInterval(gameState.clockInterval);
                    }
                    
                    // Load the game data
                    analysisData.initialState = data.initialState;
                    analysisData.moves = data.moves;
                    analysisData.currentMoveIndex = data.moves.length - 1;
                    analysisData.isAnalysisMode = true;
                    
                    // Set game as over so clocks don't run
                    gameState = createInitialState();
                    gameState.gameOver = true;
                    
                    // Reset history stack
                    historyStack = [];
                    
                    // Hide new game modal if open
                    document.getElementById('newGameModal').classList.remove('show');
                    
                    // Show analysis UI
                    document.getElementById('analysisRibbon').classList.add('show');
                    document.getElementById('moveHistoryPanel').classList.add('show');
                    document.getElementById('saveLoadPanel').classList.add('show');
                    document.getElementById('board').classList.add('analysis-mode');
                    
                    // Show the filename
                    document.getElementById('analysisFilename').textContent = `📁 ${file.name}`;
                    
                    // Reconstruct final position
                    reconstructStateAtMove(analysisData.currentMoveIndex);
                    updateAnalysisClocks(analysisData.currentMoveIndex);
                    
                    renderAnalysisRibbon();
                    renderMoveHistory();
                    renderGame();
                    
                    // Show game info
                    const info = data.game;
                    console.log(`Loaded: ${info.date} | ${info.timeControl} | ${info.totalMoves} moves | Result: ${info.result}`);
                    
                } catch (err) {
                    console.error('Import error:', err);
                    alert('Failed to load game file. The file may be corrupted.');
                }
            };
            
            reader.readAsText(file);
            
            // Reset input so same file can be loaded again
            event.target.value = '';
        }
        
        // Keyboard navigation for analysis
        document.addEventListener('keydown', (e) => {
            if (!analysisData.isAnalysisMode) return;
            
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                lastGoToMoveIndex = null; // Allow navigation even to same index after arrow keys
                goToMove(analysisData.currentMoveIndex - 1);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                lastGoToMoveIndex = null;
                goToMove(analysisData.currentMoveIndex + 1);
            } else if (e.key === 'Home') {
                e.preventDefault();
                lastGoToMoveIndex = null;
                goToMove(-1);
            } else if (e.key === 'End') {
                e.preventDefault();
                lastGoToMoveIndex = null;
                goToMove(analysisData.moves.length - 1);
            }
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('menuDropdown');
            const btn = document.getElementById('menuBtn');
            if (!menu.contains(e.target) && !btn.contains(e.target)) {
                closeMenu();
            }
        });

        // Close modals on background click
        document.getElementById('rulesModal').addEventListener('click', (e) => {
            if (e.target.id === 'rulesModal') toggleRules();
        });
        
        document.getElementById('aboutModal').addEventListener('click', (e) => {
            if (e.target.id === 'aboutModal') closeAbout();
        });

        document.getElementById('tutorialModal').addEventListener('click', (e) => {
            if (e.target.id === 'tutorialModal') closeTutorial();
        });

        document.getElementById('victoryModal').addEventListener('click', (e) => {
            if (e.target.id === 'victoryModal') {
                document.getElementById('victoryModal').classList.remove('show');
            }
        });

        document.getElementById('resignModal').addEventListener('click', (e) => {
            if (e.target.id === 'resignModal') {
                cancelResign();
            }
        });

        document.getElementById('drawOfferModal').addEventListener('click', (e) => {
            if (e.target.id === 'drawOfferModal') {
                declineDraw();
            }
        });

        document.getElementById('newGameModal').addEventListener('click', (e) => {
            if (e.target.id === 'newGameModal') {
                document.getElementById('newGameModal').classList.remove('show');
            }
        });

        // Try to lock screen orientation to portrait on mobile
        if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('portrait').catch(() => {
                // Orientation lock not supported or denied - that's okay
            });
        }
        
        // Handle page visibility changes - reconnect peer if needed
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && peer && !peer.destroyed && peer.disconnected) {
                console.log('Page visible again, reconnecting peer...');
                peer.reconnect();
            }
        });

        // Fix zoom issues on orientation change
        window.addEventListener('orientationchange', () => {
            // Reset any zoom by forcing viewport recalculation
            const viewport = document.querySelector('meta[name="viewport"]');
            viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
            
            // Force layout recalculation
            setTimeout(() => {
                window.scrollTo(0, 0);
                document.body.style.display = 'none';
                document.body.offsetHeight; // Force reflow
                document.body.style.display = '';
            }, 100);
        });

        // Initialize on load - render board, menu accessible
        // User can access menu, tutorial, rules before starting a game
        initGame();
        loadLanguagePreference();
        
        // PeerJS configuration - must be defined before any peer creation
        const peerConfig = {
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ]
            },
            debug: 1 // 0 = no logs, 1 = errors, 2 = warnings, 3 = all
        };
        
        // Check for room code in URL and auto-join
        (function checkUrlForRoom() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');
            
            if (roomCode) {
                // Close welcome modal if open
                closeWelcome();
                
                // Set a default guest name for auto-join
                localPlayerName = 'GUEST';
                
                // Open online modal and auto-join
                const modal = document.getElementById('onlineModal');
                modal.classList.add('show');
                showOnlineJoining();
                
                // Clear the URL parameter so refresh doesn't re-join
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Initialize peer, then auto-join
                peer = new Peer(peerConfig);
                
                // Set a timeout for the whole process
                const joinTimeout = setTimeout(() => {
                    console.log('Auto-join timeout');
                    showOnlineError('Could not connect to game. The host may have left.');
                }, 20000); // 20 second timeout
                
                peer.on('open', () => {
                    console.log('Connected to PeerJS, auto-joining room:', roomCode);
                    
                    isHost = false;
                    localPlayer = null;
                    
                    conn = peer.connect('inara-' + roomCode, { reliable: true });
                    
                    conn.on('open', () => {
                        clearTimeout(joinTimeout);
                        console.log('Connected to host!');
                        setupConnectionHandlers();
                        sendOnlineMessage({ type: 'requestGameState', playerName: localPlayerName });
                    });
                    
                    conn.on('error', (err) => {
                        clearTimeout(joinTimeout);
                        console.error('Connection error:', err);
                        showOnlineError('Could not connect to game. Check the link and try again.');
                    });
                });
                
                peer.on('error', (err) => {
                    clearTimeout(joinTimeout);
                    console.error('PeerJS error:', err);
                    if (err.type === 'peer-unavailable') {
                        showOnlineError('Game not found. The host may have left or the link is invalid.');
                    } else {
                        showOnlineError('Could not connect to server. Please try again.');
                    }
                });
            }
        })();

        // === ONLINE GAME BACKUP (for disconnect recovery) ===
        const ONLINE_BACKUP_KEY = 'inara-online-backup';
        
        function saveOnlineGameBackup() {
            try {
                const backup = {
                    format: 'inara-game',
                    version: 1,
                    timestamp: Date.now(),
                    localPlayer: localPlayer,
                    localPlayerName: localPlayerName,
                    remotePlayerName: remotePlayerName,
                    initialState: analysisData.initialState,
                    moves: analysisData.moves,
                    game: {
                        date: new Date().toISOString().split('T')[0],
                        totalMoves: analysisData.moves.length
                    }
                };
                localStorage.setItem(ONLINE_BACKUP_KEY, JSON.stringify(backup));
            } catch (e) {
                console.warn('Could not save online game backup:', e);
            }
        }
        
        function getOnlineGameBackup() {
            try {
                const data = localStorage.getItem(ONLINE_BACKUP_KEY);
                if (!data) return null;
                
                const backup = JSON.parse(data);
                
                // Validate it's a proper backup
                if (backup.format !== 'inara-game' || !backup.initialState || !backup.moves) {
                    return null;
                }
                
                // Validate the data
                if (!validateGameData(backup)) {
                    clearOnlineGameBackup();
                    return null;
                }
                
                return backup;
            } catch (e) {
                console.warn('Could not load online game backup:', e);
                return null;
            }
        }
        
        function clearOnlineGameBackup() {
            try {
                localStorage.removeItem(ONLINE_BACKUP_KEY);
            } catch (e) {
                console.warn('Could not clear online game backup:', e);
            }
        }
        
        function hasOnlineGameBackup() {
            return getOnlineGameBackup() !== null;
        }

        // === ONLINE MULTIPLAYER FUNCTIONS ===
        
        function generateRoomCode() {
            const adjectives = [
                'red', 'blue', 'green', 'gold', 'silver', 'bronze', 'iron', 'copper',
                'swift', 'bold', 'calm', 'dark', 'light', 'wild', 'wise', 'keen',
                'north', 'south', 'east', 'west', 'high', 'deep', 'old', 'new',
                'fire', 'ice', 'storm', 'sun', 'moon', 'star', 'wind', 'stone'
            ];
            const nouns = [
                'wolf', 'hawk', 'bear', 'lion', 'tiger', 'eagle', 'raven', 'fox',
                'peak', 'vale', 'grove', 'lake', 'river', 'ocean', 'forest', 'desert',
                'knight', 'queen', 'king', 'bishop', 'rook', 'pawn', 'tower', 'castle',
                'golem', 'shadow', 'glyph', 'moon', 'sand', 'mirror', 'mask', 'flame'
            ];
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            const num = Math.floor(Math.random() * 100);
            return `${adj}-${noun}-${num}`;
        }
        
        function openOnlineModal() {
            const modal = document.getElementById('onlineModal');
            modal.classList.add('show');
            
            // Reset state
            showOnlineStatus('Connecting to server...');
            
            // Initialize PeerJS
            initializePeer();
        }
        
        function closeOnlineModal() {
            document.getElementById('onlineModal').classList.remove('show');
            
            // Clean up peer connection if exists
            if (conn) {
                conn.close();
                conn = null;
            }
            if (peer) {
                peer.destroy();
                peer = null;
            }
            
            onlineMode = false;
            localPlayer = null;
            isHost = false;
            
            // Return to New Game modal
            showNewGameModal();
        }
        
        function showOnlineStatus(msg) {
            document.getElementById('onlineStatus').innerHTML = `<span style="color: var(--silver);">${msg}</span>`;
            document.getElementById('onlineStatus').style.display = 'block';
            document.getElementById('onlineOptions').style.display = 'none';
            document.getElementById('onlineWaiting').style.display = 'none';
            document.getElementById('onlineJoining').style.display = 'none';
            document.getElementById('onlineError').style.display = 'none';
        }
        
        function showOnlineOptions() {
            document.getElementById('onlineStatus').style.display = 'none';
            document.getElementById('onlineOptions').style.display = 'block';
            document.getElementById('onlineWaiting').style.display = 'none';
            document.getElementById('onlineJoining').style.display = 'none';
            document.getElementById('onlineError').style.display = 'none';
            
            // Check for saved game backup
            const backup = getOnlineGameBackup();
            const banner = document.getElementById('onlineBackupBanner');
            if (backup) {
                banner.style.display = 'block';
                // Pre-fill names if available
                if (backup.localPlayerName) {
                    document.getElementById('playerNameInput').value = backup.localPlayerName;
                }
                if (backup.remotePlayerName) {
                    document.getElementById('opponentNameInput').value = backup.remotePlayerName;
                }
                // Set side to what they were playing
                if (backup.localPlayer) {
                    setHostSide(backup.localPlayer);
                    return; // Don't reset to random
                }
            } else {
                banner.style.display = 'none';
            }
            
            // Reset side selection to default
            setHostSide('random');
        }
        
        function setHostSide(side) {
            selectedHostSide = side;
            
            document.getElementById('hostDarkBtn').style.background = side === 'dark' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('hostDarkBtn').style.color = side === 'dark' ? '' : 'var(--pearl)';
            document.getElementById('hostRandomBtn').style.background = side === 'random' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('hostRandomBtn').style.color = side === 'random' ? '' : 'var(--pearl)';
            document.getElementById('hostLightBtn').style.background = side === 'light' ? 'var(--gold)' : 'var(--slate)';
            document.getElementById('hostLightBtn').style.color = side === 'light' ? '' : 'var(--pearl)';
        }
        
        let selectedOnlineLives = 0; // Default sudden death for online
        let selectedMoveTimer = 0; // 0 = no limit, otherwise seconds per move
        const moveTimerValues = [0, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60]; // Slider positions
        
        function setOnlineLives(lives) {
            selectedOnlineLives = lives;
            
            [1, 2, 3].forEach(n => {
                const btn = document.getElementById(`onlineLives${n}Btn`);
                btn.style.background = lives === n ? 'var(--gold)' : 'var(--slate)';
                btn.style.color = lives === n ? '' : 'var(--pearl)';
            });
            
            // Sudden Death button (0 lives)
            const sdBtn = document.getElementById('onlineLives0Btn');
            sdBtn.style.background = lives === 0 ? 'var(--gold)' : 'var(--slate)';
            sdBtn.style.color = lives === 0 ? '' : 'var(--pearl)';
        }
        
        function updateMoveTimerDisplay() {
            const slider = document.getElementById('moveTimerSlider');
            const display = document.getElementById('moveTimerDisplay');
            const index = parseInt(slider.value);
            selectedMoveTimer = moveTimerValues[index];
            
            if (selectedMoveTimer === 0) {
                display.textContent = '∞';
            } else {
                display.textContent = selectedMoveTimer + 's';
            }
        }
        
        function showMoveTimerHelp() {
            alert('Online games use a per-move timer instead of a total game clock. Each player\'s timer resets at the start of their turn, so no synchronization between devices is needed.');
        }
        
        function showOnlineWaiting(code) {
            document.getElementById('onlineStatus').style.display = 'none';
            document.getElementById('onlineOptions').style.display = 'none';
            document.getElementById('onlineWaiting').style.display = 'block';
            document.getElementById('onlineJoining').style.display = 'none';
            document.getElementById('onlineError').style.display = 'none';
            document.getElementById('roomCode').textContent = code;
            
            // Generate shareable link
            const link = `${window.location.origin}${window.location.pathname}?room=${code}`;
            document.getElementById('roomLink').textContent = link;
        }
        
        function showOnlineJoining() {
            document.getElementById('onlineStatus').style.display = 'none';
            document.getElementById('onlineOptions').style.display = 'none';
            document.getElementById('onlineWaiting').style.display = 'none';
            document.getElementById('onlineJoining').style.display = 'block';
            document.getElementById('onlineError').style.display = 'none';
        }
        
        function showOnlineError(msg) {
            document.getElementById('onlineStatus').style.display = 'none';
            document.getElementById('onlineOptions').style.display = 'none';
            document.getElementById('onlineWaiting').style.display = 'none';
            document.getElementById('onlineJoining').style.display = 'none';
            document.getElementById('onlineError').style.display = 'block';
            document.getElementById('onlineErrorMsg').textContent = msg;
        }
        
        function copyRoomCode() {
            const code = document.getElementById('roomCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                const el = document.getElementById('roomCode');
                const original = el.textContent;
                el.textContent = 'Copied!';
                setTimeout(() => el.textContent = original, 1000);
            });
        }
        
        function copyRoomLink() {
            const link = document.getElementById('roomLink').textContent;
            navigator.clipboard.writeText(link).then(() => {
                const el = document.getElementById('roomLink');
                const original = el.textContent;
                el.textContent = 'Copied!';
                setTimeout(() => el.textContent = original, 1000);
            });
        }
        
        function initializePeer() {
            // Create peer with random ID and explicit config
            peer = new Peer(peerConfig);
            
            peer.on('open', (id) => {
                console.log('Connected to PeerJS server with ID:', id);
                showOnlineOptions();
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                if (err.type === 'peer-unavailable') {
                    showOnlineError('Game not found. Check the code and try again.');
                } else if (err.type === 'network' || err.type === 'server-error') {
                    showOnlineError('Could not connect to server. Please try again.');
                } else {
                    showOnlineError('Connection error: ' + err.type);
                }
            });
            
            // Listen for incoming connections (for host)
            peer.on('connection', handleIncomingConnection);
        }
        
        function retryOnlineConnection() {
            if (peer) {
                peer.destroy();
                peer = null;
            }
            showOnlineStatus('Connecting to server...');
            initializePeer();
        }
        
        function createOnlineGame() {
            // Get player names
            const nameInput = document.getElementById('playerNameInput');
            const opponentInput = document.getElementById('opponentNameInput');
            localPlayerName = nameInput.value.trim().toUpperCase().slice(0, 5) || 'HOST';
            remotePlayerName = opponentInput.value.trim().toUpperCase().slice(0, 5) || 'GUEST';
            
            isHost = true;
            
            // Determine host's side
            if (selectedHostSide === 'random') {
                localPlayer = Math.random() < 0.5 ? 'dark' : 'light';
            } else {
                localPlayer = selectedHostSide;
            }
            
            const roomCode = generateRoomCode();
            
            // Destroy old peer and create new one with the room code as ID
            if (peer) {
                peer.destroy();
            }
            
            peer = new Peer('inara-' + roomCode, peerConfig);
            
            peer.on('open', () => {
                console.log('Room created:', roomCode);
                showOnlineWaiting(roomCode);
            });
            
            peer.on('disconnected', () => {
                console.log('Disconnected from signaling server, attempting to reconnect...');
                // Attempt to reconnect to the signaling server
                if (peer && !peer.destroyed) {
                    peer.reconnect();
                }
            });
            
            peer.on('error', (err) => {
                console.error('Error creating room:', err);
                if (err.type === 'unavailable-id') {
                    // Room code already taken, try another
                    createOnlineGame();
                } else if (err.type === 'disconnected' || err.type === 'network') {
                    // Network issue, try to reconnect
                    if (peer && !peer.destroyed) {
                        peer.reconnect();
                    }
                } else {
                    showOnlineError('Could not create game. Please try again.');
                }
            });
            
            peer.on('connection', handleIncomingConnection);
        }
        
        let loadedGameForOnline = null; // Holds loaded game state for online resume
        
        function loadOnlineGameFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate format
                    if (data.format !== 'inara-game') {
                        alert('Invalid file format. Please select an Inara game file.');
                        return;
                    }
                    
                    if (!data.initialState || !data.moves) {
                        alert('Invalid game file. Missing required data.');
                        return;
                    }
                    
                    // Sanitize and validate game data
                    if (!validateGameData(data)) {
                        alert('Invalid game file. Data failed validation.');
                        return;
                    }
                    
                    // Store the loaded data
                    loadedGameForOnline = data;
                    
                    // Create online game with loaded state
                    createOnlineGameWithLoadedState();
                    
                } catch (err) {
                    console.error('Load error:', err);
                    alert('Failed to load game file. The file may be corrupted.');
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }
        
        function createOnlineGameWithLoadedState() {
            if (!loadedGameForOnline) return;
            
            isHost = true;
            
            // Determine host's side from selection
            if (selectedHostSide === 'random') {
                localPlayer = Math.random() < 0.5 ? 'dark' : 'light';
            } else {
                localPlayer = selectedHostSide;
            }
            
            const roomCode = generateRoomCode();
            
            if (peer) {
                peer.destroy();
            }
            
            peer = new Peer('inara-' + roomCode, peerConfig);
            
            peer.on('open', () => {
                console.log('Room created with loaded game:', roomCode);
                showOnlineWaiting(roomCode);
            });
            
            peer.on('disconnected', () => {
                if (peer && !peer.destroyed) {
                    peer.reconnect();
                }
            });
            
            peer.on('error', (err) => {
                console.error('Error creating room:', err);
                if (err.type === 'unavailable-id') {
                    createOnlineGameWithLoadedState();
                } else {
                    showOnlineError('Could not create game. Please try again.');
                }
            });
            
            peer.on('connection', handleIncomingConnectionWithLoadedGame);
        }
        
        function handleIncomingConnectionWithLoadedGame(connection) {
            console.log('Opponent connected! Starting with loaded game.');
            conn = connection;
            setupConnectionHandlers();
            
            // Start online game with loaded state
            startOnlineGameWithLoadedState();
        }
        
        function startOnlineGameWithLoadedState() {
            if (!loadedGameForOnline) return;
            
            document.getElementById('onlineModal').classList.remove('show');
            
            onlineMode = true;
            cpuMode = false;
            spectateMode = false;
            
            // Reconstruct the final position from the loaded game
            const data = loadedGameForOnline;
            
            // Start with initial state
            gameState = createInitialState();
            
            // Apply initial state
            const init = data.initialState;
            gameState.board = init.board.map(row => row.map(cell => cell ? {...cell} : null));
            gameState.currentPlayer = init.currentPlayer;
            gameState.darkHand = init.darkHand.map(g => ({...g}));
            gameState.lightHand = init.lightHand.map(g => ({...g}));
            gameState.darkResting = init.darkResting ? {...init.darkResting} : null;
            gameState.lightResting = init.lightResting ? {...init.lightResting} : null;
            gameState.darkSupply = {
                shadows: init.darkSupply.shadows,
                masks: init.darkSupply.masks.map(m => ({...m}))
            };
            gameState.lightSupply = {
                shadows: init.lightSupply.shadows,
                masks: init.lightSupply.masks.map(m => ({...m}))
            };
            gameState.lightHasPlacedShadow = init.lightHasPlacedShadow;
            gameState.darkLives = init.darkLives || 1;
            gameState.lightLives = init.lightLives || 1;
            gameState.noTimeLimit = true; // Online uses move timer instead
            
            // Replay all moves to get to final position
            for (const moveData of data.moves) {
                replayMoveOnState(moveData);
            }
            
            // Set move timer from current selection
            gameState.moveTimer = selectedMoveTimer;
            gameState.moveTimeRemaining = selectedMoveTimer;
            
            // Setup analysis data - preserve original initial state and move history
            analysisData = {
                initialState: JSON.parse(JSON.stringify(data.initialState)),
                moves: data.moves.map(m => JSON.parse(JSON.stringify(m))),
                currentMoveIndex: data.moves.length - 1,
                isAnalysisMode: false
            };
            
            // Send state to opponent (include move history for their analysis)
            const joinerSide = localPlayer === 'dark' ? 'light' : 'dark';
            sendOnlineMessage({
                type: 'gameStart',
                state: serializeGameState(),
                yourSide: joinerSide,
                hostName: localPlayerName,
                joinerName: remotePlayerName,
                hostSide: localPlayer,
                moveTimer: selectedMoveTimer,
                resumedGame: true,
                moveNumber: data.moves.length,
                initialState: data.initialState,
                moveHistory: data.moves
            });
            
            updatePlayerNames();
            setBoardFlip(localPlayer === 'light');
            renderGame();
            
            // Start move timer if applicable
            if (selectedMoveTimer > 0) {
                resetMoveTimer();
            }
            
            // Clear loaded game
            loadedGameForOnline = null;
            
            // Notify host
            const moveNum = data.moves.length;
            console.log(`Resumed game at move ${moveNum}. ${gameState.currentPlayer}'s turn.`);
        }
        
        function replayMoveOnState(moveData) {
            // Simplified replay that applies move to current gameState
            if (moveData.type === 'movement') {
                const piece = gameState.board[moveData.from.row][moveData.from.col];
                if (!piece) return;
                
                // Move piece
                gameState.board[moveData.to.row][moveData.to.col] = piece;
                gameState.board[moveData.from.row][moveData.from.col] = null;
                
                // Place shadow if indicated
                if (moveData.shadowPlaced) {
                    gameState.board[moveData.shadowPlaced.row][moveData.shadowPlaced.col] = {
                        type: 'shadow',
                        player: piece.player
                    };
                    const supply = piece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                    supply.shadows--;
                }
                
                // Handle captures
                if (moveData.captures) {
                    for (const cap of moveData.captures) {
                        const captured = gameState.board[cap.row][cap.col];
                        if (captured) {
                            gameState.board[cap.row][cap.col] = null;
                            // Return resources to owner
                            const ownerSupply = captured.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                            if (captured.type === 'shadow') {
                                ownerSupply.shadows++;
                            } else if (captured.type === 'golem') {
                                ownerSupply.shadows++;
                                ownerSupply.masks.push({ shape: captured.shape, color: captured.color });
                            }
                        }
                    }
                }
                
                // Handle breakthrough/dismantling
                if (moveData.breakthrough && moveData.dismantled) {
                    gameState.board[moveData.to.row][moveData.to.col] = null;
                    const supply = piece.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                    supply.shadows++;
                    supply.masks.push({ shape: moveData.dismantled.shape, color: moveData.dismantled.color });
                    
                    // Reduce opponent lives
                    if (piece.player === 'dark') {
                        gameState.lightLives--;
                    } else {
                        gameState.darkLives--;
                    }
                }
                
                // Handle glyph exchange
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const glyphIndex = hand.findIndex(g => 
                    g.type === moveData.glyphUsed.type && g.value === moveData.glyphUsed.value
                );
                if (glyphIndex !== -1) {
                    const usedGlyph = hand.splice(glyphIndex, 1)[0];
                    const resting = gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
                    if (resting) hand.push(resting);
                    
                    if (gameState.currentPlayer === 'dark') {
                        gameState.lightResting = usedGlyph;
                        gameState.darkResting = null;
                    } else {
                        gameState.darkResting = usedGlyph;
                        gameState.lightResting = null;
                    }
                }
                
                // Track shadow placement for lock
                if (moveData.shadowPlaced && piece.player === 'light') {
                    gameState.lightHasPlacedShadow = true;
                }
                
            } else if (moveData.type === 'reactivation') {
                // Handle reactivation - places golem on existing shadow, consumes mask
                const supply = gameState.currentPlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                const maskIndex = supply.masks.findIndex(m => 
                    m.shape === moveData.mask.shape && m.color === moveData.mask.color
                );
                if (maskIndex !== -1) {
                    const mask = supply.masks.splice(maskIndex, 1)[0];
                    // Note: shadow is already on board, we just replace it with golem
                    // No shadow counter change needed
                    gameState.board[moveData.position.row][moveData.position.col] = {
                        type: 'golem',
                        player: gameState.currentPlayer,
                        shape: mask.shape,
                        color: mask.color
                    };
                }
                
                // Handle captures from reactivation
                if (moveData.captures) {
                    for (const cap of moveData.captures) {
                        const captured = gameState.board[cap.row][cap.col];
                        if (captured) {
                            gameState.board[cap.row][cap.col] = null;
                            const ownerSupply = captured.player === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                            if (captured.type === 'shadow') {
                                ownerSupply.shadows++;
                            } else if (captured.type === 'golem') {
                                ownerSupply.shadows++;
                                ownerSupply.masks.push({ shape: captured.shape, color: captured.color });
                            }
                        }
                    }
                }
                
                // Handle glyph exchange for reactivation
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const glyphIndex = hand.findIndex(g => 
                    g.type === moveData.glyphUsed.type && g.value === moveData.glyphUsed.value
                );
                if (glyphIndex !== -1) {
                    const usedGlyph = hand.splice(glyphIndex, 1)[0];
                    const resting = gameState.currentPlayer === 'dark' ? gameState.darkResting : gameState.lightResting;
                    if (resting) hand.push(resting);
                    
                    if (gameState.currentPlayer === 'dark') {
                        gameState.lightResting = usedGlyph;
                        gameState.darkResting = null;
                    } else {
                        gameState.darkResting = usedGlyph;
                        gameState.lightResting = null;
                    }
                }
            }
            
            // Switch player
            gameState.currentPlayer = gameState.currentPlayer === 'dark' ? 'light' : 'dark';
        }
        
        function handleIncomingConnection(connection) {
            console.log('Opponent connected!');
            conn = connection;
            setupConnectionHandlers();
            
            // Host starts the game and sends initial state
            startOnlineGame();
        }
        
        function joinOnlineGame() {
            const codeInput = document.getElementById('joinCodeInput');
            const code = codeInput.value.trim().toLowerCase();
            
            // Basic validation - should be like "word-word-number"
            if (!code || !code.includes('-')) {
                showOnlineError('Please enter a room code (e.g. blue-tiger-42)');
                return;
            }
            
            // Get player name
            const nameInput = document.getElementById('playerNameInput');
            localPlayerName = nameInput.value.trim().toUpperCase().slice(0, 5) || 'GUEST';
            
            isHost = false;
            localPlayer = null; // Will be assigned by host
            
            showOnlineJoining();
            
            // Ensure peer is ready before connecting
            if (!peer || peer.destroyed) {
                peer = new Peer(peerConfig);
                peer.on('open', () => {
                    connectToHost(code);
                });
                peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    if (err.type === 'peer-unavailable') {
                        showOnlineError('Game not found. Check the code and try again.');
                    } else {
                        showOnlineError('Could not connect to server. Please try again.');
                    }
                });
            } else if (!peer.open) {
                // Peer exists but not yet open, wait for it
                peer.on('open', () => {
                    connectToHost(code);
                });
            } else {
                // Peer is ready, connect immediately
                connectToHost(code);
            }
        }
        
        function connectToHost(code) {
            console.log('Attempting to connect to host:', code);
            
            // Set a timeout for connection
            const connectionTimeout = setTimeout(() => {
                if (!conn || !conn.open) {
                    console.log('Connection timeout');
                    showOnlineError('Could not connect to game. The host may have left.');
                    if (conn) {
                        conn.close();
                        conn = null;
                    }
                }
            }, 15000); // 15 second timeout
            
            // Connect to the host
            conn = peer.connect('inara-' + code, { reliable: true });
            
            conn.on('open', () => {
                clearTimeout(connectionTimeout);
                console.log('Connected to host!');
                setupConnectionHandlers();
                
                // Request game state from host, include our name
                sendOnlineMessage({ type: 'requestGameState', playerName: localPlayerName });
            });
            
            conn.on('error', (err) => {
                clearTimeout(connectionTimeout);
                console.error('Connection error:', err);
                showOnlineError('Could not connect to game. Check the code and try again.');
            });
        }
        
        function setupConnectionHandlers() {
            conn.on('data', (data) => {
                console.log('Received:', data.type);
                handleOnlineMessage(data);
            });
            
            conn.on('close', () => {
                console.log('Connection closed');
                if (onlineMode && !gameState.gameOver) {
                    showDisconnectModal();
                    onlineMode = false;
                }
            });
            
            conn.on('error', (err) => {
                console.error('Connection error:', err);
            });
        }
        
        function startOnlineGame() {
            // Close modal
            document.getElementById('onlineModal').classList.remove('show');
            
            // Set online mode
            onlineMode = true;
            cpuMode = false;
            spectateMode = false;
            
            if (isHost) {
                // Set lives from online selection
                selectedLives = selectedOnlineLives;
                
                // Force untimed for online games (total time)
                selectedTime = 0;
                
                // Host initializes the game
                initGame();
                
                // Set move timer after init
                gameState.moveTimer = selectedMoveTimer;
                gameState.moveTimeRemaining = selectedMoveTimer;
                
                // Start move timer if applicable
                if (selectedMoveTimer > 0) {
                    startMoveTimer();
                }
                
                // Send initial state to opponent with their side assignment
                const joinerSide = localPlayer === 'dark' ? 'light' : 'dark';
                sendOnlineMessage({
                    type: 'gameStart',
                    state: serializeGameState(),
                    yourSide: joinerSide,
                    hostName: localPlayerName,
                    joinerName: remotePlayerName,
                    hostSide: localPlayer,
                    moveTimer: selectedMoveTimer
                });
                
                // Flip board if host is playing light
                setBoardFlip(localPlayer === 'light');
            }
        }
        
        function sendOnlineMessage(data) {
            if (conn && conn.open) {
                conn.send(data);
            }
        }
        
        function updatePlayerNames() {
            if (!onlineMode) return;
            
            // Determine which name goes to which side
            let darkName, lightName;
            
            if (localPlayer === 'dark') {
                darkName = localPlayerName;
                lightName = remotePlayerName || 'Light';
            } else {
                darkName = remotePlayerName || 'Dark';
                lightName = localPlayerName;
            }
            
            document.getElementById('darkPlayerName').textContent = darkName;
            document.getElementById('lightPlayerName').textContent = lightName;
        }
        
        function handleOnlineMessage(data) {
            switch (data.type) {
                case 'requestGameState':
                    // Joiner is asking for game state - send it
                    if (isHost && onlineMode) {
                        console.log('Sending game state to joiner');
                        const joinerSide = localPlayer === 'dark' ? 'light' : 'dark';
                        
                        sendOnlineMessage({
                            type: 'gameStart',
                            state: serializeGameState(),
                            yourSide: joinerSide,
                            hostName: localPlayerName,
                            joinerName: remotePlayerName, // Name host set for the joiner
                            hostSide: localPlayer
                        });
                        
                        // Update panel labels with names
                        updatePlayerNames();
                    }
                    break;
                    
                case 'gameStart':
                    // Received initial game state from host
                    document.getElementById('onlineModal').classList.remove('show');
                    onlineMode = true;
                    cpuMode = false;
                    spectateMode = false;
                    
                    // Set our side as assigned by host
                    localPlayer = data.yourSide;
                    
                    // Use names set by host
                    if (data.hostName) {
                        remotePlayerName = data.hostName;
                    }
                    if (data.joinerName) {
                        localPlayerName = data.joinerName; // Host set our name
                    }
                    
                    // Load the game state (pass full data for move history)
                    loadOnlineGameState(data);
                    
                    // Update panel labels with names
                    updatePlayerNames();
                    
                    // Flip board if we're playing light
                    setBoardFlip(localPlayer === 'light');
                    break;
                    
                case 'move':
                    // Received opponent's move
                    applyOnlineMove(data.move);
                    break;
                    
                case 'resign':
                    // Opponent resigned
                    endGame(localPlayer, `${capitalize(data.player)} resigned. ${capitalize(localPlayer)} wins!`);
                    break;
                    
                case 'drawOffer':
                    // Opponent offered a draw
                    showDrawOfferFromOpponent();
                    break;
                    
                case 'drawAccept':
                    // Opponent accepted our draw offer
                    endGame('draw', 'Game drawn by agreement!');
                    break;
                    
                case 'drawDecline':
                    // Opponent declined our draw offer
                    // Just close the modal, game continues
                    break;
                    
                case 'timeout':
                    // Opponent ran out of time
                    const winner = data.loser === 'dark' ? 'light' : 'dark';
                    const loserName = data.loser === 'dark' ? 'Dark' : 'Light';
                    endGame(winner, `${loserName} ran out of time!`);
                    break;
            }
        }
        
        function loadOnlineGameState(data) {
            const state = data.state;
            
            // Initialize fresh game state
            gameState = createInitialState();
            
            // Copy the state from host
            gameState.board = state.board.map(row => row.map(cell => cell ? {...cell} : null));
            gameState.currentPlayer = state.currentPlayer;
            gameState.darkHand = state.darkHand.map(g => ({...g}));
            gameState.lightHand = state.lightHand.map(g => ({...g}));
            gameState.darkResting = state.darkResting ? {...state.darkResting} : null;
            gameState.lightResting = state.lightResting ? {...state.lightResting} : null;
            gameState.darkSupply = {
                shadows: state.darkSupply.shadows,
                masks: state.darkSupply.masks.map(m => ({...m}))
            };
            gameState.lightSupply = {
                shadows: state.lightSupply.shadows,
                masks: state.lightSupply.masks.map(m => ({...m}))
            };
            gameState.lightHasPlacedShadow = state.lightHasPlacedShadow;
            
            // Copy lives
            gameState.darkLives = state.darkLives || 1;
            gameState.lightLives = state.lightLives || 1;
            
            // Copy move timer
            gameState.moveTimer = state.moveTimer || 0;
            gameState.moveTimeRemaining = state.moveTimer || 0;
            
            // Analysis data for replay - use history if this is a resumed game
            if (data.initialState && data.moveHistory) {
                // Resumed game - preserve full history
                analysisData = {
                    initialState: JSON.parse(JSON.stringify(data.initialState)),
                    moves: data.moveHistory.map(m => JSON.parse(JSON.stringify(m))),
                    currentMoveIndex: data.moveHistory.length - 1,
                    isAnalysisMode: false
                };
            } else {
                // New game - start fresh
                analysisData = {
                    initialState: serializeGameState(),
                    moves: [],
                    currentMoveIndex: -1,
                    isAnalysisMode: false
                };
            }
            
            historyStack = [];
            renderGame();
            
            // Start move timer if applicable and it's our turn
            if (gameState.moveTimer > 0) {
                resetMoveTimer();
            }
        }
        
        function applyOnlineMove(moveData) {
            // Reconstruct the move from the data
            if (moveData.type === 'movement') {
                // Select the glyph
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const glyphIndex = hand.findIndex(g => 
                    g.type === moveData.glyphUsed.type && g.value === moveData.glyphUsed.value
                );
                
                if (glyphIndex === -1) {
                    console.error('Could not find glyph for online move');
                    return;
                }
                
                gameState.selectedGlyph = { player: gameState.currentPlayer, index: glyphIndex };
                gameState.selectedPiece = { row: moveData.from.row, col: moveData.from.col };
                
                // Set shadow primed ONLY if shadow was placed - movePiece will handle placement
                gameState.shadowPrimed = moveData.shadowPlaced !== null;
                
                // Execute the move
                saveState();
                movePiece(moveData.from.row, moveData.from.col, moveData.to.row, moveData.to.col);
                
            } else if (moveData.type === 'reactivation') {
                // Select the glyph
                const hand = gameState.currentPlayer === 'dark' ? gameState.darkHand : gameState.lightHand;
                const glyphIndex = hand.findIndex(g => 
                    g.type === moveData.glyphUsed.type && g.value === moveData.glyphUsed.value
                );
                
                // Find the mask
                const supply = gameState.currentPlayer === 'dark' ? gameState.darkSupply : gameState.lightSupply;
                const maskIndex = supply.masks.findIndex(m => 
                    m.shape === moveData.mask.shape && m.color === moveData.mask.color
                );
                
                if (glyphIndex === -1 || maskIndex === -1) {
                    console.error('Could not find glyph or mask for online reactivation', {
                        glyphIndex, maskIndex,
                        searchedGlyph: moveData.glyphUsed,
                        searchedMask: moveData.mask,
                        hand: hand,
                        masks: supply.masks
                    });
                    return;
                }
                
                gameState.selectedGlyph = { player: gameState.currentPlayer, index: glyphIndex };
                gameState.selectedMask = maskIndex;
                
                // Execute the reactivation
                executeReactivation(moveData.position.row, moveData.position.col, maskIndex);
            }
            
            // Clear selection state
            gameState.selectedGlyph = null;
            gameState.selectedPiece = null;
            gameState.selectedMask = null;
            gameState.shadowPrimed = false;
            
            renderGame();
        }
        
        function showDrawOfferFromOpponent() {
            const opponent = localPlayer === 'dark' ? 'light' : 'dark';
            document.getElementById('drawOfferMessage').textContent = 
                `${capitalize(opponent)} offers a draw. Do you accept?`;
            document.getElementById('drawOfferModal').classList.add('show');
        }
        
        function showDisconnectModal() {
            document.getElementById('disconnectModal').classList.add('show');
        }
        
        function closeDisconnectModal() {
            document.getElementById('disconnectModal').classList.remove('show');
            // Return to welcome screen
            document.getElementById('welcomeModal').classList.add('show');
        }
        
        function exportAndCloseDisconnect() {
            // Export the game
            exportGameJSON();
            // Close disconnect modal
            document.getElementById('disconnectModal').classList.remove('show');
            // Return to welcome screen
            document.getElementById('welcomeModal').classList.add('show');
        }
        
        function resumeFromDisconnect() {
            // Close disconnect modal
            document.getElementById('disconnectModal').classList.remove('show');
            // Go directly to online setup with backup ready
            showOnlineModalWithBackup();
        }
        
        function showOnlineModalWithBackup() {
            const backup = getOnlineGameBackup();
            if (!backup) {
                // No backup, just show normal online modal
                setGameMode('online');
                return;
            }
            
            // Store backup for use
            loadedGameForOnline = backup;
            
            // Restore player names if available
            if (backup.localPlayerName) {
                document.getElementById('playerNameInput').value = backup.localPlayerName;
            }
            if (backup.remotePlayerName) {
                document.getElementById('opponentNameInput').value = backup.remotePlayerName;
            }
            
            // Set side to what they were playing
            if (backup.localPlayer) {
                setHostSide(backup.localPlayer);
            }
            
            // Show the online modal
            document.getElementById('newGameModal').classList.add('show');
            setGameMode('online');
        }
        
        function resumeFromBackup() {
            const backup = getOnlineGameBackup();
            if (!backup) {
                alert('No saved game found.');
                return;
            }
            
            // Store backup for use
            loadedGameForOnline = backup;
            
            // Create the game with loaded state
            createOnlineGameWithLoadedState();
        }
        
        function discardBackup() {
            clearOnlineGameBackup();
            document.getElementById('onlineBackupBanner').style.display = 'none';
            // Reset inputs
            document.getElementById('playerNameInput').value = '';
            document.getElementById('opponentNameInput').value = '';
            setHostSide('random');
        }
        
        // Check if it's the local player's turn in online mode
        function isLocalPlayerTurn() {
            if (!onlineMode) return true;
            return gameState.currentPlayer === localPlayer;
        }
        
        function updateOnlineIndicator() {
            const indicator = document.getElementById('onlineIndicator');
            const dot = document.getElementById('onlineIndicatorDot');
            const text = document.getElementById('onlineIndicatorText');
            
            if (!onlineMode) {
                indicator.style.display = 'none';
                return;
            }
            
            indicator.style.display = 'block';
            
            if (isLocalPlayerTurn()) {
                dot.style.background = '#4ade80'; // Green
                text.textContent = 'Your turn';
            } else {
                dot.style.background = '#fbbf24'; // Yellow
                text.textContent = 'Waiting...';
            }
        }
    </script>
</body>
</html>
